<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>k8s基础教程</title>
    <link href="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <url>/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="一、k8s安装教程"><a href="#一、k8s安装教程" class="headerlink" title="一、k8s安装教程"></a>一、k8s安装教程</h2><h3 id="1-安装要求"><a href="#1-安装要求" class="headerlink" title="1.安装要求"></a>1.安装要求</h3><ul><li><strong>3台以上机器，操作系统 CentOS7.7以上64位系统</strong></li><li><strong>硬件配置：2GB或更多RAM，2个CPU或更多CPU，硬盘30GB或更多</strong></li><li><strong>集群中所有机器之间网络互通</strong></li><li><strong>可以访问外网，需要拉取镜像</strong></li><li><strong>禁止swap分区</strong></li></ul><h3 id="2-centos7兼容版本-7-7-7-9"><a href="#2-centos7兼容版本-7-7-7-9" class="headerlink" title="2.centos7兼容版本(7.7~7.9)"></a>2.centos7兼容版本(7.7~7.9)</h3><table><thead><tr><th>Kubernetes 版本d</th><th>支持的 Docker 版本范围</th></tr></thead><tbody><tr><td>1.21</td><td>1.19.03, 1.20.02, 20.10.x</td></tr><tr><td>1.20</td><td>1.19.03, 1.20.02, 20.10.x</td></tr><tr><td>1.19</td><td>1.18.09, 1.19.03</td></tr><tr><td>1.18</td><td>1.17.09, 1.18.09, 1.19.03</td></tr><tr><td>1.17</td><td>1.13.13, 1.18.09</td></tr></tbody></table><h3 id="3-三台主机"><a href="#3-三台主机" class="headerlink" title="3.三台主机"></a>3.三台主机</h3><p>搭建k8s集群，三台主机，每台至少2G以上</p><table><thead><tr><th>主机</th><th>说明</th></tr></thead><tbody><tr><td>192.168.2.201</td><td>k8s-master</td></tr><tr><td>192.168.2.202</td><td>k8s-node1</td></tr><tr><td>192.168.2.203</td><td>k8s-node2</td></tr></tbody></table><p><strong>备注：本次装机选用k8s 1.19.16版本，dokcer1.18.09版本</strong></p><h3 id="4-安装docker-三台主机都需要安装"><a href="#4-安装docker-三台主机都需要安装" class="headerlink" title="4.安装docker(三台主机都需要安装)"></a>4.安装docker(三台主机都需要安装)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">卸载旧版本</span><br>sudo yum remove docker \<br>                docker-client \<br>                docker-client-latest \<br>                docker-common \<br>                docker-latest \<br>                docker-latest-logrotate \<br>                docker-logrotate \<br>                docker-engine<br><br>sudo yum update -y<br><br>sudo yum install -y yum-utils device-mapper-persistent-data lvm2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">配置docker的yum地址</span><br>sudo yum-config-manager \<br>--add-repo \<br>http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装指定docker版本</span><br>sudo yum -y install docker-ce-18.09.9 docker-ce-cli-18.09.9 containerd.io<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">启动dokcer并开机自启</span><br>sudo systemctl start docker<br>sudo systemctl enable docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Docker配置修改</span><br>vim /etc/docker/daemon.json<br><br>&#123;<br>  &quot;graph&quot;: &quot;/data/docker&quot;,<br>  &quot;registry-mirrors&quot;: [<br>  &quot;https://xv8xjvpp.mirror.aliyuncs.com&quot;,<br>        &quot;https://docker.m.daocloud.io/&quot;,<br>        &quot;https://dockerproxy.com/&quot;,<br>        &quot;https://mirror.baidubce.com/&quot;,<br>        &quot;https://docker.nju.edu.cn/&quot;,<br>        &quot;https://ccr.ccs.tencentyun.com/&quot;<br>  ],<br>  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],<br>  &quot;log-driver&quot;: &quot;json-file&quot;,<br>  &quot;log-opts&quot;: &#123;<br>    &quot;max-size&quot;: &quot;100m&quot;<br>  &#125;,<br>  &quot;storage-driver&quot;: &quot;overlay2&quot;<br>&#125;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">加载配置文件并重启docker</span><br>sudo systemctl daemon-reload<br>sudo systemctl restart docker<br><br><br><br><br></code></pre></td></tr></table></figure><h3 id="5-主机环境配置-三台都需要"><a href="#5-主机环境配置-三台都需要" class="headerlink" title="5.主机环境配置(三台都需要)"></a>5.主机环境配置(三台都需要)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1.关闭防火墙</span><br>sudo systemctl stop firewalld<br>sudo systemctl disable firewalld<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.关闭selinux</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">selinux禁用</span><br>setenforce 0<br>sed -i &#x27;s/enforcing/disabled/&#x27; /etc/selinux/config<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.关闭swap分区</span><br>swapoff -a   <br>vim /etc/fstab # 注释到swap那一行  永久关闭<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.设置主机名</span><br>hostnamectl set-hostname k8s-master<br>hostnamectl set-hostname k8s-node1<br>hostnamectl set-hostname k8s-node2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4.添加host,IP需要改成你自己机器的IP</span><br>cat &gt;&gt; /etc/hosts &lt;&lt; EOF<br>192.168.2.201 k8s-master<br>192.168.2.202 k8s-node1<br>192.168.2.203 k8s-node2<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">5.允许iptables 检查桥接流量</span><br>cat &gt; /etc/sysctl.d/k8s.conf &lt;&lt; EOF<br>net.ipv4.ip_forward = 1<br>net.ipv4.tcp_tw_recycle = 0<br>net.bridge.bridge-nf-call-ip6tables = 1<br>net.bridge.bridge-nf-call-iptables = 1<br>EOF<br>sysctl --system<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">6.设置时间同步</span><br>yum install -y ntpdate<br>ntpdate time.windows.com<br></code></pre></td></tr></table></figure><h3 id="6-安装kubelet-kubeadm-kubectl-三台机器都需要执行"><a href="#6-安装kubelet-kubeadm-kubectl-三台机器都需要执行" class="headerlink" title="6.安装kubelet,kubeadm,kubectl(三台机器都需要执行)"></a>6.安装kubelet,kubeadm,kubectl(三台机器都需要执行)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">1.配置k8s的yum源</span><br>cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo<br>[kubernetes]<br>name=Kubernetes<br>baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/<br>enabled=1<br>gpgcheck=1<br>repo_gpgcheck=1<br>gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg<br>EOF<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">2.如果之前安装了k8s,先卸载旧版本</span><br>yum -y remove kubelet kubeadm kubectl<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">3.查看可以安装的版本</span><br><span class="hljs-meta prompt_"> #</span><span class="language-bash">可以将 kubelet 替换为 kubeadm 或 kubectl，以查看相应组件的可用版本</span><br>yum list --showduplicates kubelet | sort -r   <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">4，安装指定的kubelet，kubeadm，kubectl版本</span><br>sudo yum install -y kubelet-1.19.16 kubeadm-1.19.16 kubectl-1.19.16<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启动kubelet并卡机自启</span><br>sudo systemctl start kubelet<br>sudo systemctl enable kubelet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">检查k8s是否启动</span><br>sudo systemctl status kubelet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">排查错误</span><br>journalctl -xefu kubelet<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">master主机上执行</span><br>sudo kubeadm init \<br>--control-plane-endpoint=k8s-master<br>--pod-network-cidr=192.168.0.0/16 \<br>--service-cidr=10.96.0.0/12 \<br>--apiserver-advertise-address=192.168.2.201 \<br>--kubernetes-version=v1.19.16 \<br>--image-repository registry.aliyuncs.com/google_containers<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">master主机上执行</span><br>mkdir -p $HOME/.kube<br>sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config<br>sudo chown $(id -u):$(id -g) $HOME/.kube/config<br>export KUBECONFIG=/etc/kubernetes/admin.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">手动拉取(三台机器都要)</span><br>docker pull docker.io/calico/cni:v3.20.6<br>docker pull docker.io/calico/kube-controllers:v3.20.6<br>docker pull docker.io/calico/node:v3.20.6<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装网络插件 Calico(仅master主机需要)</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">下载calico.yaml</span><br>mkdir /root/k8s<br>cd /root/k8s<br>wget https://docs.projectcalico.org/v3.20/manifests/calico.yaml<br>kubectl apply -f calico.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">申请一个新令牌</span><br>kubeadm token create --print-join-command<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">加入node节</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">复制新生成的令牌</span><br>kubeadm join 192.168.2.201:6443 --token xxxx     --discovery-token-ca-cert-hash sha256:xxxxx<br><br></code></pre></td></tr></table></figure><h2 id="二、k8s基础命令"><a href="#二、k8s基础命令" class="headerlink" title="二、k8s基础命令"></a>二、k8s基础命令</h2><h3 id="2-1-kubectl命令使用"><a href="#2-1-kubectl命令使用" class="headerlink" title="2.1 kubectl命令使用"></a>2.1 kubectl命令使用</h3><p><strong>使用kubectl 查看</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">Cluster Management Commands:<br>  certificate   修改 certificate 资源.<br>  cluster-info  显示集群信息<br>  top           Display Resource (CPU/Memory/Storage) usage.<br>  cordon        标记 node 为 unschedulable<br>  uncordon      标记 node 为 schedulable<br>  drain         Drain node in preparation for maintenance<br>  taint         更新一个或者多个 node 上的 taints<br><br>Troubleshooting and Debugging Commands:<br>  describe      显示一个指定 resource 或者 group 的 resources 详情<br>  logs          输出容器在 pod 中的日志<br>  attach        Attach 到一个运行中的 container<br>  exec          在一个 container 中执行一个命令<br>  port-forward  Forward one or more local ports to a pod<br>  proxy         运行一个 proxy 到 Kubernetes API server<br>  cp            复制 files 和 directories 到 containers 和从容器中复制 files 和 directories.<br>  auth          Inspect authorization<br><br>Advanced Commands:<br>  diff          Diff live version against would-be applied version<br>  apply         通过文件名或标准输入流(stdin)对资源进行配置<br>  patch         使用 strategic merge patch 更新一个资源的 field(s)<br>  replace       通过 filename 或者 stdin替换一个资源<br>  wait          Experimental: Wait for a specific condition on one or many resources.<br>  convert       在不同的 API versions 转换配置文件<br>  kustomize     Build a kustomization target from a directory or a remote url.<br><br>Settings Commands:<br>  label         更新在这个资源上的 labels<br>  annotate      更新一个资源的注解<br>  completion    Output shell completion code for the specified shell (bash or zsh)<br><br>Other Commands:<br>  alpha         Commands for features in alpha<br>  api-resources Print the supported API resources on the server<br>  api-versions  Print the supported API versions on the server, in the form of &quot;group/version&quot;<br>  config        修改 kubeconfig 文件<br>  plugin        Provides utilities for interacting with plugins.<br>  version       输出 client 和 server 的版本信息<br></code></pre></td></tr></table></figure><h3 id="2-2-Namespace"><a href="#2-2-Namespace" class="headerlink" title="2.2 Namespace"></a>2.2 Namespace</h3><p>k8s中，<strong>命名空间(Namespace)</strong> 提供一种机制同一集群中的资源划分为相互隔离的组，同一命名空间内的资源名称要唯一，命名空间是用来隔离资源的，不隔离网路。</p><p>kubernetes启动时会创建四个初始命名空间：</p><ul><li><strong>default</strong></li></ul><p>kubernetes包含这个命名空间，以便你无需创建新的命名空间即可开始使用新集群</p><ul><li><strong>kube-node-lease</strong></li></ul><p>该命名空间包含用于各个节点关联的**Lease(租约)**对象。节点租约允许kubelet发送心跳，由此控制能够检测到节点故障。</p><ul><li><strong>kube-public</strong></li></ul><p>所有的客户端(包括未经身份验证的客户端)都可以读取该命名空间。该命名空间主要预留未集群使用，以便某些资源需要在整个集群中可见可读。该命名空间的公属性是一种约定而非要求。</p><ul><li><strong>kube-system</strong></li></ul><p>该命名空间使用kubernetes系统创建的对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">查看namespace</span><br>kubectl get namespace<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看kube-system下的pod</span><br>kubectl get pods -n kube-system<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看所有namespace下的pod</span><br>kubectl get pods -A<br></code></pre></td></tr></table></figure><p><strong>创建Namespace</strong></p><ul><li><strong>命令行方式</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create namespace XXXXX<br></code></pre></td></tr></table></figure><ul><li><strong>yaml方式</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#XXXXX.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-namespace</span><br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl create -f XXXXX.yaml<br></code></pre></td></tr></table></figure><p><strong>删除namespace</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl delete namespace XXXXX<br><br>kubectl delete -f XXXXX.yaml<br></code></pre></td></tr></table></figure><h3 id="2-3-Pod"><a href="#2-3-Pod" class="headerlink" title="2.3 Pod"></a>2.3 Pod</h3><p>Pod是可以运行在kubernetes中创建和管理的、最小的可部署的计算单元。Pod是一组(一个或多个)容器；这些容器共享存储、网络、以及怎样运行这些 容器的生命。</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/pod.jpg" class="" title="k8s基础教程"><p><strong>创建Pod示例：运行一个NGINX容器</strong></p><ul><li><strong>命令方式</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">创建pod</span><br>kubectl run mynginx --image=nginx:1.14<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">获取pod的信息，-owide 表示更详细的显示信息 -n 命名空间 查询对应namespace下的pod</span><br>kubectl get pod<br>kubectl get pod -owide<br>kubectl get pod -n &lt;namespace-name&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看pod的详情</span><br>kubctl describe pod &lt;pod-name&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看pod的运行日志</span><br>kubectl logs &lt;pod-name&gt;<br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除pod</span><br>kubectl delete pod &lt;pod-name&gt;<br><br></code></pre></td></tr></table></figure><ul><li><strong>yaml方式</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#nginx-pod.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">mynginx</span><br>  <span class="hljs-attr">labels:</span><br>  <span class="hljs-string">run:mynginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br></code></pre></td></tr></table></figure><h3 id="2-4-Deployment"><a href="#2-4-Deployment" class="headerlink" title="2.4 Deployment"></a>2.4 Deployment</h3><p>Deployment负责创建和更新应用程序的实例，使<strong>Pod拥有多副本，自愈，扩容等能力</strong>。创建Deployment后，kubernetes master将应用程序实列调整到集群中的各个节点上。如果托管实列的节点关闭或被删除，Deployment控制器会将该实例替换为集群中另一个节点上的实例，这提供了一种自我修复机制来解决机器故障维护问腿。</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/deploy.png" class="" title="k8s基础教程"><p><strong>创建一个Tomcat应用程序</strong></p><ul><li><strong>命令行形式</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">my-tomcat表示pod的名称 --image表示镜像的地址</span><br>kubectl create deployment  my-tomcat --image=tomcat:9.0.55<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看deployment的信息</span><br>kubectl get deployment<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除deployment</span><br>kubectl delete deployment my-tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看Pod日志</span><br>kubectl logs my-tomcat-XXXX<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用<span class="hljs-built_in">exec</span>可以在pod的容器中执行命令</span><br>kubectl exec -it &lt;pod_name&gt; -- /bin/bash<br></code></pre></td></tr></table></figure><ul><li><strong>yaml方式</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-deployment</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>  <span class="hljs-comment"># 定义了 3 个副本</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-deployment</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">tomcat-deployment</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.14.2</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">修改 replicas</span><br>kubectl edit deployment my-tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">扩容和缩容</span><br>kubectl scale deployment my-tomcat --replicas=5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">滚动升级</span><br>kubectl set image deployment  my-tomcat tomcat=tomcat:10.1.11 --record<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看版本历史</span><br>kubectl rollout history deployment my-tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">回滚上一个版本</span><br>kubectl rollout undo deployment my-tomcat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">回滚指定版本</span><br>kubectl rollout undo deployment my-tomcat --to-revision=2 <br></code></pre></td></tr></table></figure><h3 id="2-5-Service"><a href="#2-5-Service" class="headerlink" title="2.5 Service"></a>2.5 Service</h3><p><strong>Service</strong>是一个抽象层，它定义了一组Pod的逻辑集，并为这些Pod支持外部流量暴露、负载均衡和服务发现。</p><p>尽管每个Pod都有一个唯一的IP地址，但是如果没有Service，这些IP不会暴露在集群外部。Service允许您的应用程序接收流量。Service也可以用在ServiceSpect标记type的方式暴露，type类型如下：</p><ul><li>**ClusterIP(默认)：**在集群的内部IP上公开Service。这种类型使得Service只能从集群内访问。</li><li><strong>NodePort:</strong> 使用NAT在集群中每个选定的Node的相同端口上公开Service。使用:从集群外部访问Service。是ClusterIP的超集。</li><li>**LoadBalancer:**在当前云中创建一个外部负载均衡器(如果支持的话)，并为Service分配一个固定的外部IP。NodePort的超集。</li><li><strong>ExternalName</strong>:通过返回带有该名称的CNAME记录，使用任意名称(由spec中的ExternalName指定)公开Service。不使用代理。</li></ul><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/service.jpg" class="" title="k8s基础教程"><p><strong>创建service示例</strong></p><ul><li><strong>命令行形式</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl expose deployment my-tomcat --port=8080 --type=NodePort<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看service信息，port信息冒号后面的端口号就是对集群外暴露的访问接口</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">NodePort范围在 30000-32767之间</span><br>kubectl get svc -owide<br></code></pre></td></tr></table></figure><ul><li><strong>yaml形式</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>  <span class="hljs-attr">app:</span> <span class="hljs-string">my-tomcat</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-tomcat</span>  <span class="hljs-comment"># Service 的名称</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span> <span class="hljs-comment">#service的虚拟ip对应的端口，在集群内网机器可以访问用service的虚拟ip加该端口号访问</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30001</span> <span class="hljs-comment">#Service在宿主主机上映射的外网访问端口，端口范围必须在30000~32767</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>  <span class="hljs-comment"># Service 暴露的端口</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span>  <span class="hljs-comment"># 被暴露的 Pod 的容器端口，一般与pod内部容器暴露的端口一致</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-comment"># Service 类型，可以是 ClusterIP、NodePort、LoadBalancer 等</span><br></code></pre></td></tr></table></figure><h3 id="2-6存储"><a href="#2-6存储" class="headerlink" title="2.6存储"></a>2.6存储</h3><p><strong>Volume</strong></p><p>Volume指的是存储卷，包含可被Pod中容器访问的数据目录。容器中的文件在磁盘上是临时存放的，当容器崩溃时文件会丢失，同事无法在多个Pod中共享文件，通过使用存储卷可以解决这问题。</p><p>kubernetes 支持很多类型的卷。Pod可以同时使用任意数目的卷类型。临时卷类型的生命周期与Pod相同，但持久卷可以比Pod的存活期长。当Pod不再存在时，kubernetes 也会销毁临时卷；不过kubernetes 不会销毁永久卷。对于给定的Pod中任何类型的卷，在容器重启期间数据都不会丢失。</p><p>卷的核心就是一个目录，其中可能存有数据，Pod中的容器可以访问该目录中的数据。所采用的不同卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的东西。常见有<strong>confingMap</strong>、<strong>emptyDir</strong>、<strong>local</strong>、<strong>nfs</strong>、<strong>secret</strong>等。</p><ul><li><p><strong>ConfingMap</strong>：可以将配置文件以键值对的形式保存到ConfigMap中，并且可以在Pod中以文件或环境变量的形式使用。ConfigMap可以用来存储不敏感的配置信息，如应用程序的配置文件。</p></li><li><p><strong>EmptyDir</strong>：是一个空目录，可以在Pod用来存储临时数据，当Pod删除时，该目录也会删除。</p></li><li><p><strong>Local</strong>：将本地文件系统的目录或文件映射到Pod中的一个Volume中，可以用来在Pod中共享文件或数据。</p></li><li><p><strong>NFS</strong>：将网络上的一个或多个NFS共享目录挂载到Pod中的Volume中，可以用来在多个Pod之间共享数据。</p></li><li><p><strong>Secret</strong>：将敏感信息以密文的形式保存到Secret中，并且可以在Pod中以文件或环境变量的形式使用。Secret可以用来存储敏感信息，如用户的密码、证书等。</p></li></ul><p><strong>使用方式</strong></p><p>使用卷时，在**.spec.volumes<strong>字段中设置为Pod提供的卷，并在</strong>.spec.containers[*].volumeMounts**字段中生明卷在容器中挂载位置。容器中的进程看到的文件系统试图是由他们的容器镜像的初始内容以及挂载在容器中的卷(r如果定义了的话)所组成的。其中根文件系统同容器镜像中的内容相吻合。任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。</p><h3 id="2-7Ingress"><a href="#2-7Ingress" class="headerlink" title="2.7Ingress"></a>2.7Ingress</h3><p><strong>Ingress</strong> 是一种kubernetes资源类型，它允许kubernetes 集群中暴露HTTP和HTTPS服务。通过Ingress，你可以将流量路由到不同的服务和端口点，而无需使用不同的负载均衡器。Ingress通常使用Ingress Contrller实现，它是一个运行在kubernetes 集群中的负载均衡器，它根据Ingress规则下面是一个将所有流量都发送到同一Service的简单Ingress示例：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/ingress.png" class="" title="k8s基础教程"><p><strong>Ingress和Service区别</strong></p><p>Ingress和Service都是kubernetes中用于将流量路由到应用的机制，但他们是在路由层面上有所不同：</p><ul><li><strong>Service</strong>是kubernetes中抽象的应用程序服务，它公开了一个单一的IP地址和端口，可以用于在kubernetes集群内部的Pod之间进行流量路由。</li><li><strong>Ingress</strong>是一个kubernetes资源对象，它提供了对集群外部路由的规则。Ingress通过一个公共IP地址和端口将流量路由到一个或多个Service。</li></ul><p><strong>安装Ingress</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">检查 Ingress 控制器 Pod 状态</span><br>kubectl get pods -n ingress-nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">检查 Ingress 控制器服务</span><br>kubectl get svc -n ingress-nginx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看是否安装成功</span><br>kubectl get pod,svc -n ingress-nginx -owide<br></code></pre></td></tr></table></figure><p><strong>使用Ingress</strong></p><p>官网地址：<a href="https://kubernetes.github.io/ingress-nginx/">https://kubernetes.github.io/ingress-nginx/</a></p><h2 id="三、k8s核心原理"><a href="#三、k8s核心原理" class="headerlink" title="三、k8s核心原理"></a>三、k8s核心原理</h2><h3 id="3-1-k8s的网络模型"><a href="#3-1-k8s的网络模型" class="headerlink" title="3.1 k8s的网络模型"></a>3.1 k8s的网络模型</h3><p>k8s的网络中主要存在4种类型的通信：</p><ul><li>同一Pod内的容器通信</li><li>各个Pod彼此间的通信</li><li>Pod和Service间的通信</li><li>集群外部流量和Service之间的通信</li></ul><p>k8s为Pod和Service资源对象分别使用了各自的专有网络，Pod网络由K8s的网络插件配置实现，而Service网络则由K8s集群进行指定。如下图：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%8E%9F%E7%90%861.jpg" class="" title="k8s基础教程"><p>k8s使用的网路插件需要为每个Pod配置至少一个特定的地址，即Pod IP。Pod IP地址实际存在于某个网卡(可以是虚拟机设备)上。</p><p>而Service的地址是一个虚拟IP地址，没有任何网络接口配置在此地址上，它由kube-proxy借助iptable规则或ipvs规则重定向到本地端口 ，再将其调度到后端的Pod对象。Service的IP地址是集群提供服务的接口，也称为Cluster IP。</p><p>Pod网络和IK8s的网络插件负责和管理，具体使用的网络地址可以再管理网络插件时进行指定，如192.168.0.0&#x2F;16网络。而Cluster网络和IP是由负责配置和管理，如192.96.0.0&#x2F;12网络。</p><p>从上图进行总结起来，一个k8s集群包含的是三个网络。</p><ul><li>**节点网络：**各主机(Master、Node、ETCD等)自身所属的网络，地址配置在主机的网络接口，用于各主机之间的通信，又称为节点网络。</li><li>**Pod网络 ：**专用于Pod资源对象的网络，它是一个虚拟网络，用于为各个Pod对象设定IP地址等网络参数，其地址配置在Pod种容器的接口上。Pod网络需要借助kubenet插件或CNI插件实现。</li><li><strong>Service网络</strong>：专用于Service资源对象的网络，它也是一个虚拟网络，用于k8s集群之中的Service配置IP地址，但是该地址不会配置在任何主机或容器的网络接口上，而是通过Node上的kube-proxy配置为iptable或ipvs规则，从而将发往该地址的所有流量调度到后端的各Pod对象之上。</li></ul><h3 id="3-2k8s的-工作流程"><a href="#3-2k8s的-工作流程" class="headerlink" title="3.2k8s的 工作流程"></a>3.2k8s的 工作流程</h3><p>用k8s部署Nginx的过程中，k8s内部各组件是如何协同工作的；</p><p>我们在master节点上执行一条命令master部署nginx应用(kubectl create deployment nginx –image&#x3D;nginx)</p><ul><li>这条命令首先发到master节点的网关api servcer,这是master的唯一入口</li><li>api server将命令请求给controller manager进行控制</li><li>controller manager进行应用部署分析</li><li>controller manager 会生成一次部署信息，并通过api serve将信息存入etcd存储中</li><li>scheduler调度器通过api serverc从etcd存储中，拿到要部署的应用，开始调度看哪个节点由资源适合部署</li><li>scheduler把计算出来的调度信息通过api server 再放到etcd中</li><li>每个node节点的监控组件kubectl,随时和master保持联系(给api-server发送请求不断获取最新数据)，拿到master节点存储在etcd中的部署信息</li><li>假设node2的kubectl拿到部署信息，显示他自己节点要部署某某应用</li><li>kubelet就自己run一个应用在当前机器上，并随时给master汇报当前应用的状态信息</li><li>node和master也是通过master的api-server组件联系的</li><li>每一个机器上的kube-porxy能知道集群的所有网络，只要node访问别人或者别人访问node,node上的kube-porxy网络代理自动计算进行流量转发</li></ul><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%8E%9F%E7%90%862.png" class="" title="k8s基础教程"><p>k8s是属于<strong>Master-Worker</strong>架构，即有Master节点负责核心的调度、管理和运维，Worker节点规则执行用户的程序。但是在看k8s中，主节点一般称为<strong>Master Node</strong>，而从节点则被称为<strong>Worker Node</strong>或者<strong>Node</strong>。</p><p>注意：Master Node和Work Node分别安装了k8s的Master和Worker组件的实体服务器，每个Node都对应了一台实体服务器(虽然Master Node可以和其中一个Worker Node安装在同一台服务器，但是建议Master Node单独部署)，所有Master Node 和Worker Node组成了K8s集群，同一个集群可能存在多个Master Node 和Worker。Node</p><h3 id="3-3-K8s架构六连问"><a href="#3-3-K8s架构六连问" class="headerlink" title="3.3 K8s架构六连问"></a>3.3 K8s架构六连问</h3><p>k8s是一个基于容器技术的分布式集群管理系统。既然是个分布式系统，那势必有多个Node节点(物理主机或虚拟机)，它们组成一个分布式集群，并且这些节点中会有一个Master节点，由它来统一管理Node节点。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%8E%9F%E7%90%863.png" class="" title="k8s基础教程"><p><strong>问题一：主节点和工作节点是如何工作通信的呢？</strong></p><p>首先，Master节点启动时，会运行一个kube-apiserver进程，它提供了集群管理的API接口，是集群内各个功能模块之间数据交互和通信的中心枢纽，并且它也提供了完备的集群安全机制。</p><p>在Node节点上，使用k8s中的kubelet组件，在每个Node节点上都会运行一个kubelet进程，它负责向Master汇报自身节点的运行情况，如Node节点的注册、终止、定时上报健康状况等，以及接收Master发出的命令，创建相应Pod。</p><p>在k8s中，Pod是基本的操作单元，它与docker的容器略微有不同，因为Pod可能包含一个或多个容器(可以是docker容器)，这些内部的容器是共享网络资源的，即可通过locahost进行互相访问。</p><p>关于Pod内是如何做到网络共享的，每个Pod启动，内部都会启动一个pause容器(google的一个镜像)，它是使用默认的网络模式，而其他容器的网络都设置给它，以此来完成网络的共享问题。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E8%8A%82%E7%82%B9%E9%80%9A%E4%BF%A1.png" class="" title="k8s基础教程"><p><strong>问题二：Master是如何将Pod调度到指定的Node的？</strong></p><p>该工作由kube-scheduler来完成的，整个调度过程通过执行一些列复杂的算法最终为每个Pod计算出一个最佳的目标Pod调度到一个指定的Node上，我们可以通过节点的标签(Label)和Pod的nodeSelcetor属性的相互匹配，来达到指定的效果。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/pod%E8%B0%83%E5%BA%A6.png" class="" title="k8s基础教程"><p><strong>问题三：各节点、Pod的信息都是统一维护在哪里，由谁来维护？</strong></p><p>从上面的Pod调度角度看，我们的有一个存储中心，用来储存各节点资源使用情况、健康状态、以及各Pod的基本信息等，这样Pod的调度来能正常进行。</p><p>在k8s中采用etcd组件作为高可用强一致性的储存仓库，该组件可以内置在k8s中，也可以外部搭建拱k8s使用。</p><p>集群上的所有配置信息都储存在了etcd,为了考虑各个组件的相对独立，以及整体的维护性，对于这些存储数据的增、删、改、查，统一由kube-apiserver来进行调度，apiserver也提供了RESET的支持，不仅对各个内部组件提供服务外，还对集群外部用户暴露服务。</p><p>外部用户可以通过REST接口,或者kubectl命令行进行集群管理，其内在都是与apiserver进行通信。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/etcd.png" class="" title="k8s基础教程"><p><strong>问题四：外部用户如何访问集群内运行的</strong></p><p>前面讲了外部用户如何管理k8s，而我们更关心的是内部运行的Pod如何对外访问。使用过Docker的人都应当了解，如果使用bridge模式，在容器创建时，都会分配一个虚拟IP,该IP外部是没法访问到的，就可以访问到内部容器端口了。</p><p>那么，k8s的外部访问是否也是实现的？答案是否定的，k8s中情况要复杂些。因为docker是单机模式下的，而且一个容器对外就暴露一个服务。分布式集群下。一个服务往往由多个Application提供，用来分担访问压力，而且这些Application可能分布在多个节点上，这样又涉及了跨主机的通信。</p><p>这里，k8s引入了Service的概念，将多个相同的Pod包装成一个完整的service对外提供服务，至于获取到这些相同的Pod，每个Pod启动时都会设置labels属性，在Service中我们通过选择器Selector,选择具有相同Controller来完成。同时，每个节点上会启动一个kube-porxy进程，由它来负责服务地址到Pod地址的代理以及负载均衡等工作。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE.png" class="" title="k8s基础教程"><p><strong>问题五：Pod如何动态扩容和缩放？</strong></p><p>既然知道了服务是由Pod组成的，那么服务的扩容也就意味着Pod的扩容。通俗点讲，就是在需要时将Pod复制多份，在不需要后，将Pod缩减指定的份数。k8s中通过Replication Controller来进行管理，为每个Pod设置一个期望的副本数，当实际副本数与期望不符时，就动态的进行数量调整，以达到期望数值。期望数值可以由我们手动更新，或自动扩容代理来完成。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9%E7%BC%A9%E6%94%BE.png" class="" title="k8s基础教程"><p><strong>问题六：各个组件之间是如何相互协作的？</strong></p><p>最后，讲一下 kube-controller-manager这个进程的作用。我们知道了ectd是作为集群的储存中心，apiserver是管理数据中心，作为其他进程与数据中心通信的桥梁。而Service Controller、Replication Controller这些统一交由kube-controller-manager来管理，kube-controller-manager作为一个守护进程，每个Controller都是一个控制循环，通过apiserver监视集群的共享状态，并尝试将实际状态与期望状态不符合的进行改变。关于Controller，manager中包含了Node节点控制器(Node Controller)、资源配置额管控制器(Replication Controller)、命名空间控制器(Namespace Controller)等。</p><p>如图所示：</p><img src="/2025/04/18/k8s%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/%E7%BB%84%E4%BB%B6%E5%8D%8F%E4%BD%9C.png" class="" title="k8s基础教程"><p>相关链接：</p><p>Kubernetes文档：<a href="https://kubernetes.io/zh-cn/docs/home/">Kubernetes 文档 | Kubernetes</a></p>]]></content>
    
    
    <categories>
      
      <category>Container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>K8S</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像构建</title>
    <link href="/2025/04/18/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/"/>
    <url>/2025/04/18/Docker%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Docker镜像概念"><a href="#一、Docker镜像概念" class="headerlink" title="一、Docker镜像概念"></a>一、Docker镜像概念</h3><p>Docker 镜像是 Docker 容器运行时的只读模板，每⼀个镜像由一系列的层 (layers) 组成。Docker 使用UnionFS 来将这些层联合到单独的镜像中。UnionFS 允许独⽴⽂件系统中的文件和文件夹(称之为分支)被透明覆盖，形成⼀个单独连贯的⽂件系统。正因为有了这些层的存在，Docker 是如此的轻量。当你改变了⼀个 Docker 镜像，比如升级到某个程序到新的版本，一个新的层会被创建。因此，不用替换整个原先的镜像或者重新构建(在使用虚拟机的时候你可能会这么做)，只是⼀个新的层被添加或升级了。现在你不用重新发布整个镜像，只需要升级层，使得分发 Docker 镜像变得简单和快速。在 Docker 的术语里，⼀个只读层被称为镜像，⼀个镜像是永久不会变的。由于 Docker 使用⼀个统⼀文件系统，Docker 进程认为整个文件系统是以读写方式挂载的。 但是所有的变更都发生在顶层的可写层，而下层的原始的只读镜像⽂件并未变化。由于镜像不可写，所以镜像是无状态的。每⼀个镜像都可能依赖于由⼀个或多个下层的组成的另⼀个镜像。下层那个镜像是上层镜像的父镜像。<br><a href="https://imgse.com/i/wzZTdf"><img src="https://s11.ax1x.com/2020/09/24/wzZTdf.png" alt="wzZTdf.png" style="zoom:80%;" /></a></p><h3 id="二、Docker镜像的创建"><a href="#二、Docker镜像的创建" class="headerlink" title="二、Docker镜像的创建"></a>二、Docker镜像的创建</h3><h4 id="2-1-Docker镜像的创建方法"><a href="#2-1-Docker镜像的创建方法" class="headerlink" title="2.1 Docker镜像的创建方法"></a>2.1 Docker镜像的创建方法</h4><ol><li><strong>基于已有镜像创建</strong></li><li><strong>基于本地模板创建</strong></li><li><strong>基于Dockerfile创建</strong></li></ol><h4 id="2-2-基于已有镜像创建"><a href="#2-2-基于已有镜像创建" class="headerlink" title="2.2 基于已有镜像创建"></a>2.2 基于已有镜像创建</h4><ul><li>将容器里面运行的程序及运行环境打包生成新的镜像</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff">docker commit [选项] 容器ID/名称 仓库名称:[标签]<br><span class="hljs-deletion">-m：说明信息</span><br><span class="hljs-deletion">-a：作者信息</span><br><span class="hljs-deletion">-p：生成过程中停止容器的运行</span><br></code></pre></td></tr></table></figure><h4 id="2-3-基于本地模板创建"><a href="#2-3-基于本地模板创建" class="headerlink" title="2.3 基于本地模板创建"></a>2.3 基于本地模板创建</h4><ul><li><p>通过导入操作系统模板文件生成新的镜像</p></li><li><p>使用wget命令导入为本地镜像</p></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> http://download.openvz.org/template/precreated/debian-<span class="hljs-number">7</span>.<span class="hljs-number">0</span>-x86-minimal.tar.gz<br></code></pre></td></tr></table></figure><ul><li>导入成功后可查看本地镜像信息</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker images | <span class="hljs-keyword">grep</span> <span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure><h4 id="2-4-基于Dockerfile创建"><a href="#2-4-基于Dockerfile创建" class="headerlink" title="2.4 基于Dockerfile创建"></a>2.4 基于Dockerfile创建</h4><ul><li>Dockerfile是由一组指令组成的文件</li><li>Dockerfile结构四部分</li></ul><ol><li>基础镜像信息</li><li>维护者信息</li><li>镜像操作指令</li><li>容器启动时执行指令</li></ol><ul><li><p>Dockerfile每行支持一条指令，每条指令可携带多个参数，支持使用以”#“号开头的注释</p></li><li><p>Dockerfile操作指令</p></li></ul><table><thead><tr><th>指令</th><th>含义</th></tr></thead><tbody><tr><td>FROM 镜像</td><td>指定新镜像所基于的镜像，第一条指令必须为FROM指令，每创建一个镜像就需要一条FROM指令</td></tr><tr><td>MAINTAINER 名字</td><td>说明新镜像的维护人信息</td></tr><tr><td>RUN命令</td><td>在所基于的镜像上执行命令，并提交到新的镜像中</td></tr><tr><td>CMD[“要运行的程序”，“参数1”，“参数2”]</td><td>指令启动容器时要运行的命令或脚本，Dockerfile只能有一条CMD指令，如果要指定多条则只能最后一条执行</td></tr><tr><td>EXPOSE 端口号</td><td>指定新镜像加载到Docker时要开启端口</td></tr><tr><td>ENV 环境变量 变量值</td><td>设置一个环境变量的值，会被后面的RUN使用</td></tr><tr><td>ADD 源文件&#x2F;目录 目标文件&#x2F;目录</td><td>将源文件复制到目标文件，源文件要与Dockerfile位于相同目录中，或者是一个URL</td></tr><tr><td>COPY 源文件&#x2F;目录 目标文件&#x2F;目录</td><td>将本地主机上得文件&#x2F;目录复制到目标地点，源文件&#x2F;目录要与Dockerfile在相同的目录中</td></tr><tr><td>VOLUME[“目录”]</td><td>在容器中创建一个挂载点</td></tr><tr><td>USER 用户名&#x2F;UID</td><td>指定运行容器时的用户</td></tr><tr><td>WORKDIR路径</td><td>为后续的RUN、CMD、ENTRYPOINT指定工作目录</td></tr><tr><td>ONBUILD命令</td><td>指定所生成的镜像作为一个基础镜像时所要运行的命令</td></tr><tr><td>HEALTHCHECK</td><td>健康检查</td></tr></tbody></table><h5 id="2-4-1-实战：构建SSH镜像"><a href="#2-4-1-实战：构建SSH镜像" class="headerlink" title="2.4.1 实战：构建SSH镜像"></a>2.4.1 实战：构建SSH镜像</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-number">1</span>.新建一个sshd目录用于存放dockerfile及其所需文件<br>mkdir sshd<br>cd sshd<br><br><span class="hljs-number">2</span>.创建一个dockerfile文件<br>vim Dockerfile<br><br>写入如下dockerfile：<br><br><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> This is a test rongqi<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install openssh* net-tools lsof telent passwd</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;123456&#x27;</span> | passwd --stdin root</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/UsePAM yes/UsePAM no/g&#x27;</span> /etc/ssh/sshd_config</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;/^session\s\+required\s\+pam_loginuid.so/s/^/#/&#x27;</span> /etc/pam.d/sshd</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p /root/.ssh &amp;&amp; <span class="hljs-built_in">chown</span> root.root /root &amp;&amp; <span class="hljs-built_in">chmod</span> 700 /root/.ssh</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">22</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/sbin/sshd&quot;</span>,<span class="hljs-string">&quot;-D&quot;</span>]</span><br><br>//执行命令生成镜像<br>docker built -t sshd:new .<br><br>//启动容器并修改root密码<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P sshd:new</span><br><br>//从本地使用SSH进行登陆<br>ssh localhost -p <span class="hljs-number">32770</span>   <span class="hljs-comment">## 32770是映射的端口号</span><br></code></pre></td></tr></table></figure><h5 id="2-4-2-构建systemctl镜像"><a href="#2-4-2-构建systemctl镜像" class="headerlink" title="2.4.2 构建systemctl镜像"></a>2.4.2 构建systemctl镜像</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-number">1</span>.新建一个systemctl目录用于存放dockerfile及其所需文件<br>mkdir systemctl<br>cd systemctl<br><br><span class="hljs-number">2</span>.创建一个dockerfile文件<br>vim Dockerfile<br><br>写入如下dockerfile：<br><br><span class="hljs-keyword">FROM</span> sshd:new<br><span class="hljs-keyword">ENV</span> container docker<br><span class="hljs-keyword">RUN</span><span class="language-bash"> (<span class="hljs-built_in">cd</span> /lib/systemd/system/sysinit.target.wants/; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> *;<span class="hljs-keyword">do</span> [ <span class="hljs-variable">$i</span> == \</span><br><span class="language-bash">systemd-tmpfiles-setup.service ] || <span class="hljs-built_in">rm</span> -f <span class="hljs-variable">$i</span>; <span class="hljs-keyword">done</span>); \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/multi-user.target.wants/*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /etc/systemd/system/*.wants/*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/local-fs.target.wants/*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/sockets.target.wants/*udev*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/sockets.target.wants/*initctl*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/basic.target.wants/*; \</span><br><span class="language-bash"><span class="hljs-built_in">rm</span> -f /lib/systemd/system/anaconda.target.wants/*;</span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> [<span class="hljs-string">&quot;/sys/fs/cgroup&quot;</span>]</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/sbin/init&quot;</span>]</span><br><br>//生成镜像<br>docker build -t systemd:new .<br><br>//privateged container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限<br>//运行容器<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> --privileged -ti -v /sys/fs/cgroup:/sys/fs/cgroup:ro systemd:new /sbin/init &amp;</span><br></code></pre></td></tr></table></figure><h5 id="2-4-3-构建Nginx镜像"><a href="#2-4-3-构建Nginx镜像" class="headerlink" title="2.4.3 构建Nginx镜像"></a>2.4.3 构建Nginx镜像</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-number">1</span>.新建一个nginx目录用于存放dockerfile及其所需文件<br>mkdir nginx<br>cd nginx/<br><br><span class="hljs-number">2</span>.创建一个dockerfile文件<br>vim Dockerfile<br><br>写入如下dockerfile：<br><br><span class="hljs-keyword">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-keyword">MAINTAINER</span> Test nginx<br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> yum -y install gcc gcc-c++ zlib-devel pcre-devel make</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> useradd -M -s /sbin/nologin nginx</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> nginx-1.12.0.tar.gz /usr/local/src</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /usr/local/src/nginx-1.12.0</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> ./configure \</span><br><span class="language-bash">--prefix=/usr/local/nginx \</span><br><span class="language-bash">--user=nginx \</span><br><span class="language-bash">--group=nginx \</span><br><span class="language-bash">--with-http_stub_status_module &amp;&amp; make &amp;&amp; make install</span><br><span class="hljs-keyword">ENV</span> PATH /usr/local/nginx/sbin:$PATH<br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">443</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;daemon off;&quot;</span> &gt;&gt;/usr/local/nginx/conf/nginx.conf</span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> run.sh /run.sh</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> 755 /run.sh</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;/run.sh&quot;</span>]</span><br><br><span class="hljs-number">4</span>.创建一个nginx启动脚本<br><br><span class="hljs-comment">#!/bin/bash</span><br>/usr/local/nginx/sbin/nginx<br><br>//创建镜像<br>docker build -t nginx:new .<br><br>//运行容器<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> -d -P nginx:new   <span class="hljs-comment">## -P 随机映射端口</span></span><br></code></pre></td></tr></table></figure><h5 id="2-4-4-构建Tomcat镜像"><a href="#2-4-4-构建Tomcat镜像" class="headerlink" title="2.4.4 构建Tomcat镜像"></a>2.4.4 构建Tomcat镜像</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift">mkdir <span class="hljs-regexp">/opt/</span>tomcat<br>cd <span class="hljs-regexp">/opt/</span>tomcat<br><br>vim <span class="hljs-type">Dockerfile</span><br><br><span class="hljs-type">FROM</span> centos:<span class="hljs-number">7</span><br><span class="hljs-type">MAINTAINER</span> <span class="hljs-type">This</span> <span class="hljs-keyword">is</span> <span class="hljs-type">Tomcat</span><br><span class="hljs-type">ADD</span> jdk<span class="hljs-operator">-</span>8u91<span class="hljs-operator">-</span>linux<span class="hljs-operator">-</span>x64.tar.gz <span class="hljs-regexp">/usr/</span>local<br><span class="hljs-type">WORKDIR</span> <span class="hljs-regexp">/usr/</span>local<br><span class="hljs-type">RUN</span> mv jdk1.<span class="hljs-number">8.0_91</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-operator">/</span>java<br><span class="hljs-type">ENV</span> <span class="hljs-type">JAVA_HOME</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-operator">/</span>java<br><span class="hljs-type">ENV</span> <span class="hljs-type">JAVA_BIN</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>bin<br><span class="hljs-type">ENV</span> <span class="hljs-type">JRE_HOME</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jre<br><span class="hljs-type">ENV</span> <span class="hljs-type">PATH</span> <span class="hljs-variable">$PATH</span>:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>bin:<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jre<span class="hljs-operator">/</span>bin<br><span class="hljs-type">ENV</span> <span class="hljs-type">CLASSPATH</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jre<span class="hljs-regexp">/bin:/</span>usr<span class="hljs-regexp">/local/</span>java<span class="hljs-regexp">/lib:/</span>usr<span class="hljs-regexp">/local/</span>java<span class="hljs-regexp">/jre/</span>lib<span class="hljs-operator">/</span>charsets.jar<br><span class="hljs-type">ADD</span> apache<span class="hljs-operator">-</span>tomcat<span class="hljs-operator">-</span><span class="hljs-number">8.5</span>.<span class="hljs-number">16</span>.tar.gz <span class="hljs-regexp">/usr/</span>local<br><span class="hljs-type">WORKDIR</span> <span class="hljs-regexp">/usr/</span>local<br><span class="hljs-type">RUN</span> mv apache<span class="hljs-operator">-</span>tomcat<span class="hljs-operator">-</span><span class="hljs-number">8.5</span>.<span class="hljs-number">16</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-operator">/</span>tomcat8<br><span class="hljs-type">EXPOSE</span> <span class="hljs-number">8080</span><br>#<span class="hljs-type">CMD</span> [<span class="hljs-string">&quot;/usr/local/tomcat8/bin/catalina.sh&quot;</span>,<span class="hljs-string">&quot;run&quot;</span>]<br><span class="hljs-type">ENTRYPOINT</span> [<span class="hljs-string">&quot;/usr/local/tomcat8/bin/catalina.sh&quot;</span>,<span class="hljs-string">&quot;run&quot;</span>]<br><br><span class="hljs-comment">//创建镜像</span><br>docker build <span class="hljs-operator">-</span>t tomcat:centos .<br><br><span class="hljs-comment">//运行容器</span><br>docker run <span class="hljs-operator">-</span>d <span class="hljs-operator">--</span>name tomcat01 <span class="hljs-operator">-</span>p <span class="hljs-number">1216</span>:<span class="hljs-number">8080</span> tomcat:centos  ## <span class="hljs-operator">-</span>p 指定内外映射端口<br><br><span class="hljs-type">PS：</span><br>catalina.sh ——前台运行<br>startup.sh  ——后台运行<br></code></pre></td></tr></table></figure><h5 id="2-4-5-构建MySQL镜像（MySQL-5-7）"><a href="#2-4-5-构建MySQL镜像（MySQL-5-7）" class="headerlink" title="2.4.5 构建MySQL镜像（MySQL 5.7）"></a>2.4.5 构建MySQL镜像（MySQL 5.7）</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs gams">mkdir mysqld<br>cd mysqld<br><br>vim my.cnf<br><br>[client]<br>port=<span class="hljs-number">3306</span><br>default-character-<span class="hljs-keyword">set</span>=utf8<br>socket=/usr/local/mysql/mysql.sock<br><br>[mysql]<br>port=3306<br>default-character-<span class="hljs-keyword">set</span>=utf8<br>socket=/usr/local/mysql/mysql.sock<br><br>[mysqld]<br>user=mysql<br>basedir=/usr/local/mysql<br>datadir=/usr/local/mysql/data<br>port=<span class="hljs-number">3306</span><br>character_set_server=utf8<br>pid-<span class="hljs-keyword">file</span>=/usr/local/mysql/mysqld.pid<br>socket=/usr/local/mysql/mysql.sock<br>server-id=<span class="hljs-number">1</span><br><br>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_AUTO_VALUE_ON_ZERO,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,PIPES_AS_CONCAT,ANSI_QUOTES<br><br>vim Dockerfile<br><br>FROM centos:<span class="hljs-number">7</span><br>MAINTAINER This is MySQL<br>RUN yum -y install  \<br>ncurses \<br>ncurses-devel \<br>bison \<br>cmake \<br>make \<br>gcc \<br>gcc-c++<br>RUN useradd -s /sbin/noligin mysql<br>ADD mysql-boost<span class="hljs-number">-5.7</span><span class="hljs-number">.20</span>.tar.gz /usr/local/src<br>WORKDIR /usr/<span class="hljs-comment">local</span>/src/<span class="hljs-comment">mysql-5.7.20</span>/<br>RUN cmake \<br>-DCMAKE_INSTALL_PREFIX=/<span class="hljs-comment">usr</span>/local/<span class="hljs-comment">mysql \</span><br>-DMYSQL_UNIX_ADDR=/usr/local/mysql/mysql.sock <span class="hljs-comment">\</span><br>-DSYSCONFDIR=/etc \<br>-DSYSTEMD_PID_DIR=/usr/local/mysql <span class="hljs-comment">\</span><br>-DDEFAULT_CHARSET=utf8 <span class="hljs-comment">\</span><br>-DDEFAULT_COLLATION=utf8_general_ci <span class="hljs-comment">\</span><br>-DWITH_INNOBASE_STORAGE_ENGINE=1 \<br>-DWITH_ARCHIVE_STORAGE_ENGINE=1 \<br>-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \<br>-DWITH_PERFSCHEMA_STORAGE_ENGINE=1 \<br>-DMYSQL_DATADIR=/usr/local/mysql/data <span class="hljs-comment">\</span><br>-DWITH_BOOST=boost <span class="hljs-comment">\</span><br>-DWITH_SYSTEMD=1 &amp;&amp; make <span class="hljs-comment">&amp;&amp; make install</span><br>RUN <span class="hljs-comment">chown -R mysql:mysql</span> /usr/<span class="hljs-comment">local</span>/mysql/<br>RUN <span class="hljs-comment">rm -rf</span> /etc/<span class="hljs-comment">my.cnf</span><br>ADD <span class="hljs-comment">my.cnf</span> /etc<br>RUN chown mysql:mysql /<span class="hljs-comment">etc</span>/my.cnf<br>ENV PATH=/<span class="hljs-comment">usr</span>/local/<span class="hljs-comment">mysql</span>/bin:/<span class="hljs-comment">usr</span>/local/<span class="hljs-comment">mysql</span>/lib:$PATH<br>WORKDIR /<span class="hljs-comment">usr</span>/local/<span class="hljs-comment">mysql</span>/<br>RUN bin/<span class="hljs-comment">mysqld \</span><br>--initialize-insecure <span class="hljs-comment">\</span><br>--user=mysql <span class="hljs-comment">\</span><br>--basedir=/usr/local/mysql \<br>--datadir=/usr/local/mysql/data<br>RUN cp /usr/local/mysql/usr/lib/systemd/system/mysqld.service /usr/lib/systemd/<span class="hljs-keyword">system</span>/<br>EXPOSE <span class="hljs-comment">3306</span><br>RUN <span class="hljs-comment">echo -e</span> <span class="hljs-comment">&quot;#!/bin/bash \nsystemctl enable mysqld&quot;</span> <span class="hljs-comment">&gt;</span> /run.sh<br>RUN chmod <span class="hljs-number">755</span> /<span class="hljs-comment">run.sh</span><br>RUN <span class="hljs-comment">sh</span> /run.sh<br>CMD [<span class="hljs-comment">&quot;init&quot;</span>]<br><br><span class="hljs-comment">//构建镜像</span><br>docker build -t mysql:centos .<br><br><span class="hljs-comment">//启动容器</span><br>docker run --name=mysql_server -d -P --privileged mysql:centos<br>【注意】：如果不加--privileged，则会报错：Failed to get D-Bus connection: Operation <span class="hljs-keyword">not</span> permitted<br><br><span class="hljs-comment">//进入容器</span><br>docker exec -it xxxxxxxx bash    ## x为容器ID<br><br><span class="hljs-comment">//登陆mysql数据库</span><br>mysql -uroot -p<br>密码为空，直接回车即可<br><br><span class="hljs-comment">//设置远程访问权限</span><br>grant <span class="hljs-keyword">all</span> privileges on *.* to <span class="hljs-comment">&#x27;root&#x27;</span>@<span class="hljs-comment">&#x27;%&#x27;</span> identified by <span class="hljs-comment">&#x27;123456&#x27;</span>;<br><br><br><span class="hljs-comment">//在其他客户端进行远程登录</span><br>mysql -h <span class="hljs-number">192.168</span><span class="hljs-number">.50</span><span class="hljs-number">.142</span> -uroot -P -p123456<br></code></pre></td></tr></table></figure><p>文章来源<a href="%5BDocker%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%88%E5%9F%BA%E4%BA%8E%E5%B7%B2%E6%9C%89%E9%95%9C%E5%83%8F%E3%80%81%E6%9C%AC%E5%9C%B0%E6%A8%A1%E6%9D%BF%E3%80%81Dockerfile%EF%BC%89_docker%E9%95%9C%E5%83%8F%E6%9C%89%E5%A4%9A%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/u014042047/article/details/108768082?spm=1001.2014.3001.5506)">CSDN</a>  如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Container</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2025/04/18/MySQL%E7%B4%A2%E5%BC%95/"/>
    <url>/2025/04/18/MySQL%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<hr><p>索引是MySQL中用于提高查询性能的重要工具。正确的索引设计和使用可以显著提升数据库的查询效率，而错误的索引设计则可能导致性能下降。本文将详细介绍MySQL索引的各个方面，包括索引概述、索引结构、索引分类、索引语法、SQL性能分析、索引使用、索引设计原则以及面试高频问题。</p><hr><h3 id="1-索引概述"><a href="#1-索引概述" class="headerlink" title="1. 索引概述"></a>1. 索引概述</h3><h4 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h4><p>索引是数据库中用于加速数据检索的一种数据结构。它类似于书籍的目录，通过索引可以快速定位到数据的位置，而不需要扫描整个表。</p><h4 id="1-2-索引的作用"><a href="#1-2-索引的作用" class="headerlink" title="1.2 索引的作用"></a>1.2 索引的作用</h4><ul><li><p><strong>加速查询</strong>：索引可以显著提高查询速度，尤其是在大数据量的表中。</p></li><li><p><strong>优化排序和分组</strong>：索引可以帮助数据库快速完成排序和分组操作。</p></li><li><p><strong>保证数据唯一性</strong>：唯一索引可以确保某一列或多列的值唯一。</p></li></ul><h4 id="1-3-索引的代价"><a href="#1-3-索引的代价" class="headerlink" title="1.3 索引的代价"></a>1.3 索引的代价</h4><ul><li><p><strong>存储空间</strong>：索引需要占用额外的存储空间。</p></li><li><p><strong>写操作性能</strong>：索引会降低插入、更新和删除操作的性能，因为每次写操作都需要更新索引。</p></li></ul><hr><h3 id="2-索引结构"><a href="#2-索引结构" class="headerlink" title="2. 索引结构"></a>2. 索引结构</h3><h4 id="2-1-B-树索引"><a href="#2-1-B-树索引" class="headerlink" title="2.1 B+树索引"></a>2.1 B+树索引</h4><ul><li><p><strong>B+树</strong>是MySQL中最常用的索引结构，适用于范围查询和排序操作。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>所有数据都存储在叶子节点中，内部节点仅用于索引。</p></li><li><p>叶子节点通过指针连接，形成一个有序链表，便于范围查询。</p></li></ul></li></ul><h4 id="2-2-哈希索引"><a href="#2-2-哈希索引" class="headerlink" title="2.2 哈希索引"></a>2.2 哈希索引</h4><ul><li><p><strong>哈希索引</strong>基于哈希表实现，适用于等值查询。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>查询速度极快，但不支持范围查询和排序。</p></li><li><p>只有Memory存储引擎支持哈希索引。</p></li></ul></li></ul><h4 id="2-3-全文索引"><a href="#2-3-全文索引" class="headerlink" title="2.3 全文索引"></a>2.3 全文索引</h4><ul><li><p><strong>全文索引</strong>用于全文搜索，支持自然语言查询。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>适用于文本数据的搜索。</p></li><li><p>只有MyISAM和InnoDB存储引擎支持全文索引。</p></li></ul></li></ul><h4 id="2-4-R-Tree索引"><a href="#2-4-R-Tree索引" class="headerlink" title="2.4 R-Tree索引"></a>2.4 R-Tree索引</h4><ul><li><p><strong>R-Tree索引</strong>: 用于空间数据查询，如地理坐标。</p></li><li><p><strong>特点</strong>：</p><ul><li><p>适用于地理信息系统（GIS）等场景。</p></li><li><p>只有MyISAM存储引擎支持R-Tree索引。</p></li></ul></li></ul><hr><h3 id="3-索引分类"><a href="#3-索引分类" class="headerlink" title="3. 索引分类"></a>3. 索引分类</h3><p>MySQL可以按照四个角度来分类索引。</p><p>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引。</strong><br>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）。</strong><br>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引。</strong><br>按「字段个数」分类：<strong>单列索引、联合索引。</strong><br>接下来，按照这些角度来说说各类索引的特点。</p><blockquote><h4 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a><strong>按数据结构分类</strong></h4></blockquote><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p><p>每一种存储引擎支持的索引类型不一定相同，我在表中总结了 MySQL 常见的存储引擎 InnoDB、MyISAM 和 Memory 分别支持的索引类型。</p><img src="/2025/04/18/MySQL%E7%B4%A2%E5%BC%95/1.png" class="" title="MySQL索引"><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引。</strong></p><blockquote><h4 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a><strong>按物理存储分类</strong></h4></blockquote><p>从物理存储的角度来看，索引分为<strong>聚簇索引（主键索引）、二级索引（辅助索引</strong>）。</p><p>这两个区别在前面也提到了：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是覆盖索引。如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是回表。</p><blockquote><h4 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a><strong>按字段特性分类</strong></h4></blockquote><p>从字段特性的角度来看，索引分为<strong>主键索引、唯一索引、普通索引、前缀索引。</strong></p><ul><li>主键索引</li></ul><p>主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p>在创建表时，创建主键索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">PRIMARY</span> KEY (index_column_1) <span class="hljs-keyword">USING</span> BTREE<br>);<br></code></pre></td></tr></table></figure><ul><li>唯一索引</li></ul><p>唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p>在创建表时，创建唯一索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  <span class="hljs-keyword">UNIQUE</span> KEY(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，如果要创建唯一索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_column_1,index_column_2,...);<br></code></pre></td></tr></table></figure><ul><li>普通索引</li></ul><p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p>在创建表时，创建普通索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name  (<br>  ....<br>  INDEX(index_column_1,index_column_2,...) <br>);<br></code></pre></td></tr></table></figure><p>建表后，如果要创建普通索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(index_column_1,index_column_2,...);<br></code></pre></td></tr></table></figure><ul><li>前缀索引</li></ul><p>前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。</p><p>使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p>在创建表时，创建前缀索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name(<br>    column_list,<br>    INDEX(column_name(length))<br>);<br></code></pre></td></tr></table></figure><p>建表后，如果要创建前缀索引，可以使用这面这条命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(column_name(length));<br></code></pre></td></tr></table></figure><blockquote><h4 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a><strong>按字段个数分类</strong></h4></blockquote><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><ul><li>建立在单列上的索引称为单列索引，比如主键索引；</li><li>建立在多列上的索引称为联合索引；</li></ul><p>通过将多个字段组合成一个索引，该索引就被称为联合索引。</p><p>比如，将商品表中的 product_no 和 name 字段组合成联合索引(product_no, name)，创建联合索引的方式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_product_no_name <span class="hljs-keyword">ON</span> product(product_no, name);<br></code></pre></td></tr></table></figure><p>联合索引(product_no, name) 的 B+Tree 示意图如下（图中叶子节点之间我画了单向链表，但是实际上是双向链表，原图我找不到了，修改不了，偷个懒我不重画了，大家脑补成双向链表就行）。</p><img src="/2025/04/18/MySQL%E7%B4%A2%E5%BC%95/2.png" class="" title="MySQL索引"><p>可以看到，联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。</p><p>也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。</p><p>因此，使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p>比如，如果创建了一个 (a, b, c) 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：</p><ul><li>where a&#x3D;1；</li><li>where a&#x3D;1 and b&#x3D;2 and c&#x3D;3；</li><li>where a&#x3D;1 and b&#x3D;2；</li></ul><p>需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。</p><p>但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:</p><ul><li>where b&#x3D;2；</li><li>where c&#x3D;3；</li><li>where b&#x3D;2 and c&#x3D;3；</li></ul><p>上面这些查询条件之所以会失效，是因为(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，<strong>b 和 c 是全局无序，局部相对有序的</strong>，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</p><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><blockquote><h4 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h4></blockquote><h4 id="1-最左匹配原则的定义‌"><a href="#1-最左匹配原则的定义‌" class="headerlink" title="1. 最左匹配原则的定义‌"></a>1. 最左匹配原则的定义‌</h4><p>最左匹配原则是指在联合索引中，查询条件必须从索引的最左端开始，按照索引列的顺序依次匹配。如果查询条件没有从最左端开始，或者中间有列未匹配，索引将无法完全生效或部分失效。</p><h4 id="2-联合索引的结构与匹配过程"><a href="#2-联合索引的结构与匹配过程" class="headerlink" title="2. 联合索引的结构与匹配过程"></a>2. 联合索引的结构与匹配过程</h4><p>联合索引的底层是<a href="https://www.baidu.com/s?wd=B+%E6%A0%91&usm=1&ie=utf-8&rsv_pq=eef5b8d30002e939&oq=%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99&rsv_t=7cb9A6G42a2KCfZr4JDsmHeYtGaE7g+jJD0+j67e9NpPioyB0z8Nw/y83CE&rsv_dl=re_dqa_generate&sa=re_dqa_generate" title="B+树">B+树</a>，其节点按照索引列的顺序存储数据。例如，联合索引(a, b, c)的B+树会先按a排序，a相同的情况下按b排序，b相同的情况下再按c排序。查询时，数据库会依次匹配a、b、c，如果某列未匹配，后续列的索引将无法使用。</p><h4 id="3-最左匹配原则的应用场景"><a href="#3-最左匹配原则的应用场景" class="headerlink" title="3. 最左匹配原则的应用场景"></a>3. 最左匹配原则的应用场景</h4><ul><li>‌<strong>完全匹配</strong>‌：查询条件包含联合索引的所有列，且顺序一致。例如，索引(a, b, c)的查询<code>WHERE a=1 AND b=2 AND c=3</code>会完全利用索引。</li><li>‌<strong>部分匹配</strong>‌：查询条件从最左端开始，但未包含所有列。例如，<code>WHERE a=1 AND b=2</code>会利用索引的前两列，而<code>WHERE a=1 AND c=3</code>只能利用a列，c列无法通过索引加速。</li><li>‌<strong>范围查询</strong>‌：如果查询条件中包含范围查询（如<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>），范围查询之后的列将无法使用索引。例如，<code>WHERE a=1 AND b&gt;2 AND c=3</code>只能利用a和b列，c列无法通过索引加速。</li></ul><hr><h3 id="4-索引语法"><a href="#4-索引语法" class="headerlink" title="4. 索引语法"></a>4. 索引语法</h3><h4 id="4-1-创建索引"><a href="#4-1-创建索引" class="headerlink" title="4.1 创建索引"></a>4.1 创建索引</h4><ul><li><strong>单列索引</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> users(name);<br></code></pre></td></tr></table></figure><ul><li><strong>复合索引</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> users(name, age);<br></code></pre></td></tr></table></figure><ul><li><strong>唯一索引</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX idx_email <span class="hljs-keyword">ON</span> users(email);<br></code></pre></td></tr></table></figure><ul><li><strong>全文索引：</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> FULLTEXT INDEX idx_content <span class="hljs-keyword">ON</span> articles(content);<br></code></pre></td></tr></table></figure><h4 id="4-2-删除索引"><a href="#4-2-删除索引" class="headerlink" title="4.2 删除索引"></a>4.2 删除索引</h4><ul><li><strong>删除索引</strong>：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX idx_name <span class="hljs-keyword">ON</span> users;<br></code></pre></td></tr></table></figure><h4 id="4-3-修改索引"><a href="#4-3-修改索引" class="headerlink" title="4.3 修改索引"></a>4.3 修改索引</h4><ul><li><strong>修改索引</strong>：MySQL不支持直接修改索引，需要先删除旧索引，再创建新索引。</li></ul><hr><h3 id="5-SQL性能分析"><a href="#5-SQL性能分析" class="headerlink" title="5. SQL性能分析"></a>5. SQL性能分析</h3><h4 id="5-1-EXPLAIN命令"><a href="#5-1-EXPLAIN命令" class="headerlink" title="5.1 EXPLAIN命令"></a>5.1 EXPLAIN命令</h4><ul><li><p><strong>EXPLAIN</strong>：用于分析SQL查询的执行计划。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li><p><strong>输出字段</strong>：</p><ul><li><p><strong>id</strong>：查询的标识符。</p></li><li><p><strong>select_type</strong>：查询的类型（如SIMPLE、PRIMARY、SUBQUERY等）。</p></li><li><p><strong>table</strong>：查询的表。</p></li><li><p><strong>type</strong>：访问类型（如ALL、index、range、ref等）。</p></li><li><p><strong>possible_keys</strong>：可能使用的索引。</p></li><li><p><strong>key</strong>：实际使用的索引。</p></li><li><p><strong>rows</strong>：扫描的行数。</p></li><li><p><strong>Extra</strong>：额外信息（如Using where、Using index等）。</p></li></ul></li></ul><h4 id="5-2-慢查询日志"><a href="#5-2-慢查询日志" class="headerlink" title="5.2 慢查询日志"></a>5.2 慢查询日志</h4><ul><li><p><strong>慢查询日志</strong>：记录执行时间超过指定阈值的查询。</p></li><li><p><strong>启用慢查询日志</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> slow_query_log <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;ON&#x27;</span>;<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> long_query_time <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 设置阈值为2秒</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-索引使用"><a href="#6-索引使用" class="headerlink" title="6. 索引使用"></a>6. 索引使用</h3><h4 id="6-1-索引覆盖"><a href="#6-1-索引覆盖" class="headerlink" title="6.1 索引覆盖"></a>6.1 索引覆盖</h4><ul><li><p><strong>索引覆盖</strong>：查询的列都包含在索引中，无需回表查询。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> users(name, age);<br><span class="hljs-keyword">SELECT</span> name, age <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>; <span class="hljs-comment">-- 索引覆盖</span><br></code></pre></td></tr></table></figure><h4 id="6-2-最左前缀原则"><a href="#6-2-最左前缀原则" class="headerlink" title="6.2 最左前缀原则"></a>6.2 最左前缀原则</h4><ul><li><p><strong>最左前缀原则</strong>：复合索引中，查询条件必须从最左列开始，否则索引失效。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name_age <span class="hljs-keyword">ON</span> users(name, age);<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span>; <span class="hljs-comment">-- 使用索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">30</span>; <span class="hljs-comment">-- 索引失效</span><br></code></pre></td></tr></table></figure><h4 id="6-3-索引下推"><a href="#6-3-索引下推" class="headerlink" title="6.3 索引下推"></a>6.3 索引下推</h4><ul><li><p><strong>索引下推</strong>：MySQL 5.6引入的优化技术，将WHERE条件推到存储引擎层执行。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John&#x27;</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="7-索引设计原则"><a href="#7-索引设计原则" class="headerlink" title="7. 索引设计原则"></a>7. 索引设计原则</h3><h4 id="7-1-选择性高的列"><a href="#7-1-选择性高的列" class="headerlink" title="7.1 选择性高的列"></a>7.1 选择性高的列</h4><ul><li><p><strong>选择性高的列</strong>：索引列的值越唯一，索引的效果越好。</p></li><li><p><strong>示例</strong>：用户表的<code>email</code>列比<code>gender</code>列更适合创建索引。</p></li></ul><h4 id="7-2-避免过度索引"><a href="#7-2-避免过度索引" class="headerlink" title="7.2 避免过度索引"></a>7.2 避免过度索引</h4><ul><li><p><strong>过度索引</strong>：过多的索引会增加写操作的开销，降低性能。</p></li><li><p><strong>建议</strong>：只为常用的查询条件创建索引。</p></li></ul><h4 id="7-3-短索引"><a href="#7-3-短索引" class="headerlink" title="7.3 短索引"></a>7.3 短索引</h4><ul><li><p><strong>短索引</strong>：索引列的长度越短，索引的效率越高。</p></li><li><p><strong>示例</strong>：对<code>VARCHAR(255)</code>列的前10个字符创建索引：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> users(name(<span class="hljs-number">10</span>));<br></code></pre></td></tr></table></figure><h4 id="7-4-复合索引的顺序"><a href="#7-4-复合索引的顺序" class="headerlink" title="7.4 复合索引的顺序"></a>7.4 复合索引的顺序</h4><ul><li><p><strong>复合索引的顺序</strong>：将选择性高的列放在前面。</p></li><li><p><strong>示例</strong>：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_age_name <span class="hljs-keyword">ON</span> users(age, name); <span class="hljs-comment">-- age的选择性高于name</span><br></code></pre></td></tr></table></figure><hr><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>索引是MySQL中优化查询性能的重要工具。通过理解索引的结构、分类、使用方法和设计原则，可以显著提升数据库的查询效率。在实际应用中，需要根据具体的查询需求和数据特点，合理设计和使用索引。</p><p>文章来自CSDN作者<a href="https://blog.csdn.net/isolusion">isolusion</a>    <a href="https://blog.csdn.net/isolusion/article/details/146426380">https://blog.csdn.net/isolusion/article/details/146426380</a>    </p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPSecVPN配置实践</title>
    <link href="/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1-网络拓扑图"><a href="#1-网络拓扑图" class="headerlink" title="1.网络拓扑图"></a>1.网络拓扑图</h3><img src="/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" class="" title="IPSecVPN配置实践"><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><img src="/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E9%85%8D%E7%BD%AE1.jpg" class="" title="IPSecVPN配置实践"><img src="/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E9%85%8D%E7%BD%AE2.jpg" class="" title="IPSecVPN配置实践"><h4 id="配置测试"><a href="#配置测试" class="headerlink" title="配置测试"></a>配置测试</h4><img src="/2025/04/18/IPSecVPN%E9%85%8D%E7%BD%AE%E5%AE%9E%E8%B7%B5/%E9%85%8D%E7%BD%AE%E6%B5%8B%E8%AF%95.jpg" class="" title="IPSecVPN配置实践"><h3 id="2-路由器配置"><a href="#2-路由器配置" class="headerlink" title="2.路由器配置"></a>2.路由器配置</h3><h4 id="接口配置"><a href="#接口配置" class="headerlink" title="接口配置"></a>接口配置</h4><p>interface GigabitEthernet0&#x2F;0&#x2F;0<br> ip address 1.1.1.254 255.255.255.0 </p><p>interface GigabitEthernet0&#x2F;0&#x2F;1<br> ip address 11.1.1.254 255.255.255.0 </p><p>interface GigabitEthernet0&#x2F;0&#x2F;2<br> ip address 13.1.1.254 255.255.255.0 </p><h3 id="3-网络拓扑图"><a href="#3-网络拓扑图" class="headerlink" title="3.网络拓扑图"></a>3.网络拓扑图</h3><h4 id="3-1-FW1参考配置"><a href="#3-1-FW1参考配置" class="headerlink" title="3.1 FW1参考配置"></a>3.1 FW1参考配置</h4><h5 id="acl配置"><a href="#acl配置" class="headerlink" title="acl配置"></a>acl配置</h5><p>acl number 3000<br> rule 5 permit ip source 192.168.10.0 0.0.0.255 destination 192.168.20.0 0.0.0.255</p><h5 id="ipsec安全提议"><a href="#ipsec安全提议" class="headerlink" title="ipsec安全提议"></a>ipsec安全提议</h5><p>ipsec proposal tran1<br> esp authentication-algorithm sha2-256<br> esp encryption-algorithm aes-256</p><h5 id="默认ike安全提议"><a href="#默认ike安全提议" class="headerlink" title="默认ike安全提议"></a>默认ike安全提议</h5><p>ike proposal default<br> encryption-algorithm aes-256 aes-192 aes-128<br> dh group14<br> authentication-algorithm sha2-512 sha2-384 sha2-256<br> authentication-method pre-share<br> integrity-algorithm hmac-sha2-256<br> prf hmac-sha2-256</p><h5 id="ike安全提议"><a href="#ike安全提议" class="headerlink" title="ike安全提议"></a>ike安全提议</h5><p>ike proposal 10<br> encryption-algorithm aes-256<br> dh group14<br> authentication-algorithm sha2-256<br> authentication-method pre-share<br> integrity-algorithm hmac-sha2-256<br> prf hmac-sha2-256</p><h5 id="ike对等体"><a href="#ike对等体" class="headerlink" title="ike对等体"></a>ike对等体</h5><p>ike peer b<br> pre-shared-key Welcome@123<br> ike-proposal 10<br> remote-address 11.1.1.2</p><h5 id="ipsec安全策略"><a href="#ipsec安全策略" class="headerlink" title="ipsec安全策略"></a>ipsec安全策略</h5><p>ipsec policy FW1 10 isakmp<br> security acl 3000<br> ike-peer b<br> proposal tran1</p><h5 id="接口配置-1"><a href="#接口配置-1" class="headerlink" title="接口配置"></a>接口配置</h5><p>interface GigabitEthernet1&#x2F;0&#x2F;0<br> undo shutdown<br> ip address 1.1.1.1 255.255.255.0<br> ipsec policy FW1</p><p>interface GigabitEthernet1&#x2F;0&#x2F;1<br> undo shutdown<br> ip address 192.168.10.1 255.255.255.0</p><h5 id="区域配置"><a href="#区域配置" class="headerlink" title="区域配置"></a>区域配置</h5><p>firewall zone local<br> set priority 100</p><p>firewall zone trust<br> set priority 85<br> add interface GigabitEthernet0&#x2F;0&#x2F;0<br> add interface GigabitEthernet1&#x2F;0&#x2F;1</p><p>firewall zone untrust<br> set priority 5<br> add interface GigabitEthernet1&#x2F;0&#x2F;0</p><h5 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h5><p>ip route-static 0.0.0.0 0.0.0.0 1.1.1.254</p><h5 id="IPSecVPN安全策略"><a href="#IPSecVPN安全策略" class="headerlink" title="IPSecVPN安全策略"></a>IPSecVPN安全策略</h5><p>security-policy<br> rule name vpn-ike<br>  source-zone local<br>  source-zone untrust<br>  destination-zone local<br>  destination-zone untrust<br>  source-address 1.1.1.1 mask 255.255.255.255<br>  source-address 11.1.1.2 mask 255.255.255.255<br>  destination-address 1.1.1.1 mask 255.255.255.255<br>  destination-address 11.1.1.2 mask 255.255.255.255<br>  action permit<br> rule name vpn-tranffic<br>  source-zone trust<br>  source-zone untrust<br>  destination-zone trust<br>  destination-zone untrust<br>  source-address 192.168.10.0 0.0.0.255<br>  source-address 192.168.20.0 0.0.0.255<br>  destination-address 192.168.10.0 0.0.0.255<br>  destination-address 192.168.20.0 0.0.0.255<br>  action permit</p><h5 id="启用IPSec安全策略"><a href="#启用IPSec安全策略" class="headerlink" title="启用IPSec安全策略"></a>启用IPSec安全策略</h5><p>[FW1-GigabitEthernet1&#x2F;0&#x2F;0]ipsec policy FW1</p><h4 id="3-2-FW2参考配置"><a href="#3-2-FW2参考配置" class="headerlink" title="3.2 FW2参考配置"></a>3.2 FW2参考配置</h4><h5 id="acl配置-1"><a href="#acl配置-1" class="headerlink" title="acl配置"></a>acl配置</h5><p>acl number 3000<br> rule 5 permit ip source 192.168.20.0 0.0.0.255 destination 192.168.10.0 0.0.0.255</p><p>ipsec proposal tran1<br> esp authentication-algorithm sha2-256<br> esp encryption-algorithm aes-256</p><p>ike proposal default<br> encryption-algorithm aes-256 aes-192 aes-128<br> dh group14<br> authentication-algorithm sha2-512 sha2-384 sha2-256<br> authentication-method pre-share<br> integrity-algorithm hmac-sha2-256<br> prf hmac-sha2-256</p><p>ike proposal 10<br> encryption-algorithm aes-256<br> dh group14<br> authentication-algorithm sha2-256<br> authentication-method pre-share<br> integrity-algorithm hmac-sha2-256<br> prf hmac-sha2-256</p><h5 id="ike对等体-1"><a href="#ike对等体-1" class="headerlink" title="ike对等体"></a>ike对等体</h5><p>ike peer a<br> pre-shared-key Welcome@123<br> ike-proposal 10<br> remote-address 1.1.1.1</p><h5 id="ipsec安全策略-1"><a href="#ipsec安全策略-1" class="headerlink" title="ipsec安全策略"></a>ipsec安全策略</h5><p>ipsec policy FW2 10 isakmp<br> security acl 3000<br> ike-peer a<br> proposal tran1</p><p>interface GigabitEthernet1&#x2F;0&#x2F;0<br> undo shutdown<br> ip address 11.1.1.2 255.255.255.0<br> ipsec policy FW2</p><p>interface GigabitEthernet1&#x2F;0&#x2F;1<br> undo shutdown<br> ip address 192.168.20.2 255.255.255.0</p><p>firewall zone local<br> set priority 100</p><p>firewall zone trust<br> set priority 85<br> add interface GigabitEthernet0&#x2F;0&#x2F;0<br> add interface GigabitEthernet1&#x2F;0&#x2F;1</p><p>firewall zone untrust<br> set priority 5<br> add interface GigabitEthernet1&#x2F;0&#x2F;0</p><p>ip route-static 0.0.0.0 0.0.0.0 11.1.1.254</p><p>security-policy<br> rule name vpn-ike<br>  source-zone local<br>  source-zone untrust<br>  destination-zone local<br>  destination-zone untrust<br>  source-address 1.1.1.1 mask 255.255.255.255<br>  source-address 11.1.1.2 mask 255.255.255.255<br>  destination-address 1.1.1.1 mask 255.255.255.255<br>  destination-address 11.1.1.2 mask 255.255.255.255<br>  action permit<br> rule name vpn-tranffic<br>  source-zone trust<br>  source-zone untrust<br>  destination-zone trust<br>  destination-zone untrust<br>  source-address 192.168.10.0 0.0.0.255<br>  source-address 192.168.20.0 0.0.0.255<br>  destination-address 192.168.10.0 0.0.0.255<br>  destination-address 192.168.20.0 0.0.0.255<br>  action permit</p><h5 id="启用IPSec安全策略-1"><a href="#启用IPSec安全策略-1" class="headerlink" title="启用IPSec安全策略"></a>启用IPSec安全策略</h5><p>[FW2-GigabitEthernet1&#x2F;0&#x2F;0]ipsec policy FW2</p>]]></content>
    
    
    <categories>
      
      <category>eNSP网络搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>银河麒麟账户被锁定</title>
    <link href="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/"/>
    <url>/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>银河麒麟操作系统忘记密码分为三种情况：</p><ul><li><p>第一种忘记密码，但是用户未被锁定；</p></li><li><p>第二种忘记密码，输入次数过多导致被永久锁定；</p></li><li><p>第三种记得密码，但是输入次数过多导致永久锁定。</p></li></ul><p>以上各种情况，归结起来就是重置密码和解锁账户两步操作，我们可以进入银河麒麟操作系统的<strong>单用户模式</strong>来处理。</p><h2 id="1-进入单用户模式"><a href="#1-进入单用户模式" class="headerlink" title="1.进入单用户模式"></a>1.进入单用户模式</h2><p>1.启动操作系统，在如下界面按“e”键一次，进入Grub配置界面。</p><img src="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/1.jpg" class="" title="银河麒麟账户被锁定"><p>2.在Grub界面Linux开头的那一行，从secutity&#x3D; 那里开始往前删，删到ro那里，打一个空格加上内容 rw single console&#x3D;tty init&#x3D;&#x2F;bin&#x2F;bash</p><img src="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/2.png" class="" title="银河麒麟账户被锁定"><img src="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/3.png" class="" title="银河麒麟账户被锁定"><p>3.或者在Linux这行后边直接添加 rw init&#x3D;&#x2F;bin&#x2F;bash console&#x3D;tty0</p><img src="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/4.jpg" class="" title="银河麒麟账户被锁定"><p>3.修改完成后，按“Ctrl+X”或F10引导进入单用户模式。</p><h2 id="2-重置密码操作"><a href="#2-重置密码操作" class="headerlink" title="2.重置密码操作"></a>2.重置密码操作</h2><p>进入单用户模式后，输入如下命令进行操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-built_in">ls</span> /home   （查看用户名）</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">passwd 用户名  （按照用户更改密码）</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">reboot -f  （强制重启电脑）亦可使用ctrl+alt+delete快捷键</span><br></code></pre></td></tr></table></figure><img src="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/5.jpg" class="" title="银河麒麟账户被锁定"><h2 id="3-账户解除锁定"><a href="#3-账户解除锁定" class="headerlink" title="3.账户解除锁定"></a>3.账户解除锁定</h2><p>在<strong>单用户模式</strong>下：</p><p>输入：pam_tally2 -u username -r （username为需要解锁的用户名）回车</p><p>界面显示：Login Failures Lastest failure From user 0</p><p>账户已经成功解锁！</p>]]></content>
    
    
    <categories>
      
      <category>Linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cpp五个分区详解</title>
    <link href="/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/"/>
    <url>/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>在C++中，程序的内存管理被分为几个区域，这些区域每个都有其特定的用途。下面是五个分区的详细描述：</strong></p><h3 id="1-栈区（Stack）"><a href="#1-栈区（Stack）" class="headerlink" title="1. 栈区（Stack）"></a>1. 栈区（Stack）</h3><ul><li><p>用途：用于存储局部变量和函数调用时的上下文（如返回地址与参数等）。</p></li><li><p>特点：</p></li><li><p>采用先进后出（LIFO）原则进行管理。</p></li><li><p>内存由编译器自动分配和释放，程序员无法手动干预。</p></li><li><p>栈区的内存分配和释放速度非常快。</p></li><li><p>栈的大小通常是有限的，较大的局部变量或深度递归可能导致栈溢出（Stack Overflow）。</p></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;    <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 存储在栈区&#125;</span><br></code></pre></td></tr></table></figure><h3 id="2-堆区（Heap）"><a href="#2-堆区（Heap）" class="headerlink" title="2. 堆区（Heap）"></a>2. 堆区（Heap）</h3><ul><li><p>用途：用于动态分配内存（例如使用<code>new</code>或<code>malloc</code>时）。</p></li><li><p>特点：</p></li><li><p>由程序员手动管理内存分配和释放（使用<code>delete</code>或<code>free</code>）。</p></li><li><p>内存大小通常只有在系统可用内存的限制下。</p></li><li><p>相较于栈区，堆区的分配和释放较慢，且容易出现内存泄漏等问题。</p></li><li><p>适合存储生命周期不明确的对象。</p></li></ul><p>示例：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">// ptr 存储在堆区</span><br>    *ptr = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放堆区内存</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-静态区（Static-Data-Segment）"><a href="#3-静态区（Static-Data-Segment）" class="headerlink" title="3. 静态区（Static Data Segment）"></a>3. 静态区（Static Data Segment）</h3><ul><li><p>用途：用于全局变量、静态变量和常量的存储。这部分内存的生命周期从程序开始直到程序结束。</p></li><li><p>特点：</p></li><li><p>静态变量在程序的整个运行过程中保持其值。</p></li><li><p>静态区的大小在编译时决定，且并不随函数调用而改变。</p></li><li><p>存储在静态区的变量以其初始值进行初始化。</p></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> globalVar; <span class="hljs-comment">// 存储在静态区</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> staticVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// staticVar 存储在静态区</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-常量区（Constant-Area）"><a href="#4-常量区（Constant-Area）" class="headerlink" title="4. 常量区（Constant Area）"></a>4. 常量区（Constant Area）</h3><ul><li><p>用途：用于存储常量（如字符串字面量和使用<code>const</code>修饰的变量）。</p></li><li><p>特点：</p></li><li><p>常量区中的数据是不可修改的，尝试修改将导致未定义行为。</p></li><li><p>该区通常有助于提高程序的安全性和稳定性。</p></li><li><p>具体实现和存储方式可能依赖于编译器和平台。</p></li></ul><p>示例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> constValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 存储在常量区</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 字符串常量存储在常量区</span><br></code></pre></td></tr></table></figure><h3 id="5-代码区（Code-Segment）"><a href="#5-代码区（Code-Segment）" class="headerlink" title="5. 代码区（Code Segment）"></a>5. 代码区（Code Segment）</h3><ul><li><p>用途：存储编译生成的机器代码（即程序指令）。</p></li><li><p>特点：</p></li><li><p>该区域通常是只读的，防止程序在运行时意外地修改代码。</p></li><li><p>包含了所有函数的实现。</p></li><li><p>使用静态分配，不占用运行时内存的动态分配。</p></li></ul><p>示例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 代码存储在代码区</span><br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;This is a function.&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/FQ.jpg" class="" title="Cpp五个分区详解"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在C++程序的运行过程中，不同的内存区域有各自的用途和特点：</p><ul><li><p>栈区：用于局部变量，访问速度快，自动管理。</p></li><li><p>堆区：用于动态分配内存，程序员管理。</p></li><li><p>静态区：用于全局和静态变量，生命周期与程序相同。</p></li><li><p>常量区：用于常量，防止数据修改。</p></li><li><p>代码区：存储程序的执行指令。</p></li></ul><p>理解这些内存区域对有效管理内存、避免内存泄漏及错误是非常重要的。</p><h3 id="虚函数的存储区域"><a href="#虚函数的存储区域" class="headerlink" title="虚函数的存储区域"></a>虚函数的存储区域</h3><ol><li>代码区（Code Segment）</li></ol><ul><li>虚函数的实现（代码）存储在代码区。这是程序编译后生成的机器码包含函数体的地方，所有的函数（包括虚函数）的代码都在这一区域。</li></ul><ol start="3"><li>虚函数表（Vtable）</li></ol><ul><li><p>使用虚函数的类会生成一个虚函数表（Vtable），这个表通常被存储在静态区。Vtable是一个指针数组，每个类的每个虚函数都有一个对应的表项，指向类的虚函数实现。</p></li><li><p>在实例化一个对象时，对象内部会有一个指向Vtable的指针（通常称为虚指针，Vptr），这个指针存储在对象的实例内存中，位于堆或栈内存中，具体取决于对象是如何创建的。</p></li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><p>虚函数的代码存储在代码区。</p></li><li><p>虚函数表（Vtable）通常存储在静态区。</p></li><li><p>对象内的虚指针（Vptr）则存储在堆区或栈区，具体取决于对象的创建方式。</p></li></ul><h4 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h4><p>下面是一个简单的示例，展示如何用虚函数实现多态：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; <span class="hljs-comment">// 这段代码在代码区</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">// 这段代码在代码区</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    Base* b;              <span class="hljs-comment">// b 变量在栈中</span><br>    Derived d;           <span class="hljs-comment">// d 对象在栈中</span><br>    b = &amp;d;              <span class="hljs-comment">// b 指向 d 的地址</span><br>    b-&gt;show();           <span class="hljs-comment">// 调用 Derived::show，通过虚指针（vptr）访问 Vtable</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><p><code>Base</code> 和 <code>Derived</code> 的 <code>show()</code> 函数实现存储在代码区。</p></li><li><p><code>b</code> 是一个指向 <code>Base</code> 类型的指针（存储在栈区），但它指向了 <code>Derived</code> 对象。</p></li><li><p>当调用 <code>b-&gt;show()</code> 时，程序使用 <code>b</code> 的虚指针来查找 <code>Derived</code> 类的 <code>show()</code> 实现（再次通过虚函数表）。</p></li></ul><p><strong>在C++中，重载、重写和隐藏的概念与其他面向对象编程语言（如Java）既有相似之处，也有一些特有的实现方式。下面是对这三个概念在C++中的详细解释和示例。</strong></p><h3 id="1-重载（Overloading）"><a href="#1-重载（Overloading）" class="headerlink" title="1. 重载（Overloading）"></a>1. 重载（Overloading）</h3><p>定义：重载是在同一个作用域中定义多个同名的函数，但这些函数的参数列表必须不同（可以是参数类型不同、参数个数不同，或参数顺序不同）。重载是在编译时决定的。</p><p>特点：</p><ul><li><p>方法名相同，但参数不同（无论是类型还是数量）。</p></li><li><p>可以在同一类中或在同一作用域内进行重载。</p></li><li><p>仅通过参数类型和数量来区分，返回类型不影响重载。</p></li></ul><p>示例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">int</span> a) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display integer: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">double</span> b) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display double: &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">double</span> b) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display int and double: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main() &#123;<br>    Example e;<br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 调用第一个方法</span><br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5.0</span>);      <span class="hljs-comment">// 调用第二个方法</span><br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>);   <span class="hljs-comment">// 调用第三个方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-重写（Overriding）"><a href="#2-重写（Overriding）" class="headerlink" title="2. 重写（Overriding）"></a>2. 重写（Overriding）</h3><p>定义：重写是指在子类中重新定义父类的虚函数，子类中的函数必须与父类的虚函数具有相同的名称、参数列表和返回类型。重写是在运行时决定的。</p><p>特点：</p><ul><li><p>只有当父类的方法被声明为<code>virtual</code>时，才能在子类中重写。</p></li><li><p>允许多态性，通过父类指针或引用可以调用子类的重写方法。</p></li><li><p>使用<code>override</code>关键字能够提高代码的可读性(VS2010及以后版本)。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 声明为虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 重写父类方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();<br>    p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 输出: Child show</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-隐藏（Hiding）"><a href="#3-隐藏（Hiding）" class="headerlink" title="3. 隐藏（Hiding）"></a>3. 隐藏（Hiding）</h3><p>定义：在C++中，隐藏是指子类中定义了与父类同名的静态方法或非虚函数。隐藏只适用于静态方法或非虚方法，子类的方法会“隐藏”父类的同名方法。</p><p>特点：</p><ul><li><p>只适用于静态成员和非虚函数，虚函数不会被隐藏。</p></li><li><p>子类中的同名静态成员或函数不会覆盖父类的版本，而是隐藏了它们。</p></li><li><p>访问时推荐使用类名方式来明确调用哪个类中的成员。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent display&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 非静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 隐藏父类的静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child display&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写父类的非静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent::<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Parent display</span><br>    Child::<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 输出: Child display</span><br><br>    Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();<br>    p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 输出: Child show</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li><p>重载：同一作用域中同名函数，参数不同，编译时绑定。</p></li><li><p>重写：子类实现父类的虚函数，同名同签名，运行时绑定。</p></li><li><p>隐藏：子类定义与父类同名的静态方法或非虚函数，仅造成隐藏，而非重写。</p></li></ul><h3 id="什么是虚函数？"><a href="#什么是虚函数？" class="headerlink" title="什么是虚函数？"></a>什么是虚函数？</h3><p><strong>虚函数是C++中一种用于实现多态性的成员函数。虚函数是在基类中声明为<code>virtual</code>的函数，可以被派生类重写（覆盖）。虚函数允许通过基类的指针或引用来调用派生类的实现。虚函数的使用能够灵活地管理对象的行为，特别是在使用多态时。</strong></p><h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol><li><p>动态多态性：虚函数支持运行时多态性。通过基类指针或引用调用虚函数时，实际调用的函数是派生类中重写的函数，而不是基类中的函数。</p></li><li><p>虚函数表（Vtable）：每一个包含虚函数的类都会有一个虚函数表，它是一个指针数组，里面存储着类中虚函数的地址。每个对象在创建时，会有一个指向虚函数表的指针（通常称为<code>vptr</code>）。</p></li><li><p>可以被重写：派生类可以重写基类的虚函数，以实现特定的行为。</p></li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; <span class="hljs-comment">// 声明为虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class showing&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">// 重写基类的虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class showing&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    Base* b;          <span class="hljs-comment">// 基类指针</span><br>    Derived d;       <span class="hljs-comment">// 创建派生类对象</span><br>    b = &amp;d;          <span class="hljs-comment">// 基类指针指向派生类对象</span><br><br>    b-&gt;show();       <span class="hljs-comment">// 动态绑定，调用派生类的 show()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Derived <span class="hljs-keyword">class</span> <span class="hljs-symbol">showing</span><br></code></pre></td></tr></table></figure><h4 id="为什么在基类中使用虚函数"><a href="#为什么在基类中使用虚函数" class="headerlink" title="为什么在基类中使用虚函数?"></a>为什么在基类中使用虚函数?</h4><ol><li>实现多态性：</li></ol><ul><li>虚函数允许通过基类指针或引用调用派生类的方法，这就实现了所谓的<em>动态多态性</em>，使得可以在运行时决定调用哪个方法。这样，可以在不需要关心对象具体类型的情况下处理不同类型的对象。</li></ul><ol start="3"><li>增强代码的灵活性与可扩展性：</li></ol><ul><li>使用虚函数可以使代码更灵活，允许通过继承来扩展现有类的功能，而不需要更改原有代码。这使得程序可以更容易的适应变化。</li></ul><ol start="5"><li>统一接口：</li></ol><ul><li>通过在基类中声明虚函数，确保所有派生类都实现相同的方法，提供了一种统一的接口。这种接口规范使得代码更易于理解和使用。</li></ul><ol start="7"><li>通过抽象类引入接口：</li></ol><ul><li>创建一个只有虚函数（即没有实现的函数）的基类，可以强制派生类实现这些函数。这种方式允许将基类定义为抽象类，提供了强制实现的能力。</li></ul><ol start="9"><li>遵循开闭原则：</li></ol><ul><li>在设计中，基础类只需定义接口，而不需要知道所依赖的具体实现，符合面向对象设计的开闭原则（对扩展开放，对修改关闭）。</li></ul><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>虚函数在C++中是重要的面向对象编程特性之一，使得程序能够实现动态多态性。它不仅提高了代码的灵活性与可扩展性，还允许通过定义统一的接口来管理和使用不同类型的对象。</p><h3 id="什么是析构函数？"><a href="#什么是析构函数？" class="headerlink" title="什么是析构函数？"></a>什么是析构函数？</h3><p>析构函数（Destructor）是C++中一个特殊的成员函数，用于在对象生命周期结束时释放资源和清理工作。它的名称与类名相同，但前面加上波浪号（<code>~</code>），且不接受参数也不返回值。</p><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ol><li><p>自动调用：当一个对象的生命周期结束时（例如超出作用域、动态分配的对象被删除），析构函数自动被调用。</p></li><li><p>只能有一个：每个类只能有一个析构函数，无法被重载。</p></li><li><p>不可继承：析构函数在派生类中不能被继承，但是可以被重写。</p></li><li><p>逆序调用：对于局部对象，当控制离开其作用域时，其析构函数按照逆序调用，即先调用最新创建的对象的析构函数。</p></li></ol><h4 id="析构函数的作用"><a href="#析构函数的作用" class="headerlink" title="析构函数的作用"></a>析构函数的作用</h4><ol><li>释放动态分配的内存：</li></ol><ul><li>当对象使用 <code>new</code> 操作符动态分配内存时，在析构函数中对应地使用 <code>delete</code> 释放这部分内存，防止内存泄漏。</li></ul><ol start="3"><li>清理资源：</li></ol><ul><li>除了内存，析构函数还可以释放其他资源，如文件句柄、网络连接、数据库连接等。</li></ul><ol start="5"><li>执行必要的清理工作：</li></ol><ul><li>可以在对象销毁前执行清理操作，确保那些需要在对象结束其生命周期前处理的操作能被执行。</li></ul><ol start="7"><li>用于维护静态或全局资源：</li></ol><ul><li>当程序结束时，可以利用析构函数中装配的清理代码来确保静态对象或全局对象得到妥善处理。</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个简单的示例，展示了析构函数的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;  <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-comment">// 分配资源</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructor: Resource allocated, value: &quot;</span> &lt;&lt; *data &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-comment">// 析构函数</span><br>        <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-keyword">delete</span> data;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor: Resource released&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data; <span class="hljs-comment">// 指向动态分配的整数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        MyClass obj; <span class="hljs-comment">// 创建对象，调用构造函数</span><br>    &#125; <span class="hljs-comment">// obj 超出范围，调用析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>:</span> Resource allocated, value: <span class="hljs-number">42</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span>:</span> Resource released<br></code></pre></td></tr></table></figure><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>析构函数在C++中是一个关键机制，帮助开发者管理动态资源。在设计类时，特别是涉及到动态内存分配、文件操作及其他资源管理时，必须谨慎地实现析构函数，以确保资源得到正确和及时的释放，防止内存泄漏或资源浪费。</p><p><strong>C++标准模板库（STL）提供了一些非常实用和强大的容器，能有效支持各种数据结构的实现和操作。以下是STL库中一些常用容器的介绍，包括<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>、<code>unordered_map</code>和<code>array</code>。</strong></p><h4 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. <code>vector</code></h4><ul><li><p>定义：<code>std::vector</code>是一个动态数组，可以根据需要调整大小。</p></li><li><p>特点：</p></li><li><p>允许随机访问元素，可以通过索引访问。</p></li><li><p>支持在末尾插入和删除元素，时间复杂度为O(1)，但在中间位置插入和删除的时间复杂度为O(n)。</p></li><li><p>需要时，可自动扩展其容量，以容纳更多元素。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. <code>list</code></h4><ul><li><p>定义：<code>std::list</code>是一个双向链表，支持在任意位置高效插入和删除元素。</p></li><li><p>特点：</p></li><li><p>不支持随机访问，必须通过迭代器顺序访问元素。</p></li><li><p>插入和删除操作的时间复杂度为O(1)（在已知的位置进行操作）。</p></li><li><p>适合频繁插入和删除的场景。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 在末尾添加元素</span><br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在头部添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : lst) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 0 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. <code>deque</code></h4><ul><li><p>定义：<code>std::deque</code>（双端队列）是一种支持在两端进行高效插入和删除的序列容器。</p></li><li><p>特点：</p></li><li><p>允许在两端（前端和后端）高效地添加和删除元素，时间复杂度为O(1)。</p></li><li><p>支持随机访问，时间复杂度为O(1)。</p></li><li><p>在某些情况下，比<code>vector</code>更适合于频繁的前端插入。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    deque dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在前端添加元素</span><br>    dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在后端添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dq) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 0 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. <code>set</code></h4><ul><li><p>定义：<code>std::set</code>是一个存储唯一元素的集合，底层通常使用红黑树实现。</p></li><li><p>特点：</p></li><li><p>自动排序，且每个元素都是唯一的，不可重复。</p></li><li><p>支持高效的查找、插入和删除，时间复杂度为O(log n)。</p></li><li><p>不能通过索引访问元素，但支持迭代器。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : s) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3 4 （自动排序）</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-map"><a href="#5-map" class="headerlink" title="5. map"></a>5. <code>map</code></h4><ul><li><p>定义：<code>std::map</code>是一种以键值对形式存储数据的容器，底层使用红黑树。</p></li><li><p>特点：</p></li><li><p>自动排序，键是唯一的，且不允许重复。</p></li><li><p>可以通过键高效查找、插入和删除，时间复杂度为O(log n)。</p></li><li><p>支持使用迭代器访问元素。</p></li></ul><p>示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map m;<br>    m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span>;<br>    m[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>;<br>    m[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : m) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: a: 1 b: 2 c: 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-unordered-map"><a href="#6-unordered-map" class="headerlink" title="6. unordered_map"></a>6. <code>unordered_map</code></h4><ul><li><p>定义：<code>std::unordered_map</code>是基于哈希表实现的关联容器，不会对元素进行排序。</p></li><li><p>特点：</p></li><li><p>允许快速查找、插入和删除，平均时间复杂度为O(1)。</p></li><li><p>键必须是唯一的，且不能重复，插入的顺序没有保证。</p></li><li><p>适合于需要快速查找的场景。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map um;<br>    um[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">1</span>;<br>    um[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : um) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: apple: 1 banana: 2 （顺序不固定）</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-array"><a href="#7-array" class="headerlink" title="7. array"></a>7. <code>array</code></h4><ul><li><p>定义：<code>std::array</code>是一个固定大小的数组容器，提供了数组的许多优点。</p></li><li><p>特点：</p></li><li><p>尺寸在编译时确定，不支持动态大小调整。</p></li><li><p>支持随机访问，和内置数组一样高效。均为常数时间复杂度 O(1)。</p></li><li><p>具有较好的类型安全性，能够使用STL算法。</p></li></ul><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    array arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>STL中的各种容器提供了丰富的数据结构支持，使得C++能够高效地处理各种数据存储和访问需求。根据不同的应用场景和需求，可以选择合适的容器来优化性能和资源使用。了解这些容器的特性和用法是使用C++进行高效编程的重要基础。</p><p><strong>在C++中，静态成员变量和静态成员函数是类中的特殊成员，它们有一些独特的属性和行为。下面将详细解释这两个概念，讨论它们属于哪个内存分区，并提供代码示例。</strong></p><h4 id="静态成员变量（Static-Member-Variables）"><a href="#静态成员变量（Static-Member-Variables）" class="headerlink" title="静态成员变量（Static Member Variables）"></a>静态成员变量（Static Member Variables）</h4><p>定义：</p><ul><li><p>静态成员变量是属于类本身而不是某个具体对象的变量。所有的对象共享同一个静态成员变量。</p></li><li><p>静态成员变量使用<code>static</code>关键字声明，且只能在类内部定义，但必须在类外部初始化。</p></li></ul><p>特点：</p><ul><li><p>所有的对象共享同一个静态成员变量。</p></li><li><p>可以直接通过类名访问（不需要创建对象）。</p></li><li><p>生命周期与程序相同，在程序运行期间存在。</p></li><li><p>在类的所有对象创建之前分配内存，并在程序结束时释放。</p></li></ul><p>属于哪个分区：</p><ul><li>静态成员变量存储在静态区中。</li></ul><p>示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 声明静态成员变量</span><br><br>    <span class="hljs-built_in">Example</span>() &#123;<br>        count++; <span class="hljs-comment">// 每创建一个对象，count加1</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Current count: &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义并初始化静态成员变量</span><br><span class="hljs-type">int</span> Example::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Example obj1;<br>    Example obj2;<br>    Example obj3;<br><br>    Example::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出: Current count: 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态成员函数（Static-Member-Functions）"><a href="#静态成员函数（Static-Member-Functions）" class="headerlink" title="静态成员函数（Static Member Functions）"></a>静态成员函数（Static Member Functions）</h4><p>定义：</p><ul><li><p>静态成员函数是属于类本身而不是某个具体对象的函数。静态成员函数也使用<code>static</code>关键字声明。</p></li><li><p>静态成员函数只能访问静态成员变量或其他静态成员函数，不能访问非静态成员变量和非静态成员函数。</p></li></ul><p>特点：</p><ul><li><p>静态成员函数可以在没有创建类的对象的情况下被调用。</p></li><li><p>不能访问类中的非静态成员（没有<code>this</code>指针）。</p></li><li><p>可以通过类名直接调用。</p></li></ul><p>属于哪个分区：</p><ul><li>静态成员函数的代码存储在代码区中。</li></ul><p>示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 静态成员变量</span><br><br>    <span class="hljs-built_in">Example</span>() &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 静态成员函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Current count: &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Example::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Example obj1;<br>    Example obj2;<br><br>    Example::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出: Current count: 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul><li><p>静态成员变量是类中的变量，只有一份，所有实例共享，声明时需要在类定义中及类外部定义。</p></li><li><p>静态成员函数是类中的方法，无法访问非静态的成员，但可以访问静态成员，没有 <code>this</code> 指针，通常通过类名调用。</p></li><li><p>静态成员变量：</p></li><li><p>存储在静态区。</p></li><li><p>所有对象共享。</p></li><li><p>生命周期与程序相同。</p></li><li><p>静态成员函数：</p></li><li><p>存放在代码区。</p></li><li><p>不能访问非静态成员。</p></li><li><p>可以通过类名直接调用。</p></li></ul><p>这两个特性在设计类时非常有用，可以用于实现类级别的数据和行为。</p><h3 id="const和-static-的作用及其作用域的区别。"><a href="#const和-static-的作用及其作用域的区别。" class="headerlink" title="const和 static 的作用及其作用域的区别。"></a>const和 static 的作用及其作用域的区别。</h3><p><strong>在 C++ 中，<code>const</code> 和 <code>static</code> 是两个常用的修饰符，它们可以结合使用来定义某些特定特性。下面将详细解释 <code>const</code> 和 <code>static</code> 的作用及其作用域的区别。</strong></p><h4 id="1-const-关键字"><a href="#1-const-关键字" class="headerlink" title="1. const 关键字"></a>1. <code>const</code> 关键字</h4><ul><li><p>作用：用于声明常量，即该变量在初始化后不能被修改。</p></li><li><p>作用域：<code>const</code> 变量的作用域和类型（如局部、全局或成员）有关。</p></li></ul><p>示例：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 是一个全局常量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>; <span class="hljs-comment">// b 是一个局部常量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，<code>a</code> 是一个全局常量，<code>b</code> 是一个局部常量，它们的值在定义后不能被修改。<code>const</code> 的作用域取决于它所在的上下文。</p><p><strong>在类中的 <code>const</code>：</strong></p><p>在类中声明的 <code>const</code> 成员变量，意味着这个变量在对象的生命周期内无法被修改。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>public:<br>    const <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">x</span> 是一个常量成员变量<br>    MyClass(<span class="hljs-keyword">int</span> val) : <span class="hljs-keyword">x</span>(val) &#123;&#125; // 在构造函数中初始化<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-static-关键字"><a href="#2-static-关键字" class="headerlink" title="2. static 关键字"></a>2. <code>static</code> 关键字</h4><ul><li><p>作用：用于声明静态变量或函数，意味着该变量或函数的生命周期在整个程序运行期间持续存在。对于类中的静态成员，其值在所有对象之间共享。</p></li><li><p>作用域：</p></li><li><p>全局作用域：<code>static</code> 修饰的全局变量或函数只能在定义它们的文件内访问，具有内部链接。</p></li><li><p>类作用域：<code>static</code> 成员属于类本身，而不是类的实例，所有对象共享静态成员。</p></li></ul><p>示例：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>; <span class="hljs-comment">// 声明静态成员变量</span><br>&#125;;<br><br><span class="hljs-comment">// 静态成员需在类外初始化</span><br><span class="hljs-built_in">int</span> MyClass::<span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>count</code> 是 <code>MyClass</code> 的静态成员变量，在所有 <code>MyClass</code> 的实例中共享。</p><h4 id="3-const-static-的组合"><a href="#3-const-static-的组合" class="headerlink" title="3. const static 的组合"></a>3. <code>const static</code> 的组合</h4><p>当 <code>const</code> 和 <code>static</code> 组合使用时，表示该变量是类级别的常量，所有实例共享同一份常量，且其值在对象的生命周期内不可改变。</p><p>示例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">double</span> <span class="hljs-literal">PI</span>; <span class="hljs-comment">// 声明静态常量</span><br>&#125;;<br><br><span class="hljs-comment">// 在类外初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">double</span> Circle::<span class="hljs-literal">PI</span> = <span class="hljs-number">3.14159</span>;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>Circle::PI</code> 是静态常量，所有 <code>Circle</code> 的实例共享 <code>PI</code> 的值。因为它是 <code>const</code> 的，这个值不能被修改。</p><h4 id="作用域区别总结"><a href="#作用域区别总结" class="headerlink" title="作用域区别总结"></a>作用域区别总结</h4><ul><li><p><code>const</code>：</p></li><li><p>局部或全局作用域，根据声明位置决定。</p></li><li><p>只能在声明它的作用域中访问（例如，局部常量只能在函数内部访问）。</p></li><li><p><code>static</code>：</p></li><li><p>全局作用域的 static 变量或函数只能在定义它的源文件中访问。</p></li><li><p>类中声明的 static 成员变量在类的所有实例之间共享，可以通过类名直接访问。</p></li><li><p><code>const static</code>：</p></li><li><p>在类中声明的 <code>const static</code> 成员变量属于类，所有实例共享并且不可改变。</p></li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li><p>使用 <code>const</code> 来定义常量值，确保它们不可被修改。</p></li><li><p>使用 <code>static</code> 来管理类中的共享状态或限制变量的作用域到声明它的文件。</p></li><li><p>使用 <code>const static</code> 来定义类级别的常量，增强代码的可读性和维护性。</p></li></ul><p><strong>运算符重载（Operator Overloading）是C++的一项重要特性，允许程序员为自定义类型（类）定义或重新定义运算符的行为。通过运算符重载，可以使对象看起来像内置类型一样使用，从而提高代码的可读性和可维护性。</strong></p><h3 id="运算符重载的基本概念"><a href="#运算符重载的基本概念" class="headerlink" title="运算符重载的基本概念"></a>运算符重载的基本概念</h3><p>在C++中，许多内置数据类型（如整型、浮点型、字符型等）支持多种运算符（如<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>[]</code>, <code>()</code>, 等）。运算符重载通过提供特定的函数定义，使得这些运算符能够作用于用户自定义类型。运算符的重载并不是创建新的运算符，而是改变其在特定上下文中的行为。</p><h4 id="运算符重载的基本语法"><a href="#运算符重载的基本语法" class="headerlink" title="运算符重载的基本语法"></a>运算符重载的基本语法</h4><p>运算符重载通常通过成员函数或非成员函数来实现。例如，假设我们有一个简单的 <code>Complex</code> 类来表示复数：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">double</span> <span class="hljs-keyword">real</span>;<br>    <span class="hljs-keyword">double</span> imag;<br><br>    <span class="hljs-title function_ invoke__">Complex</span>(<span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span> i) : <span class="hljs-keyword">real</span>(r), <span class="hljs-title function_ invoke__">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数重载 `+` 运算符</span><br>    Complex operator+(<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Complex</span>&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Complex</span>(<span class="hljs-keyword">real</span> + other.<span class="hljs-keyword">real</span>, imag + other.imag);<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数重载 `&lt;&lt;` 运算符，以便于输出</span><br>    friend std::<span class="hljs-variable constant_">ostream</span>&amp; operator&lt;&lt;(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Complex</span>&amp; c) &#123;<br>        os &lt;&lt; c.<span class="hljs-keyword">real</span> &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>() &#123;    <span class="hljs-comment">// 创建两个 Complex 对象    Complex c1(1.0, 2.0);    Complex c2(3.0, 4.0);    // 使用重载的 + 运算符    Complex c3 = c1 + c2; // 会调用 c1.operator+(c2)</span><br>    <span class="hljs-comment">// 使用重载的 &lt;&lt; 运算符输出结果    std::cout &lt;&lt; &quot;c1 + c2 = &quot; &lt;&lt; c3 &lt;&lt; std::endl; // 输出: c1 + c2 = 4.0 + 6.0i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure><h4 id="运算符重载的注意事项"><a href="#运算符重载的注意事项" class="headerlink" title="运算符重载的注意事项"></a>运算符重载的注意事项</h4><ol><li><p>不能改变运算符的优先级：运算符重载并不能改变运算符的优先级或结合性，它们仍然遵循C++的默认规则。</p></li><li><p>所有现有运算符不能重载：某些运算符（如<code>::</code>, <code>.</code>, <code>.*</code>, <code>? :</code>）在C++中无法被重载。</p></li><li><p>至少一个操作数必须是用户定义的类型：运算符必须至少有一个操作数是自定义类型，才能重载该运算符。</p></li><li><p>重载函数返回类型：运算符重载函数通常返回相应类型的对象（如 <code>Complex</code> 类型的对象），以支持链式调用。</p></li></ol><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>运算符重载的常见使用场景包括但不限于：</p><ol><li><p>数学类：如复数（<code>Complex</code>），矩阵（<code>Matrix</code>），向量（<code>Vector</code>），使用运算符重载可以让这些类的对象直接参与数值运算，使代码更自然易读。</p></li><li><p>容器类：如链表、栈、队列等数据结构类，重载运算符如<code>[]</code>可以方便地实现对元素的访问。</p></li><li><p>字符串类：自定义字符串类的运算符重载可以支持字符串拼接、比较等操作。</p></li><li><p>比较逻辑：重载比较运算符（如<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）可以方便地使用这些类对象进行排序和查找操作。</p></li></ol><h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>例如，我们可以创建一个表示二维点的类，并重载一些运算符以便使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 `+` 运算符</span><br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x + other.x, y + other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载 `-` 运算符</span><br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x - other.x, y - other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载 `==` 运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-built_in">return</span> (x == other.x) &amp;&amp; (y == other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出重载</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>        os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    Point p3 = p1 + p2; <span class="hljs-comment">// 使用重载的 +</span><br>    Point p4 = p2 - p1; <span class="hljs-comment">// 使用重载的 -</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3: &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出 (4, 6)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4: &quot;</span> &lt;&lt; p4 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出 (2, 2)</span><br><br>    <span class="hljs-keyword">if</span> (p1 == p4) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 and p4 are equal.\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 and p4 are not equal.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个<code>Point</code>类，重载了加法（<code>+</code>）、减法（<code>-</code>）和比较（<code>==</code>）运算符，使得我们可以像使用内置类型一样使用这些对象。这样不仅增加了代码的可读性，也让用户自定义对象的使用变得更简单和自然。</p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>运算符重载在C++中是一种强大且灵活的特性，能够使用户定义类型的行为更符合直觉，提升代码的可读性与可维护性。合理使用运算符重载可以让复杂的操作变得简单明了，但也需要注意过度重载可能导致代码的理解和维护变得困难。</p><h3 id="模板类和模板函数"><a href="#模板类和模板函数" class="headerlink" title="模板类和模板函数"></a>模板类和模板函数</h3><p>C++ 的模板是强大的工具，它允许开发者编写与类型无关的代码。这主要有两种形式：模板类（Class Template）和模板函数（Function Template）。</p><h4 id="1-模板类（Class-Template）"><a href="#1-模板类（Class-Template）" class="headerlink" title="1. 模板类（Class Template）"></a>1. 模板类（Class Template）</h4><p>模板类是一种用于创建泛型类的机制。借助模板类，可以根据不同的数据类型生成多个类，而不需要为每种数据类型重写相似的代码。</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data;<br>    <span class="hljs-built_in">MyClass</span>(T value) : <span class="hljs-built_in">data</span>(value) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-模板函数（Function-Template）"><a href="#2-模板函数（Function-Template）" class="headerlink" title="2. 模板函数（Function Template）"></a>2. 模板函数（Function Template）</h4><p>模板函数是一种创建泛型函数的机制。使用模板函数，可以将相同的函数逻辑应用于不同的数据类型。</p><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span> </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T arg)</span> </span>&#123;<br>    std::cout &lt;&lt; arg &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面的示例展示了如何定义一个模板类和一个模板函数，并且在 <code>main</code> 函数中使用它们。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-comment">// 模板类：Stack</span><br><span class="hljs-keyword">template</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* arr;       <span class="hljs-comment">// 动态数组</span><br>    <span class="hljs-type">int</span> top;      <span class="hljs-comment">// 栈顶索引</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 栈的容量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> size) &#123;<br>        arr = <span class="hljs-keyword">new</span> T[size]; <span class="hljs-comment">// 分配动态内存</span><br>        capacity = size;<br>        top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶为 -1（为空）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 压栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == capacity - <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;栈已满，无法压入 &quot;</span> &lt;&lt; item &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        arr[++top] = item; <span class="hljs-comment">// 将数据放到栈顶，并增加栈顶索引</span><br>    &#125;<br><br>    <span class="hljs-comment">// 弹栈</span><br>    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;栈为空，无法弹出元素&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 返回默认构造的 T 类型对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[top--]; <span class="hljs-comment">// 返回栈顶元素并减少栈顶索引</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回栈顶元素</span><br>    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;栈为空，无法查看元素&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 返回默认构造的 T 类型对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[top];<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Stack</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 释放动态内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 模板函数：打印数组元素</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用模板类</span><br>    <span class="hljs-function">Stack <span class="hljs-title">intStack</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个可以存储 5 个整数的栈</span><br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">peek</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出的元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 弹出栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出的元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-function">Container <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;    c<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出：Data: 5 MyClass  c2(&quot;Hello&quot;);    c2.print(); // 输出：Data: Hello// 使用模板函数    double arr[] = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printArray</span>(arr, size); <span class="hljs-comment">// 打印数组元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="解释示例代码"><a href="#解释示例代码" class="headerlink" title="解释示例代码"></a>解释示例代码</h4><ul><li><p>模板类：在示例中，我们定义了一个 <code>Stack</code> 模板类，可以存储任何类型的数据。该类实现了基本的栈操作，包括压栈、弹栈和查看栈顶元素。</p></li><li><p>模板函数：自定义了一个 <code>printArray</code> 模板函数，用于打印数组中的元素。同样，它可以处理任何数据类型。</p></li><li><p>主函数：在 <code>main</code> 函数中，我们创建了一个 <code>Stack&lt;int&gt;</code> 的实例，并使用它进行栈操作。此外，我们还使用 <code>printArray</code> 函数打印一个 <code>double</code> 类型的数组。</p></li></ul><p>这样，模板的使用使得代码变得灵活且重用性高，开发者可以针对不同的类型创建相同的逻辑。</p><h3 id="解释引用（Reference）与指针（Pointer）之间的区别"><a href="#解释引用（Reference）与指针（Pointer）之间的区别" class="headerlink" title="解释引用（Reference）与指针（Pointer）之间的区别"></a>解释引用（Reference）与指针（Pointer）之间的区别</h3><p><strong>引用（Reference）和指针（Pointer）都是C++中用于间接访问变量的机制，但是它们有不同的定义、语法和特性。下面将详细解释引用和指针之间的主要区别。</strong></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul><li><p>指针（Pointer）：</p></li><li><p>指针是一个变量，用于存储另一个变量的内存地址。它可以指向任何数据类型，使用时需要解引用（dereference）以访问指向的值。</p></li><li><p>指针可以修改其指向的对象，可以在任何时刻改变指向的地址。</p></li><li><p>引用（Reference）：</p></li><li><p>引用是一个变量的别名，为一个已有的变量起一个新的名字。引用在创建时必须初始化，并在创建后不可以改变指向的对象。</p></li><li><p>引用的使用方式与普通变量相同，可以直接使用而无需解引用。</p></li></ul><h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h4><ul><li><p>指针的声明和使用：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>* p = &amp;x; <span class="hljs-comment">// 声明一个指针，指向x的地址</span><br>*p = <span class="hljs-number">20</span>; <span class="hljs-comment">// 解引用指针p，修改x的值为20Copy</span><br></code></pre></td></tr></table></figure></li><li><p>引用的声明和使用：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span>&amp; <span class="hljs-keyword">ref</span> = <span class="hljs-keyword">x</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">ref</span>是<span class="hljs-keyword">x</span>的引用<br><span class="hljs-keyword">ref</span> = <span class="hljs-number">20</span>; <span class="hljs-regexp">//</span> 修改<span class="hljs-keyword">x</span>的值为20Copy<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h4><ul><li><p>指针：</p></li><li><p>指针可以在任意时刻被初始化和重新赋值，可以为<code>nullptr</code>，也可以指向不同的变量。</p></li><li><p>例如：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-keyword">ptr</span> = &amp;a; // <span class="hljs-keyword">ptr</span>指向a<br><span class="hljs-keyword">ptr</span> = &amp;b; // 现在<span class="hljs-keyword">ptr</span>指向b<br></code></pre></td></tr></table></figure></li><li><p>引用：</p></li><li><p>引用必须在定义时进行初始化，并且初始化后就不能改变所引用的变量。</p></li><li><p>例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span>&amp; <span class="hljs-keyword">ref</span> = a; <span class="hljs-regexp">//</span> <span class="hljs-keyword">ref</span>引用a<br>// <span class="hljs-keyword">int</span>&amp; ref2; <span class="hljs-regexp">//</span> 错误：必须在声明时初始化<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-空值"><a href="#4-空值" class="headerlink" title="4. 空值"></a>4. 空值</h4><ul><li><p>指针：</p></li><li><p>指针可以指向<code>nullptr</code>，表示指向无效地址。</p></li><li><p>例如：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>* ptr = <span class="hljs-literal">null</span>ptr; <span class="hljs-comment">// 指针初始化为null，表示不指向任何变量</span><br></code></pre></td></tr></table></figure></li><li><p>引用：</p></li><li><p>引用不能为<code>nullptr</code>，在定义时必须绑定到一个有效对象。</p></li></ul><h4 id="5-大小"><a href="#5-大小" class="headerlink" title="5. 大小"></a>5. 大小</h4><ul><li><p>指针的大小通常为4字节（在32位系统中）或8字节（在64位系统中），用于存储地址。</p></li><li><p>引用的大小通常与其所引用的对象相同，实际上引用会在编译时转换为相应的指针，因此它的大小与指针相同。</p></li></ul><h4 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h4><ul><li><p>指针可以在不同的作用域中声明和使用，可以改变其作用域。</p></li><li><p>引用的生命周期通常与其所引用的对象一致，一旦对象超出范围，引用变量也将不可用。</p></li></ul><h4 id="7-用途"><a href="#7-用途" class="headerlink" title="7. 用途"></a>7. 用途</h4><ul><li><p>指针：</p></li><li><p>常用于动态内存分配（例如通过<code>new</code>和<code>delete</code>）。</p></li><li><p>可以表示数组（指针可以和数组名互换使用）。</p></li><li><p>优于引用的场景如需要可选参数（可以传null）。</p></li><li><p>引用：</p></li><li><p>常用于函数参数传递（可以避免复制大对象的开销）。</p></li><li><p>适合表示对象的别名，使得语法更简洁。</p></li><li><p>适合用作返回值（返回大对象的引用而不是值）。</p></li></ul><h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个示例，展示了指针和引用的不同使用场景：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyWithPointer</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p) &#123; <span class="hljs-comment">// 检查指针是否为空</span><br>        *p = <span class="hljs-number">100</span>; <span class="hljs-comment">// 修改指针指向的值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyWithReference</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; r)</span> </span>&#123;<br>    r = <span class="hljs-number">200</span>; <span class="hljs-comment">// 直接修改引用的值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">// 使用指针</span><br>    <span class="hljs-type">int</span>* ptr = &amp;a;<br>    <span class="hljs-built_in">modifyWithPointer</span>(ptr); <span class="hljs-comment">// 通过指针修改a</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a after pointer modification: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// 输出 100</span><br><br>    <span class="hljs-comment">// 使用引用</span><br>    <span class="hljs-built_in">modifyWithReference</span>(b); <span class="hljs-comment">// 通过引用修改b</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b after reference modification: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出 200</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">a <span class="hljs-keyword">after</span> pointer modification: <span class="hljs-number">100</span><br>b <span class="hljs-keyword">after</span> <span class="hljs-keyword">reference</span> modification: <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul><li><p>引用（Reference） 是对已有变量的别名，在使用时更为简洁、清晰，并且在生命周期上与所引用的对象一致。</p></li><li><p>指针（Pointer） 是一个可以指向不同对象及不同内存地址的变量，灵活性更强，但使用时相对复杂，需要处理指针的有效性。</p></li><li><p>在选择时，可以根据需要的灵活性和易用性来决定使用引用还是指针。</p></li></ul><h3 id="解释浅拷贝和深拷贝"><a href="#解释浅拷贝和深拷贝" class="headerlink" title="解释浅拷贝和深拷贝"></a>解释浅拷贝和深拷贝</h3><p><strong>在C++中，浅拷贝（Shallow Copy）和深拷贝（Deep Copy）是指在复制对象时如何处理成员变量，尤其是指针和动态分配的内存。</strong></p><h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><p>定义：浅拷贝会复制对象的所有成员，包括指针的值（地址），使得源对象和目标对象都指向相同的内存位置。这意味着如果一个对象释放了这段内存，另一个对象将变为悬空指针，导致未定义行为。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(value) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认深拷贝构造函数（浅拷贝）</span><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">const</span> ShallowCopy&amp; other) &#123;<br>        data = other.data;  <span class="hljs-comment">// 共享内存</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">ShallowCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;  <span class="hljs-comment">// 释放内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ShallowCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    ShallowCopy obj2 = obj1; <span class="hljs-comment">// 浅拷贝</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放 obj1 的数据</span><br>    <span class="hljs-keyword">delete</span>[] obj<span class="hljs-number">1.</span>data;<br><br>    <span class="hljs-comment">// 此时 obj2.data 成为悬空指针，访问会导致未定义行为</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;obj2 data: &quot; &lt;&lt; obj2.data &lt;&lt; std::endl; // 不安全的访问！</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当执行 <code>delete[] obj1.data;</code> 时，<code>obj2.data</code> 也会变成一个悬空指针，造成未定义行为。</p><h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><p>定义：深拷贝会创建一个新对象，并为其每一个动态分配的成员（包括指针指向的内容）分配新的内存。这样，源对象与目标对象之间没有共享内存的指针。</p><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(value) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义拷贝构造函数实现深拷贝</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(other.data) + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配新内存</span><br>        <span class="hljs-built_in">strcpy</span>(data, other.data);  <span class="hljs-comment">// 复制内容</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">DeepCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;  <span class="hljs-comment">// 释放内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">DeepCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    DeepCopy obj2 = obj1; <span class="hljs-comment">// 深拷贝</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 修改 obj1 的数据，不会影响 obj2</span><br>    obj<span class="hljs-number">1.</span>data[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After modification...&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，每当 <code>DeepCopy</code> 对象被创建时，都会分配自己的内存，并且每个对象都是独立的。对 <code>obj1</code> 的任何修改都不会影响 <code>obj2</code>，因为它们各自拥有自己的 <code>data</code> 副本。</p><h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><ul><li><p>浅拷贝：拷贝的是指针，多个对象会指向同一个内存区域，释放其中一个的内存会导致其他对象变成悬空指针。</p></li><li><p>深拷贝：拷贝的是实际的数据，确保每个对象都拥有独立的内存副本，修改一个对象不会影响另一个对象。</p></li></ul><p>在实际开发中，了解何时使用浅拷贝，何时使用深拷贝非常重要，尤其涉及到动态内存管理时。</p>]]></content>
    
    
    <categories>
      
      <category>C++基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统root账户被锁解决方法</title>
    <link href="/2025/02/24/Linux%E7%B3%BB%E7%BB%9Froot%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2025/02/24/Linux%E7%B3%BB%E7%BB%9Froot%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>​    <strong>在Linux系统中，root账户是最高权限的账户，通常用于系统管理和维护。然而，由于各种原因，root账户可能会被锁定，导致无法登录系统。本文将介绍几种常见的解锁root账户的方法，帮助用户快速恢复对系统的访问。</strong></p><h2 id="方法一：通过单用户模式重置密码"><a href="#方法一：通过单用户模式重置密码" class="headerlink" title="方法一：通过单用户模式重置密码"></a>方法一：通过单用户模式重置密码</h2><p>重启系统并进入内核编辑界面：在系统启动时，按下“e”键进入内核编辑界面。</p><p><strong>修改启动参数：</strong>找到以“linux16”或“linux”开头的行，将“ro”替换为“rw init&#x3D;&#x2F;bin&#x2F;bash”，然后按“Ctrl + X”启动系统。</p><p><strong>进入单用户模式：</strong>系统启动后会进入一个具有root权限的shell。</p><p><strong>重置密码：</strong>使用“passwd”命令重置root密码，例如：passwd root。</p><p><strong>退出并重启系统：</strong>执行“exit”命令退出shell，然后执行“reboot”命令重启系统。</p><h2 id="方法二：使用系统安装盘或Live-CD-USB"><a href="#方法二：使用系统安装盘或Live-CD-USB" class="headerlink" title="方法二：使用系统安装盘或Live CD&#x2F;USB"></a>方法二：使用系统安装盘或Live CD&#x2F;USB</h2><p>启动系统安装盘或Live CD&#x2F;USB：将系统安装盘或Live CD&#x2F;USB插入系统，重启并设置从光盘或USB启动。</p><p><strong>进入救援模式：</strong>选择“Rescue a Red Hat Enterprise Linux System”或类似的选项进入救援模式。</p><p><strong>挂载根文件系统：</strong>在救援模式下，输入以下命令挂载根文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -o remount,rw /sysroot<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot /sysroot<br></code></pre></td></tr></table></figure><p><strong>重置密码：</strong>使用“passwd”命令重置root密码，例如：passwd root。</p><p>退出并重启系统：执行“exit”命令退出shell，然后执行“reboot”命令重启系统。</p><h2 id="方法三：修改shadow文件"><a href="#方法三：修改shadow文件" class="headerlink" title="方法三：修改shadow文件"></a>方法三：修改shadow文件</h2><p>启动系统安装盘或Live CD&#x2F;USB：将系统安装盘或Live CD&#x2F;USB插入系统，重启并设置从光盘或USB启动。</p><p><strong>进入系统：</strong>选择“试用ubuntu”或类似的选项进入系统。</p><p><strong>查找根文件系统分区：</strong>使用“sudo fdisk -l”命令查找根文件系统分区，例如：&#x2F;dev&#x2F;sda1。</p><p><strong>挂载根文件系统：</strong>使用以下命令挂载根文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount /dev/sda1 /mnt<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount --bind /dev /mnt/dev<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount --bind /proc /mnt/proc<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mount --bind /sys /mnt/sys<br></code></pre></td></tr></table></figure><p>切换到挂载的文件系统：使用“chroot”命令切换到挂载的文件系统，例如：sudo chroot &#x2F;mnt。</p><p><strong>修改shadow文件：</strong>使用文本编辑器（如vi）打开&#x2F;etc&#x2F;shadow文件，找到root用户对应的行，删除密码部分（通常是第二个冒号之间的内容）。</p><p><strong>退出并重启系统：</strong>执行“exit”命令退出shell，然后执行“reboot”命令重启系统。</p><h2 id="方法四：使用pam-tally2命令"><a href="#方法四：使用pam-tally2命令" class="headerlink" title="方法四：使用pam_tally2命令"></a>方法四：使用pam_tally2命令</h2><p>如果root账户被锁定是由于多次登录失败，可以使用pam_tally2命令解锁。</p><p><strong>启动系统并进入救援模式：</strong>使用系统安装盘或Live CD&#x2F;USB启动系统，并进入救援模式。</p><p><strong>挂载根文件系统：</strong>输入以下命令挂载根文件系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mount -o remount,rw /sysroot<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chroot /sysroot<br></code></pre></td></tr></table></figure><p>查看并重置登录失败次数：使用以下命令查看并重置root用户的登录失败次数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pam\_tally2 --user=root<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pam\_tally2 --user=root --reset<br></code></pre></td></tr></table></figure><p>退出并重启系统：执行“exit”命令退出shell，然后执行“reboot”命令重启系统。</p><p><strong>以上是几种常见的解锁root账户的方法，用户可以根据自己的实际情况选择合适的方法进行解锁。在解锁root账户后，建议检查系统日志，分析账户被锁定的原因，并采取相应的措施防止类似问题再次发生。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux磁盘及分区</title>
    <link href="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/"/>
    <url>/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>Linux 系统中所有的硬件设备都是通过文件的方式来表现和使用的，我们将这些文件称为设备文件，硬盘对应的设备文件一般被称为块设备文件。本文介绍磁盘设备在 Linux 系统中的表示方法以及如何创建磁盘分区。说明：本文的演示环境为 ubuntu 16.04。</p><h1 id="磁盘分类"><a href="#磁盘分类" class="headerlink" title="磁盘分类"></a>磁盘分类</h1><p>比较常见的磁盘类型有消费类市场中的 SATA 硬盘和服务器中使用的 SCSI 硬盘、SAS 硬盘，当然还有当下大热的各种固态硬盘。</p><p><strong>SATA 硬盘</strong><br>SATA(Serial ATA)口的硬盘又叫串口硬盘，Serial ATA 采用串行连接方式，串行 ATA 总线使用嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令(不仅仅是数据)进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。SATA 硬盘主要用于消费类市场和一些低端服务器(下图来自互联网)：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/1.jpg" class="" title="Linux磁盘及分区"><p><strong>SCSI 硬盘</strong><br>SCSI 硬盘即采用 SCSI 接口的硬盘。它由于性能好、稳定性高，因此在服务器上得到广泛应用。同时其价格也不菲，正因它的价格昂贵，所以在普通PC上很少见到它的踪迹。SCSI 硬盘使用 50 针接口，外观和普通硬盘接口有些相似(下图来自互联网)：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/2.jpg" class="" title="Linux磁盘及分区"><p><strong>SAS 硬盘</strong></p><p>SAS 是 Serial Attached SCSI 的缩写，即串行连接的 SCSI，其目标是定义一个新的串行点对点的企业级存储设备接口。串行接口减少了线缆的尺寸，允许更快的传输速度。SAS 硬盘与相同转速的 SCSI 硬盘相比有相同或者更好的性能。SAS 硬盘一般用于比较高端的服务器。</p><p><strong>固态硬盘</strong><br>固态硬盘(Solid State Disk)，一般称之为 SSD 硬盘，固态硬盘是用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元(FLASH芯片、DRAM芯片)组成。其主要特点是没有传统硬盘的机械结构，读写速度非常快(下图来自互联网)：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/3.png" class="" title="Linux磁盘及分区"><h1 id="磁盘设备在-Linux-下的表示方法"><a href="#磁盘设备在-Linux-下的表示方法" class="headerlink" title="磁盘设备在 Linux 下的表示方法"></a>磁盘设备在 Linux 下的表示方法</h1><p>在 Linux 系统中磁盘设备文件的命名规则为：<br><strong>主设备号 + 次设备号 + 磁盘分区号</strong><br>对于目前常见的磁盘，一般表示为：<br><strong>sd[a-z]x</strong><br>主设备号代表设备的类型，相同的主设备号表示同类型的设备。当前常见磁盘的主设备号为 sd。<br>次设备号代表同类设备中的序号，用 “a-z” 表示。比如 &#x2F;dev&#x2F;sda 表示第一块磁盘，&#x2F;dev&#x2F;sdb 表示第二块磁盘。<br>x 表示磁盘分区编号。在每块磁盘上可能会划分多个分区，针对每个分区，Linux 用 &#x2F;dev&#x2F;sdbx 表示，这里的 x 表示第二块磁盘的第 x 个分区。</p><p>如下图所示：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/4.png" class="" title="Linux磁盘及分区"><p>该系统中一共有四块磁盘 &#x2F;dev&#x2F;sda，&#x2F;dev&#x2F;sdb，&#x2F;dev&#x2F;sdc 和 &#x2F;dev&#x2F;sdd。其中的 &#x2F;dev&#x2F;sda 上创建了三个分区，分别是 &#x2F;dev&#x2F;sda1，&#x2F;dev&#x2F;sda2，&#x2F;dev&#x2F;sda5；&#x2F;dev&#x2F;sdb 上只有一个分区 &#x2F;dev&#x2F;sdb1。而 &#x2F;dev&#x2F;sdc 和 &#x2F;dev&#x2F;sdd 则尚未分区(也肯能是只有一个分区，分区的名称和磁盘的名称相同)。</p><h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><p>创建磁盘分区大概有下面几个目的：</p><ul><li>提升数据的安全性(一个分区的数据损坏不会影响其他分区的数据)</li><li>支持安装多个操作系统</li><li>多个小分区对比一个大分区会有性能提升</li><li>更好的组织数据</li></ul><p>本文以常见的 MBR 分区为例介绍磁盘分区中的一些常见概念。MBR 磁盘的分区由主分区、扩展分区和逻辑分区组成。在一块磁盘上，主分区的最大个数是 4，其中扩展分区也是一个主分区，并且最多只能有一个扩展分区，但可以在扩展分区上创建多个逻辑分区。因此主分区(包括扩展分区)的范围是 1-4，逻辑分区从 5 开始。对于逻辑分区，Linux 规定它们必须建立在扩展分区上，而不是建立在主分区上。<br>主分区的作用是用来启动操作系统的，主要存放操作系统的启动或引导程序，因此建议操作系统的引导程序都放在主分区，比如 Linux 的 &#x2F;boot 分区，最好放在主分区上：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/5.png" class="" title="Linux磁盘及分区"><p>扩展分区只不过是逻辑分区的 “容器”。实际上只有主分区和逻辑分区是用来进行数据存储的，因而可以将数据集中存放在磁盘的逻辑分区中。<br>我们可以通过 fdisk 命令来查看磁盘分区的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> fdisk -l /dev/sda</span><br></code></pre></td></tr></table></figure><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/6.png" class="" title="Linux磁盘及分区"><p>输出中的前几行是磁盘的基本信息，比如总大小为 80G，一共有多少个扇区(sector)，每个扇区的大小等等。红框中的则是我们比较关注的分区信息：<br><strong>第一列 Device</strong> 显示了磁盘分区对应的设备文件名。<br><strong>第二列 Boot</strong> 显示是否为引导分区，上图中的 &#x2F;dev&#x2F;sda1 就是引导分区。<br><strong>第三列 Start</strong> 表示磁盘分区的起始位置。<br><strong>第四列 End</strong> 表示磁盘分区的结束位置。<br><strong>第五列 Sectors</strong> 表示分区占用的扇区数目。<br><strong>第六列 Size</strong> 显示分区的大小。<br><strong>第七列和第八列</strong>显示的内容相同，分别是数值 ID 及其文字描述。 Id 列显示了磁盘分区对应的 ID，根据分区的不同，分区对应的 ID 号也不相同。Linux 下用 83 表示主分区和逻辑分区，5 表示扩展分区，8e 表示 LVM 分区，82 表示交换分区，7 表示 NTFS 分区。<br>上图中的信息表明：&#x2F;dev&#x2F;sda1 是一个主分区并且被用作引导分区；&#x2F;dev&#x2F;sda2 是扩展分区，其中只有一个逻辑分区，即 &#x2F;dev&#x2F;sda5，这点可以通过两个分区相同的大小证明。</p><h1 id="利用-fdisk-划分磁盘分区"><a href="#利用-fdisk-划分磁盘分区" class="headerlink" title="利用 fdisk 划分磁盘分区"></a>利用 fdisk 划分磁盘分区</h1><p>fdisk 是 Linux 系统中一款功能强大的磁盘分区管理工具，可以观察硬盘的使用情况，也可以用来管理磁盘分区。本文仅介绍如何使用 fdisk 创建新的磁盘分区。<br>假设我们的 Linux 系统中增加了一块新的磁盘，系统对应的设备名为 &#x2F;dev&#x2F;sdd，下面我们通过 fdisk 命令对这个磁盘进行分区。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> fdisk /dev/sdd</span><br></code></pre></td></tr></table></figure><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/7.png" class="" title="Linux磁盘及分区"><p>输入命令 n 来创建新分区：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/8.png" class="" title="Linux磁盘及分区"><p>根据上面的提示，我们选择 p 来创建主分区，然后提示我们输入分区的编号：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/9.png" class="" title="Linux磁盘及分区"><p>主分区的编号为 1- 4，这里我们输入了 1。接下来是设置分区的大小：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/10.png" class="" title="Linux磁盘及分区"><p>分区的大小是通过设置分区开始处的扇区和结束处的扇区设置的。这里如果回车两次会把整个磁盘划分为一个分区，也就是整个磁盘的容器都分给了一个分区。这样一个简单的分区就差不多完成了，注意此时的分区信息还没有写入到磁盘中，在这里还可以反悔，如果确认执行上面的分区，执行 w 命令就行了：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/11.png" class="" title="Linux磁盘及分区"><p>这时分区操作已经完成了，我们可以通过下面的命令查看分区的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">sudo</span> fdisk -l /dev/sdd</span><br></code></pre></td></tr></table></figure><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/12.png" class="" title="Linux磁盘及分区"><p>如果嫌上面的执行过程麻烦，可以用下面的一行命令起到相同的效果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">(<span class="hljs-built_in">echo</span> n; <span class="hljs-built_in">echo</span> p; <span class="hljs-built_in">echo</span> 1; <span class="hljs-built_in">echo</span> ; <span class="hljs-built_in">echo</span> ; <span class="hljs-built_in">echo</span> w) | <span class="hljs-built_in">sudo</span> fdisk /dev/sdd</span><br></code></pre></td></tr></table></figure><h1 id="更改分区的类型"><a href="#更改分区的类型" class="headerlink" title="更改分区的类型"></a>更改分区的类型</h1><p>上面创建的分区类型默认为 83(Linux)，如果想要一个 8e(Linux LVM)类型的分区该怎么办？我们可以继续使用 fdisk 命令修改分区的类型，这次输入 t 命令来修改分区的类型：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/13.png" class="" title="Linux磁盘及分区"><p>接下来可以选择要修改的分区号，我们只有一个分区，所以默认就是 1。<br>下面我们可以通过 L 命令来查看 fdisk 命令支持的分区类型：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/14.jpg" class="" title="Linux磁盘及分区"><p>我们需要创建 LVM，因此我们使用 LVM 的类型代码 8e：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/15.png" class="" title="Linux磁盘及分区"><p>最后输入 w 命令确认变更。再次查看 &#x2F;dev&#x2F;sdd 的分区信息，此时分区类型已经变成了 Linux LVM：</p><img src="/2024/11/18/Linux%E7%A3%81%E7%9B%98%E5%8F%8A%E5%88%86%E5%8C%BA/16.png" class="" title="Linux磁盘及分区"><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分区是使用磁盘的基础，在分区完成后还需要对分区进行格式化，并把格式化后的文件系统挂载到 Linux 系统之后才能存储文件。</p><p>本文转自 <a href="https://www.cnblogs.com/sparkdev/p/10095916.html">https://www.cnblogs.com/sparkdev/p/10095916.html</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux四剑客及正则表达式</title>
    <link href="/2024/11/18/Linux%E5%9B%9B%E5%89%91%E5%AE%A2%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2024/11/18/Linux%E5%9B%9B%E5%89%91%E5%AE%A2%E5%8F%8A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="Linux四剑客及正则表达式"><a href="#Linux四剑客及正则表达式" class="headerlink" title="Linux四剑客及正则表达式"></a>Linux四剑客及正则表达式</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul><li><strong>基础正则（使用四剑客命令时无需加任何参数即可使用）</strong></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs autoit">^    <span class="hljs-meta"># 匹配以某一内容开头 如：<span class="hljs-string">&#x27;^grep&#x27;</span>匹配所有以grep开头的行。    </span><br>$    <span class="hljs-meta"># 匹配以某一内容结尾 如：<span class="hljs-string">&#x27;grep$&#x27;</span> 匹配所有以grep结尾的行。</span><br>^$ <span class="hljs-meta"># 匹配空行。</span><br>.    <span class="hljs-meta"># 匹配任意单个字符 如：<span class="hljs-string">&#x27;gr.p&#x27;</span>匹配gr后接一个任意字符，然后是p。    </span><br>*    <span class="hljs-meta"># 前一个字符出现0次及0次以上 如：<span class="hljs-string">&#x27;a*&#x27;</span>匹配所有有a的行。</span><br>.*   <span class="hljs-meta"># 表示文件中所有内容。</span><br>[]   <span class="hljs-meta"># 匹配一个指定范围内的字符，如<span class="hljs-string">&#x27;[Gg]rep&#x27;</span>匹配Grep和grep。</span><br>[^]  <span class="hljs-meta"># 匹配一个不在指定范围内的字符，如：<span class="hljs-string">&#x27;[^A-Z]rep&#x27;</span> 匹配不包含 A-Z 中的字母开头的行</span><br> 注意：在[]中，除位置在第一个字符的^外，其余任何带含义的特殊符号都会被还原。<br><br></code></pre></td></tr></table></figure><ul><li><p><strong>扩展正则</strong></p><ul><li>使用方法</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span>命令：<br><span class="hljs-keyword">grep</span> -E ……或egrep ……<br>sed命令：<br>sed -r ……<br>awk命令：<br>awk -E ……<br><br></code></pre></td></tr></table></figure><ul><li>表达式</li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autoit">+<span class="hljs-meta">#匹配前一个字符连续出现1次或1次以上 如：<span class="hljs-string">&#x27;a+&#x27;</span> 匹配字符a连续出现1次或多次的行。</span><br>注：通常与[]配合使用，过滤连续的内容。<br>&#123;n,m&#125;<span class="hljs-meta">#匹配前一个字符至少n次，最多m次,优先匹配后面的数字</span><br>例：<span class="hljs-string">&#x27;[0-9]&#123;18&#125;&#x27;</span>匹配连续的<span class="hljs-number">18</span>个数字<br>|<span class="hljs-meta">#或者</span><br>例：<span class="hljs-string">&#x27;^$|^#&#x27;</span>匹配文件的空行或以井号开头的<br>()<span class="hljs-meta">#表示一个整体；反向引用/后向引用</span><br><br></code></pre></td></tr></table></figure></li><li><p><strong>单词边界符</strong></p></li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\b</span>    <span class="hljs-comment"># 单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep;&#x27;\b[0-9]&#123;18&#125;\b&#x27;只匹配连续的18位数字</span><br><span class="hljs-string">\&lt;</span>    <span class="hljs-comment"># 锚定单词的开始，如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行。    </span><br><span class="hljs-string">\&gt;</span>    <span class="hljs-comment"># 锚定单词的结束，如&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行。</span><br><span class="hljs-string">\&lt;……\&gt;</span><span class="hljs-comment"># 相当于\b...\b</span><br><span class="hljs-string">\w</span>      <span class="hljs-comment"># 匹配文字和数字字符，也就是[A-Za-z0-9];</span><br><span class="hljs-string">\W</span>      <span class="hljs-comment"># \w的反置形式，匹配一个或多个非单词字符,相当于[^A-Za-z0-9]</span><br><br></code></pre></td></tr></table></figure><h3 id="四剑客"><a href="#四剑客" class="headerlink" title="四剑客"></a>四剑客</h3><h4 id="find-在指定目录下查找文件"><a href="#find-在指定目录下查找文件" class="headerlink" title="find 在指定目录下查找文件"></a>find 在指定目录下查找文件</h4><p><strong>语法形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">find <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[选项]</span>   #单条件查找<br>find <span class="hljs-selector-attr">[参数]</span> <span class="hljs-selector-attr">[选项]</span> <span class="hljs-selector-attr">[or/and]</span> <span class="hljs-selector-attr">[选项]</span>  #多条件查找<br><br></code></pre></td></tr></table></figure><p><strong>or&#x2F;and</strong></p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-comment">#使用find命令可以多条件查找；</span><br><span class="hljs-literal">-</span>a<span class="hljs-comment">#需要同时满足两个、多个条件时（and可以省略）；</span><br><span class="hljs-literal">-</span>o<span class="hljs-comment">#只需满足其中之一条件时；</span><br><br></code></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">-type f<span class="hljs-regexp">/d/</span>l<span class="hljs-regexp">/b/</span>c<span class="hljs-comment">#按照文件类型查找；</span><br>-name <span class="hljs-string">&quot;NAME&quot;</span><span class="hljs-comment">#按照文件名字查找；</span><br>-iname <span class="hljs-string">&quot;NAME&quot;</span><span class="hljs-comment">#按照文件名字查找（忽略大小写）；</span><br>-inum <span class="hljs-string">&quot;INUM&quot;</span><span class="hljs-comment">#按照文件iNode号查找；</span><br>-maxdepth n<span class="hljs-comment">#按照深度等级查找（向下遍历）；</span><br>-size +n<span class="hljs-regexp">/-n/</span>n<span class="hljs-comment">#按照文件大小查找；</span><br>-mtime +n<span class="hljs-regexp">/-n/</span>n<span class="hljs-comment">#按照文件修改时间查找；当n=0，代表24小时内被修改过的文件；</span><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#查找/目录下文件名为dezyan.txt的文件(不区分大小写)</span><br>[root@Dezyan ~]# <span class="hljs-built_in">find</span> / -iname <span class="hljs-string">&quot;dezyan.txt&quot;</span><br>/proc/kcore<br><span class="hljs-comment">#查找/目录下文件大小大于1M的目录</span><br>[root@Dezyan ~]# <span class="hljs-built_in">find</span> / -size +1M -type d<br>注意：当一个目录大小大于1M，说明该目录中存在非常多的小文件<br><span class="hljs-comment">#查找/目录下的字符设备或块设备文件</span><br>[root@Dezyan ~]# <span class="hljs-built_in">find</span> / -type c -o -type b<br>或<span class="hljs-built_in">find</span> / -type c,b<br><span class="hljs-comment">#以深度等级为1查找/目录下以.log结尾的文件</span><br>[root@Dezyan ~]# <span class="hljs-built_in">find</span> / -maxdepth 1 -name <span class="hljs-string">&quot;*.log&quot;</span> -type f<br><span class="hljs-comment">#查找24小时内被修改过的文件</span><br>[root@Dezyan ~]# <span class="hljs-built_in">find</span> ./ -mtime 0<br><br></code></pre></td></tr></table></figure><h5 id="xargs-给其他命令传递参数的一个过滤器"><a href="#xargs-给其他命令传递参数的一个过滤器" class="headerlink" title="xargs 给其他命令传递参数的一个过滤器"></a>xargs 给其他命令传递参数的一个过滤器</h5><p>注意：在xargs后别名失效</p><p><strong>语法形式</strong></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">find …………|<span class="hljs-string"> xargs [文件操作，命令]</span><br><span class="hljs-string">#可以理解为将</span>|<span class="hljs-string">前执行的结果甩到末尾，再执行</span>|<span class="hljs-string">后的命令</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p><strong>相关使用方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">-n1 <span class="hljs-comment">#按照第一列方式输出内容</span><br><span class="hljs-built_in">ls</span> -l/cat <span class="hljs-comment">#查看找到的文件；</span><br><span class="hljs-built_in">rm</span> [选项]<span class="hljs-comment">#将查找的文件删除；</span><br>-i <span class="hljs-built_in">cp</span>/mv &#123;&#125; [参数]<span class="hljs-comment">#将查找到的文件复制/移动到[参数位置]；</span><br><span class="hljs-built_in">cp</span>/mv -t [参数]<span class="hljs-comment">#将查找到的文件复制/移动到[参数位置]；</span><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#将/etc/下大于9M的文件复制到~目录下</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># find /etc/ -size +9M | xargs cp -t ~</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># ls ~ | grep <span class="hljs-string">&#x27;hwd&#x27;</span></span><br>hwdb.bin<br><span class="hljs-meta">#查找出所有大写的.TXT结尾的文件 然后打包成test.tar.gz</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># find ./ -name <span class="hljs-string">&quot;*.TXT&quot;</span>|xargs tar zcvf a.tar.gz</span><br><br></code></pre></td></tr></table></figure><h5 id="exec-调用并执行指定的命令"><a href="#exec-调用并执行指定的命令" class="headerlink" title="exec 调用并执行指定的命令"></a>exec 调用并执行指定的命令</h5><p>注意：使用exec将多个文件压缩成一个压缩包是不可取的，因为按照exec的逻辑，是将前一命令的每一次执行结果依次放入{}，进行压缩时，会不断覆盖文件；</p><p><strong>语法形式</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">find …………-exec <span class="hljs-selector-attr">[命令]</span> &#123;&#125; <span class="hljs-selector-attr">[参数]</span> \;<br><br></code></pre></td></tr></table></figure><p>注意：其中&#x3D;&#x3D;；&#x3D;&#x3D;为shell中命令的分隔符，可将多个命令同时执行：mkdir test;touch 1.txt。</p><p><strong>相关使用方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span> [选项] &#123;&#125; \;<span class="hljs-comment">#将查找的文件删除；</span><br><span class="hljs-built_in">cp</span>/mv &#123;&#125; [参数] \;<span class="hljs-comment">#将查找到的文件复制/移动到[参数位置]；</span><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将/etc/下大于9M的文件复制到~目录下</span><br>[root@Dezyan ~]# find /etc/ -size +9M -<span class="hljs-built_in">exec</span>  <span class="hljs-built_in">cp</span> &#123;&#125; ~ \;<br><br></code></pre></td></tr></table></figure><h5 id="使用-和"><a href="#使用-和" class="headerlink" title="使用``和$()"></a>使用``和$()</h5><p><strong>语法形式</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">[命令+选项] <span class="hljs-string">`find ……………`</span> <br>[命令+选项] <span class="hljs-string">`find ……………`</span> [参数]<br><br></code></pre></td></tr></table></figure><p>$()效果与``相同</p><p>注意：如果一段命令被添加上了``，那么在整体命令中，需要先执行``中的命令，类似于运算法则中的加减乘除先算（）。</p><p><strong>相关使用方法</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span>/mv `find ……` [参数]<br><span class="hljs-built_in">ls</span>/rm……<br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#将<span class="hljs-regexp">/etc/</span>下大于<span class="hljs-number">9</span>M的文件复制到~目录下<br>[root@Dezyan ~]# cp -a `<span class="hljs-keyword">find</span> <span class="hljs-regexp">/etc/</span> -<span class="hljs-keyword">size</span> +<span class="hljs-number">9</span>M` ~<br><br></code></pre></td></tr></table></figure><h4 id="grep-强大的文本搜索工具"><a href="#grep-强大的文本搜索工具" class="headerlink" title="grep 强大的文本搜索工具"></a>grep 强大的文本搜索工具</h4><p><strong>语法形式</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">grep <span class="hljs-comment">[选项]</span> &#x27;<span class="hljs-comment">[word]</span>&#x27; <span class="hljs-comment">[参数]</span><br><br></code></pre></td></tr></table></figure><p><strong>选项</strong></p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-literal">-</span>v<span class="hljs-comment">#反转查找;</span><br><span class="hljs-literal">-</span>r<span class="hljs-comment">#当指定要查找的是&lt;目录&gt;而非文件时，必须使用这项参数;</span><br><span class="hljs-literal">-</span>E<span class="hljs-comment">#识别扩展正则进行过滤;等同于egrep；</span><br><span class="hljs-literal">-</span>o<span class="hljs-comment">#展示匹配过程;</span><br><span class="hljs-literal">-</span>-----------------------------------------------------------<br><span class="hljs-literal">-</span>-color<span class="hljs-comment">#对筛选出的WORD加颜色显示；建议设置永久别名；</span><br><span class="hljs-literal">-</span>i<span class="hljs-comment">#搜索时不区分大小写；</span><br><span class="hljs-literal">-</span>n<span class="hljs-comment">#搜索出的结果显示行号；</span><br><span class="hljs-literal">-</span>w   <span class="hljs-comment">#过滤的内容两边必须是空格(类似于边界符)</span><br><span class="hljs-literal">-</span>c   <span class="hljs-comment">#统计单词出现的次数;</span><br><span class="hljs-literal">-</span>A   <span class="hljs-comment">#过滤到内容往下2行;</span><br><span class="hljs-literal">-</span>B   <span class="hljs-comment">#过滤到内容往上2行;</span><br><span class="hljs-literal">-</span>C   <span class="hljs-comment">#过滤到内容上下各2行;</span><br><br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment">#在/etc/passwd文件中过滤出root的行</span><br>[root<span class="hljs-variable">@Dezyan</span> ~]<span class="hljs-comment"># grep &#x27;root&#x27; /etc/passwd</span><br><span class="hljs-symbol">root:</span><span class="hljs-symbol">x:</span><span class="hljs-number">0</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">:root</span><span class="hljs-symbol">:/root</span><span class="hljs-symbol">:/bin/bash</span><br><span class="hljs-symbol">operator:</span><span class="hljs-symbol">x:</span><span class="hljs-number">11</span><span class="hljs-symbol">:</span><span class="hljs-number">0</span><span class="hljs-symbol">:operator</span><span class="hljs-symbol">:/root</span><span class="hljs-symbol">:/sbin/nologin</span><br><span class="hljs-comment">#不区分大小写过滤出 /etc/ssh/sshd_config 文件中包含`port 22`的行并输出行号</span><br>[root<span class="hljs-variable">@Dezyan</span> ~]<span class="hljs-comment"># grep -i -n  &#x27;port 22&#x27;   /etc/ssh/sshd_config </span><br><span class="hljs-number">17</span><span class="hljs-symbol">:</span><span class="hljs-comment">#Port 22</span><br><span class="hljs-comment">#排除（取反）/etc/selinux/config文件中的#和注释</span><br>[root<span class="hljs-variable">@Dezyan</span> ~]<span class="hljs-comment"># grep -v &#x27;^#|^$&#x27;  /etc/ssh/sshd_config</span><br><span class="hljs-comment">#统计word.txt文件中shutdown单词的个数</span><br>[root<span class="hljs-variable">@Dezyan</span> ~]<span class="hljs-comment"># grep -c &#x27;shutdown&#x27; word.txt </span><br><span class="hljs-number">2</span><br><span class="hljs-comment">#显示文件word.txt中config的上下各两行</span><br>[root<span class="hljs-variable">@Dezyan</span> ~]<span class="hljs-comment">#  grep -C 2 &#x27;config&#x27; word.txt </span><br>test测试<br>server服务<br>configure配置configconfcfg<br>continue继续<br><span class="hljs-keyword">next</span>下一个<br><br></code></pre></td></tr></table></figure><h4 id="sed-功能强大的流式文本编辑器"><a href="#sed-功能强大的流式文本编辑器" class="headerlink" title="sed 功能强大的流式文本编辑器"></a>sed 功能强大的流式文本编辑器</h4><ul><li><strong>语法形式</strong></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">sed <span class="hljs-comment">[选项]</span> &#x27;<span class="hljs-comment">[模式]</span><span class="hljs-comment">[动作]</span>&#x27; <span class="hljs-comment">[参数]</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>选项</strong></li></ul><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-literal">-</span>n<span class="hljs-comment">#取消内存空间默认输出；不添加时sed命令会默认输出文件所有内容及匹配到的内容；</span><br><span class="hljs-literal">-</span>r<span class="hljs-comment">#使模式中的正则表达式支持扩展正则；</span><br><span class="hljs-literal">-</span>i<span class="hljs-comment">#对源文件进行修改；不添加时不会修改；</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>模式</strong></li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">number</span><span class="hljs-comment">#按行查找，查找第n行</span><br><span class="hljs-built_in">number</span>或正则符号，<span class="hljs-built_in">number</span>或正则符号   <span class="hljs-comment">#查找n到m行</span><br>/字符串或正则表达式/  <span class="hljs-comment">#模糊查询，查询包含此字符串的行</span><br>/字符串/,/字符串/ <span class="hljs-comment">#匹配区间：查询两个字符串之间的内容（也可用正则）</span><br>n[动作];m[动作] <span class="hljs-comment">#指定第n行和第m行进行操作</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>动作</strong></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs clean">p#输出打印过滤出的内容<br>d#删除过滤出的内容<br>a字符串    #add 在……后追加xxx <br>i字符串    #insert 在……前插入xxx<br>c字符串    #replace 将……替换为xxx<br>w文件   #将过滤到的内容写入到文件中<br>--------------------------------------------------<br>s###g#<span class="hljs-number">1.</span>其中，g代表全局替换<br>#<span class="hljs-number">2.</span>s<span class="hljs-comment">///g、s@@@g等与s###g效果相同</span><br><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>动作中有p，模式中必有n</p></li><li><p>在使用匹配区间（ &#x2F;开头字符串&#x2F;,&#x2F;结尾字符串&#x2F; ）时，尽量<strong>使用文件内容中唯一的、不重复的字符串</strong>；</p><ul><li>若只有一个开头，有两个甚至多个结尾时：输出的内容只会是<strong>开头到第一个结尾字符串之间的内容</strong>；</li><li>若只有开头，结尾字符串没有：输出的内容为<strong>开头字符串到文件末尾</strong>；</li></ul></li><li><p><strong>sed的后向引用</strong></p></li></ul><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs leaf">sed &#x27;s<span class="hljs-punctuation">#</span><span class="hljs-params">(正则)</span>(数字)(字符串)<span class="hljs-punctuation">#</span>\1\3<span class="hljs-punctuation">#</span><span class="hljs-keyword">g</span>&#x27; <span class="hljs-punctuation">#</span>\n获取第n个()中的内容<br><br></code></pre></td></tr></table></figure><p> <strong>实例</strong></p><figure class="highlight leaf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs leaf"><span class="hljs-punctuation">#</span>获取IP地址<br>[root@Dezyan ~]<span class="hljs-punctuation">#</span> ip add show ens33 | sed -rn &#x27;3s<span class="hljs-punctuation">#</span>.*et (.*)/24 .*$<span class="hljs-punctuation">#</span>\1<span class="hljs-punctuation">#</span><span class="hljs-keyword">gp</span>&#x27;<br>10.0.0.101<br><br><span class="hljs-punctuation">#</span>批量创建用户test01..test03<br>[root@Dezyan ~]<span class="hljs-punctuation">#</span> echo test&#123;01..03&#125; | xargs -n1 | sed -r &#x27;s<span class="hljs-punctuation">#</span><span class="hljs-params">(.<span class="hljs-operator">*</span>)</span><span class="hljs-punctuation">#</span><span class="hljs-keyword">useradd</span> \1<span class="hljs-punctuation">#</span><span class="hljs-keyword">g</span>&#x27; | bash<br><br><span class="hljs-punctuation">##</span>批量创建用户test01..test03并设置密码为dingzhiyan1016<br>echo test&#123;01..03&#125; | xargs -n1 | sed -r &#x27;s<span class="hljs-punctuation">#</span><span class="hljs-params">(.<span class="hljs-operator">*</span>)</span><span class="hljs-punctuation">#</span><span class="hljs-keyword">useradd</span> \1 ; echo dingzhiyan1016 | passwd --stdin \1<span class="hljs-punctuation">#</span><span class="hljs-keyword">g</span>&#x27; | bash<br>或<br>[root@Dezyan ~]<span class="hljs-punctuation">#</span> echo test11&#123;01..03&#125; | xargs -n1 | sed -r &#x27;s<span class="hljs-punctuation">#</span><span class="hljs-params">(.<span class="hljs-operator">*</span>)</span><span class="hljs-punctuation">#</span><span class="hljs-keyword">useradd</span> \1 ; echo \1:dingzhiyan1016 | chpasswd <span class="hljs-punctuation">#</span><span class="hljs-keyword">g</span>&#x27;  | bash<br><br><span class="hljs-punctuation">#</span>批量删除用户<br>[root@Dezyan ~]<span class="hljs-punctuation">#</span> echo user&#123;1..20&#125; | xargs -n1 | sed -r &#x27;s<span class="hljs-punctuation">#</span><span class="hljs-params">(.<span class="hljs-operator">*</span>)</span><span class="hljs-punctuation">#</span><span class="hljs-keyword">userdel</span> -r \1<span class="hljs-punctuation">#</span><span class="hljs-keyword">g</span>&#x27; | bash<br><br></code></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">1</span>.<span class="hljs-keyword">a</span>.txt文件<br>[root@Dezyan ~]# <span class="hljs-keyword">cat</span> -n <span class="hljs-keyword">a</span>.txt <br>     <span class="hljs-number">1</span>The <span class="hljs-keyword">first</span> snow came. <br>     <span class="hljs-number">2</span>How beautiful it was, falling <span class="hljs-keyword">so</span> silently <span class="hljs-keyword">all</span> day long,<br>     <span class="hljs-number">3</span><span class="hljs-keyword">all</span> night long.<br>     <span class="hljs-number">4</span><span class="hljs-keyword">on</span> the mountains, <span class="hljs-keyword">on</span> the meadows, <br>     <span class="hljs-number">5</span><span class="hljs-keyword">on</span> the roofs of the living, <span class="hljs-keyword">on</span> the graves of the dead! A<br>     <br><span class="hljs-number">2</span>.查看<span class="hljs-keyword">a</span>.txt文件第三行的内容<br>[root@Dezyan ~]# sed -n <span class="hljs-string">&#x27;3p&#x27;</span> <span class="hljs-keyword">a</span>.txt <br><span class="hljs-keyword">all</span> night long.<br><br><span class="hljs-number">3</span>.查看<span class="hljs-keyword">a</span>.txt文件中第三行到结尾的内容<br>[root@Dezyan ~]#  sed -n <span class="hljs-string">&#x27;3,$p&#x27;</span> <span class="hljs-keyword">a</span>.txt <br><span class="hljs-keyword">all</span> night long.<br><span class="hljs-keyword">on</span> the mountains, <span class="hljs-keyword">on</span> the meadows, <br><span class="hljs-keyword">on</span> the roofs of the living, <span class="hljs-keyword">on</span> the graves of the dead! A<br><br><span class="hljs-number">4</span>.查看<span class="hljs-keyword">a</span>.txt中以<span class="hljs-keyword">o</span>开头或以T开头的行<br>[root@Dezyan ~]# sed -rn <span class="hljs-string">&#x27;/^o|^T/p&#x27;</span> <span class="hljs-keyword">a</span>.txt <br>The <span class="hljs-keyword">first</span> snow came. <br><span class="hljs-keyword">on</span> the mountains, <span class="hljs-keyword">on</span> the meadows, <br><span class="hljs-keyword">on</span> the roofs of the living, <span class="hljs-keyword">on</span> the graves of the dead! A<br><br><span class="hljs-number">5</span>.查看<span class="hljs-keyword">a</span>.txt文件中包含<span class="hljs-keyword">so</span>与meadows行之间的内容<br>[root@Dezyan ~]# sed -n <span class="hljs-string">&#x27;/so/,/meadows/p&#x27;</span> <span class="hljs-keyword">a</span>.txt <br>How beautiful it was, falling <span class="hljs-keyword">so</span> silently <span class="hljs-keyword">all</span> day long,<br><span class="hljs-keyword">all</span> night long.<br><span class="hljs-keyword">on</span> the mountains, <span class="hljs-keyword">on</span> the meadows,<br><br><span class="hljs-number">6</span>.在<span class="hljs-keyword">a</span>.txt文件<span class="hljs-number">1</span>到<span class="hljs-number">3</span>行后都添加一行Dezyan<br>[root@Dezyan ~]# sed <span class="hljs-string">&#x27;1,3i Dezyan&#x27;</span> <span class="hljs-keyword">a</span>.txt <br>Dezyan<br>The <span class="hljs-keyword">first</span> snow came. <br>Dezyan<br>How beautiful it was, falling <span class="hljs-keyword">so</span> silently <span class="hljs-keyword">all</span> day long,<br>Dezyan<br><span class="hljs-keyword">all</span> night long.<br><span class="hljs-keyword">on</span> the mountains, <span class="hljs-keyword">on</span> the meadows, <br><span class="hljs-keyword">on</span> the roofs of the living, <span class="hljs-keyword">on</span> the graves of the dead! A<br><br><span class="hljs-number">7</span>.将<span class="hljs-keyword">a</span>.txt文件中所有的（第一个）<span class="hljs-keyword">on</span>替换为under<br>[root@Dezyan ~]# sed <span class="hljs-string">&#x27;s#on#under#g&#x27;</span> <span class="hljs-keyword">a</span>.txt （只替换第一个只需将g去掉即可）<br>The <span class="hljs-keyword">first</span> snow came. <br>How beautiful it was, falling <span class="hljs-keyword">so</span> silently <span class="hljs-keyword">all</span> day lunderg,<br><span class="hljs-keyword">all</span> night lunderg.<br>under the mountains, under the meadows, <br>under the roofs of the living, under the graves of the dead! A<br><br><span class="hljs-number">8</span>.查找roofs所在行，并将其替换为<span class="hljs-built_in">floor</span>，并且只显示替换行<br>[root@Dezyan ~]# sed -n <span class="hljs-string">&#x27;/roofs/s#roofs#floor#gp&#x27;</span> <span class="hljs-keyword">a</span>.txt<br><span class="hljs-keyword">on</span> the <span class="hljs-built_in">floor</span> of the living, <span class="hljs-keyword">on</span> the graves of the dead! A<br><br><span class="hljs-number">9</span>.删除文件amount.txt中的所有字母<br>[root@Dezyan testdir]# sed -r <span class="hljs-string">&#x27;s#[a-Z]##g&#x27;</span> amount.txt<br><br></code></pre></td></tr></table></figure><h4 id="awk-文本和数据进行处理的编程语言"><a href="#awk-文本和数据进行处理的编程语言" class="headerlink" title="awk 文本和数据进行处理的编程语言"></a>awk 文本和数据进行处理的编程语言</h4><ul><li><strong>语法形式</strong></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">awk [选项] <span class="hljs-string">&#x27;哪一行&#123;print 哪一列&#125;&#x27;</span> [<span class="hljs-built_in">file</span>]<br><span class="hljs-comment">#逻辑：按行取列，先将符合条件的行尽数找出，再对其中的某一列进行选取；</span><br><span class="hljs-comment">#awk本质上其实是一种编程语言，其中可以进行运算；</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>选项</strong></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-operator">-F</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-comment">#指定分隔符；</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>取行</strong></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#当语法形式中的`&#123;print 哪一列&#125;`为空即为取行</span><br><span class="hljs-number">1</span>.指定某行或某几行<br>语法形式：<br>awk <span class="hljs-string">&#x27;NR[运算符]n&#x27;</span> file<br>使用awk内置变量：<br>NR  --&gt; 存储每行的行号<br>运算符：<br>== 等于<br>&gt;  大于<br>&gt;= 大于等于<br>&lt;  小于<br>&lt;= 小于等于<br>!= 不等于<br>&amp;&amp; 且<br>|| 或<br><span class="hljs-comment">#可使用内置函数取出文件内容的最后一行</span><br>awk <span class="hljs-string">&#x27;END&#123;print&#125;&#x27;</span> file<br><span class="hljs-number">2</span>.模糊过滤取行<br>语法形式：<br>awk <span class="hljs-string">&#x27;模式&#x27;</span> file<br>模式<span class="hljs-string">&#x27;可以使用正则符号&#x27;</span>：<br><span class="hljs-regexp">//</span><span class="hljs-comment">#模糊查找文件中的字符串</span><br><span class="hljs-regexp">//</span>,<span class="hljs-regexp">//</span><span class="hljs-comment">#模糊查找两字符串之间的内容</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>字符比对查取行</strong></li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">语法形式：<br>awk [选项] &#x27;[取列内置变量] [模式匹配符] <span class="hljs-string">&quot;[表达式]&quot;</span>&#x27; <span class="hljs-built_in">file</span><br>模式匹配符：<br>==<span class="hljs-comment">#某列等于……</span><br>!=<span class="hljs-comment">#某列不等于……</span><br>~<span class="hljs-comment">#使用正则匹配字符串</span><br>!~<span class="hljs-comment">#使用正则匹配字符串并取反</span><br>表达式：<br>任意字符<br>正则表达式<br><br></code></pre></td></tr></table></figure><ul><li><strong>数字比对查取行</strong></li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">语法形式：<br>awk <span class="hljs-comment">[选项]</span> &#x27;<span class="hljs-comment">[取列内置变量]</span> <span class="hljs-comment">[模式匹配符]</span><span class="hljs-comment">[运算符]</span>n&#x27; file<br><br></code></pre></td></tr></table></figure><ul><li><strong>取列</strong></li></ul><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment">#当语法形式中的`哪一行`为空即为取列</span><br>语法形式：<br>awk <span class="hljs-string">&#x27;&#123;print [内置变量]&#125;&#x27;</span> <span class="hljs-keyword">file</span><br>awk内置变量：<br><span class="hljs-variable">$0</span>  <span class="hljs-comment"># 表示整行</span><br><span class="hljs-variable">$n</span>  <span class="hljs-comment"># 表示文件的第n列 </span><br>,   <span class="hljs-comment"># 逗号表示空格</span><br>NF  <span class="hljs-comment"># 表示每一行最后一列的列号</span><br><span class="hljs-variable">$NF</span><span class="hljs-comment"># 表示最后一列;`$(NF-1)`表示倒数倒数第二列 --&gt; 也体现了awk支持运算的特性</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>指定分隔符取列</strong></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">语法形式：<br>awk -F <span class="hljs-string">&quot;[表达式]&quot;</span> <span class="hljs-string">&#x27;&#123;print [内置变量]&#125;&#x27;</span> <span class="hljs-keyword">file</span><br>表达式：<br>任意字符<br>正则表达式<br><br></code></pre></td></tr></table></figure><ul><li><strong>指定分隔符按行取列</strong></li></ul><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">awk -F <span class="hljs-string">&quot;[表达式]&quot;</span> <span class="hljs-string">&#x27;取行方式+取列方式&#x27;</span> <span class="hljs-keyword">file</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>BEGIN的用法</strong></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">#BEGIN 是一个特殊的模式，它在处理任何输入行之前执行一次。</span><br>awk -F <span class="hljs-string">&quot;[表达式]&quot;</span> <span class="hljs-string">&#x27;BEGIN&#123;print 任意内容&#125;&#x27;</span> <span class="hljs-built_in">file</span><br><br></code></pre></td></tr></table></figure><ul><li><strong>示例</strong></li></ul><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-meta">#过滤文件的选择：/etc/passwd文件的前10行，存储到了~/passwd.txt中</span><br><span class="hljs-meta">#即：head /etc/passwd &gt;&gt; ~/passwd.txt</span><br><span class="hljs-meta">#在未明确说明分隔符时，默认指定分隔符为<span class="hljs-string">&quot;:&quot;</span></span><br><span class="hljs-number">1.</span>指定取行<br><span class="hljs-meta">#取出文件最后一行 </span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk <span class="hljs-string">&#x27;END&#123;print&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#取出第7行和第9行以及两行之间的内容</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk <span class="hljs-string">&#x27;NR&gt;=7&amp;&amp;NR&lt;=9&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">2.</span>模糊取行<br><span class="hljs-meta">#取出文件中以root开头和以adm开头以及两行之间的内容</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk <span class="hljs-string">&#x27;/^root/,/^adm/&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">3.</span>字符比对取行<br><span class="hljs-meta">#取出文件中用户名为root的行</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;$1==&quot;root&quot;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#取出文件中以nologin结尾的行</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;$NF~&quot;nologin$&quot;&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">4.</span>数字比对取行<br><span class="hljs-meta">#取出用户uid大于6的行</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;$3&gt;6&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">5.</span>取列<br><span class="hljs-meta">#输出文件每一行最后一列的序号（以:或\或:\为分隔符）</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F <span class="hljs-string">&quot;[:/]+&quot;</span> <span class="hljs-string">&#x27;&#123;print NF&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#输出文件的第一列和最后一列（以:或\或:\为分隔符）</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F <span class="hljs-string">&quot;[:/]+&quot;</span> <span class="hljs-string">&#x27;&#123;print $1,$NF&#125;&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">6.</span>BEGIN用法示例<br><span class="hljs-meta">#在输出文件第一列内容前，先输出“用户名”</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;BEGIN&#123;print &quot;用户名&quot;&#125;&#123;print $1&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#让输出的第一列内容前，都有“用户名：”几个字</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;&#123;print &quot;用户名：&quot;  $1&#125;&#x27;</span> passwd.txt</span><br><br><span class="hljs-number">7.</span>综合运用<br><span class="hljs-meta">#输出文件最后一行的最后一列</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;END&#123;print $NF&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#输出大于第5行到结尾的内容，并取出第3列</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;NR&gt;5&#123;print $3&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#输出用户uid大于6的行并输出用户名</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;$3&gt;6&#123;print $1&#125;&#x27;</span> passwd.txt</span><br><span class="hljs-meta">#将系统重不能登录的用户输出到nologin.txt文件中，并在文件的开头显示“不能登录的用户有：”</span><br><span class="hljs-meta">##注：使用awk命令；不能使用管道符</span><br>[root<span class="hljs-symbol">@Dezyan</span> ~/testdir]<span class="hljs-meta"># awk -F: <span class="hljs-string">&#x27;BEGIN&#123;print &quot;不能登录的用户有：&quot;&#125; $NF~&quot;nologin$&quot;&#123;print $1&#125;&#x27;</span> /etc/passwd &gt;&gt; nologin.txt</span><br>不能登录的用户有：<br>bin<br>daemon<br>……………………<br><br><br><br></code></pre></td></tr></table></figure><p>  本文转自 <a href="https://blog.csdn.net/dingzy1/article/details/143837764?spm=1001.2014.3001.5506">https://blog.csdn.net/dingzy1/article/details/143837764?spm=1001.2014.3001.5506</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <categories>
      
      <category>Linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为路由器NAT</title>
    <link href="/2024/09/22/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8NAT/"/>
    <url>/2024/09/22/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8NAT/</url>
    
    <content type="html"><![CDATA[<p>华为路由器配置NAT  </p><img src="/2024/09/22/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8NAT/%E6%8B%93%E6%89%91.png" class="" title="华为路由器NAT"><hr><p><strong>配置R1接口和默认路由（基础配置）</strong></p><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1<br>[R1-GigabitEthernet0&#x2F;0&#x2F;1]ip address 10.1.1.2 24</p><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;2<br>[R1-GigabitEthernet0&#x2F;0&#x2F;2]ip address 192.168.11.254 24</p><p>添加默认路由，下一跳指向10.1.1.1<br>[R1]ip route-static 0.0.0.0 0 10.1.1.1</p><p>配置外网R2路由器<br>[R2]interface GigabitEthernet 0&#x2F;0&#x2F;1<br>[R2-GigabitEthernet0&#x2F;0&#x2F;1]ip add 10.1.1.1 24</p><p>配置本地环回接口，模拟互联网站<br>[R2]interface LoopBack 0<br>[R2-LoopBack0]ip address 8.8.8.8 32</p><h3 id="上面配置不变，以下各需求下都用此部分配置"><a href="#上面配置不变，以下各需求下都用此部分配置" class="headerlink" title="上面配置不变，以下各需求下都用此部分配置"></a>上面配置不变，以下各需求下都用此部分配置</h3><p><strong>一，配置静态NAT</strong><br>配置静态NAT，做一对一的地址转换。假设分给内网两个电脑两个公网ip地址10.1.1.3和10.1.1.4用来上网。</p><p>在R1出口GE0&#x2F;0&#x2F;0接口上配置静态NAT，与内网电脑一一对应。</p><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1<br>[R1-GigabitEthernet0&#x2F;0&#x2F;1]nat static global 10.1.1.3 inside 192.168.11.3 netmask 255.255.255.255<br>[R1-GigabitEthernet0&#x2F;0&#x2F;1]nat static global 10.1.1.4 inside 192.168.11.4 netmask 255.255.255.255</p><hr><p>给PC配置ip，分别去访问互联网8.8.8.8，都能成功访问  </p><p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p><strong>二，使用公网地址池，为内网用户做NAT转换。（no-pat）</strong></p><p>如上图不变，假设分给公司A部分10.1.1.10-10.1.1.20为内网192.168.11.0&#x2F;24的员工上网所用。</p><p>在R1上配置地址池<br>[R1]nat address-group 1 10.1.1.10 10.1.1.20</p><p>创建acl，匹配需要上网的内网段<br>[R1]acl 2000<br>[R1-acl-basic-2000]rule permit source 192.168.11.0 0.0.0.255</p><p>在路由出口引用acl 2000，使匹配的网段中的地址可以使用地址池中地址进行NAT转换。</p><p>[R1-GigabitEthernet0&#x2F;0&#x2F;1]nat outbound 2000 address-group 1 no-pat</p><p>在路由出口GE0&#x2F;0&#x2F;1上抓包，可看到内网地址已被转换为10.1.1.10发出。  </p><img src="/2024/09/22/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8NAT/%E6%8A%93%E5%8C%851.png" class="" title="华为路由器NAT"><p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>三，使用Easy-IP配置NAT实现上网（端口转换）</strong></p><p>如图，拓扑和网段不变，假设公司人员越来越多，公网地址紧张，于是使用Easy IP 的方式满足让B部门上网的需求。</p><p>配置acl 2001匹配内网需要上网的网段<br>[R1]acl 2001<br>[R1-acl-basic-2001]rule permit source 192.168.11.0 0.0.0.255</p><p>到路由出口GE0&#x2F;0&#x2F;1口调用acl 2001</p><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1<br>[R1-GigabitEthernet0&#x2F;0&#x2F;1]nat outbound 2001</p><p>用pc去ping 8.8.8.8 ，查看源地址已经是以接口地址发出了。  </p><img src="/2024/09/22/%E5%8D%8E%E4%B8%BA%E8%B7%AF%E7%94%B1%E5%99%A8NAT/%E6%8A%93%E5%8C%852.png" class="" title="华为路由器NAT"><p>=&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;<br><strong>四，配置使用公网地址池的NAT端口地址转换。</strong><br>如上图不变，假设分给公司部分10.1.1.30-10.1.1.40为内网192.168.11.0&#x2F;24的员工上网所用，要求利用端口转换实现内网上网。<br>创建可用的公网地址池<br>[R1]nat address-group 2 10.1.1.30 10.1.1.40 &#x2F;&#x2F;配置公网地址池</p><p>配置匹配的内网段<br>[R1]acl 2002 rule<br>[R1-acl-basic-2002]rule permit source 192.168.11.0 0.0.0.255 配置要上网的内网段</p><p>把acl绑定到路由器出口</p><p>[R1]interface GigabitEthernet 0&#x2F;0&#x2F;1<br>[R1-GigabitEthernet0&#x2F;0&#x2F;1]nat outbound 2002 address-group 2</p>]]></content>
    
    
    <categories>
      
      <category>eNSP网络搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单臂路由VLAN互联</title>
    <link href="/2024/09/13/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1VLAN%E4%BA%92%E8%81%94/"/>
    <url>/2024/09/13/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1VLAN%E4%BA%92%E8%81%94/</url>
    
    <content type="html"><![CDATA[<h1 id="单臂路由VLAN互联"><a href="#单臂路由VLAN互联" class="headerlink" title="单臂路由VLAN互联"></a>单臂路由VLAN互联</h1><h2 id="1、网络拓扑"><a href="#1、网络拓扑" class="headerlink" title="1、网络拓扑"></a>1、网络拓扑</h2><img src="/2024/09/13/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1VLAN%E4%BA%92%E8%81%94/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1.jpg" class="" title="单臂路由VLAN互联"><h2 id="2、交换机LSW1配置"><a href="#2、交换机LSW1配置" class="headerlink" title="2、交换机LSW1配置"></a>2、交换机LSW1配置</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type ac<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">10</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">3</span><br><span class="hljs-attribute">port</span> link-type ac<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">20</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type tr<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>划两个vlan即可，记得配置trunk口</p><h2 id="3、路由器配置"><a href="#3、路由器配置" class="headerlink" title="3、路由器配置"></a>3、路由器配置</h2><h3 id="3-1-创建两个子接口关联vlan并配置IP"><a href="#3-1-创建两个子接口关联vlan并配置IP" class="headerlink" title="3.1 创建两个子接口关联vlan并配置IP"></a>3.1 创建两个子接口关联vlan并配置IP</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>.<span class="hljs-number">10</span><br><span class="hljs-attribute">dot1q</span> termination  vid <span class="hljs-number">10</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.10.1</span> <span class="hljs-number">24</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span>.<span class="hljs-number">20</span><br><span class="hljs-attribute">dot1q</span> termination  vid <span class="hljs-number">20</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.20.1</span> <span class="hljs-number">24</span><br><br><span class="hljs-comment">#dis ip int b查看一下是否配置成功</span><br></code></pre></td></tr></table></figure><h3 id="3-2-开启arp广播功能（华为产品特性）"><a href="#3-2-开启arp广播功能（华为产品特性）" class="headerlink" title="3.2 开启arp广播功能（华为产品特性）"></a>3.2 开启arp广播功能（华为产品特性）</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">arp broadcast <span class="hljs-built_in">enable</span><br></code></pre></td></tr></table></figure><h2 id="4、测试结果"><a href="#4、测试结果" class="headerlink" title="4、测试结果"></a>4、测试结果</h2><p>配置成功了！</p><img src="/2024/09/13/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1VLAN%E4%BA%92%E8%81%94/%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" class="" title="单臂路由VLAN互联">]]></content>
    
    
    <categories>
      
      <category>eNSP网络搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防火墙三区域</title>
    <link href="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/"/>
    <url>/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91.png" class="" title="防火墙三区域"><blockquote><p>实验配置目标：</p><ol><li>trust区域可以访问DMZ区域</li><li>trust区域可以访问unstrust区域</li><li>untrust区域可以访问DMZ区域</li><li>trust区域可以访问防火墙，防火墙可以访问所有区域</li></ol></blockquote><p>首先把三个区域的接口地址给配置上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs auto">Trust-&gt;R1:<br>sys<br>un in en<br>sysname Trust_R1<br>int e0/0/0<br>ip address 192.168.1.7 24<br>dis this<br><br>Unstrust-&gt;R2:<br>sys <br>un in en<br>sysname Untrust_R2<br>int e0/0/0<br>ip address 177.7.7.7 24<br>dis this<br></code></pre></td></tr></table></figure><p>DMZ: Server:  </p><img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/dmz.png" class="" title="防火墙三区域"><blockquote><p>使用命令行终端对防火墙进行配置</p></blockquote><p>首先设置好每个接口的IP地址，<code>g0/0/0</code>口除外，这是防火墙的本地口，默认设置<code>192.168.0.1</code>并且划分到<code>Trust</code>区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>Please configure the password：Admin@123<br><br>sys<br>un in en<br>sysname FW1<br>int g1/0/0<br>ip address 192.168.1.1 24<br>dis this<br>int g1/0/1<br>ip address 177.7.7.1 24<br>dis this<br>int g1/0/2<br>ip address  123.4.5.1 24<br>dis this<br>dis ip int brief<br></code></pre></td></tr></table></figure><p>接下来对接口地址进行区域划分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>sys<br>firewall zone trust<br>add int g1/0/0<br>dis this<br>quit <br>firewall zone dmz<br>add int g1/0/2<br>dis this <br>quit<br>firewall zone untrust<br>add int g1/0/1<br>dis this<br></code></pre></td></tr></table></figure><p>接下来配置第一个要求：<code>Trust区域可以访问DMZ区域</code>，先需要在防火墙上建立一条<code>Trust</code>区域到<code>DMZ</code>区域的策略，后然在<code>Trust</code>区域的R1上配置一条缺省路由即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>sys<br>security-policy<br>rule name trust_to_dmz<br>source-zone trust<br>destination-zone dmz<br>action permit<br>dis this<br><br>Trust-&gt;R1:<br>sys<br>ip route-static 0.0.0.0 0 192.168.1.1<br>dis ip routing-table<br></code></pre></td></tr></table></figure><p>接下来看第二条要求，<code>trust区域可以访问untrust区域</code><br>首先需要一条trust到untrust的策略，其次因为untrust是外网，不会接受内网<code>192.168.1.7</code>的包，需要做一个NAT源地址转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>sys<br>security-policy<br>rule name trsut_to_untrust<br>source-zone trust<br>destination-zone untrust<br>action permit<br>dis this<br>quit<br>quit<br>nat-policy<br>rule name trust_nat_untrust<br>source-zone trust<br>egress-interface g1/0/1<br>action nat easy-ip<br>dis this<br></code></pre></td></tr></table></figure><p>第三条要求：<code>untrust区域可以访问DMZ区域</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>sys<br>security-policy<br>rule name untrust_to_dmz<br>source-zone untrust<br>destination-zone dmz<br>action permit<br>dis this<br><br>Untrust-&gt;R2:<br>sys<br>ip route-static 0.0.0.0 0 177.7.7.1<br>dis this<br></code></pre></td></tr></table></figure><p>最后一个要求：<code>trust区域可以访问防火墙，防火墙可以访问所有区域</code>，首先，要使得<code>Trust</code>能访问防火墙，需要进入对应接口，允许对应服务，防火墙访问所有区域只需要一条策略允许即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs auto">Local-&gt;FW1:<br>sys<br>int g1/0/0<br>service-manage ping permit<br>dis this <br>quit<br>security-policy<br>rule name local_to_any<br>source-zone local<br>destination-zone any<br>action permit<br>dis this<br></code></pre></td></tr></table></figure><p>自己ping一下验证结果</p><blockquote><p>防火墙web端配置</p></blockquote><p>地址设置以及区域规，在<code>g1/0/0</code>接口设置的勾选上允许<code>ping</code>服务，也就是上述要求的允许<code>trust</code>访问防火墙  </p><img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/fw1.jpg" class="" title="防火墙三区域"><img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/fw2.png" class="" title="防火墙三区域"> <p>策略在这里加就是了  </p><img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/fw3.png" class="" title="防火墙三区域">  <p>NAT策略在这里  </p><img src="/2024/09/12/%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%89%E5%8C%BA%E5%9F%9F/fw-nat.jpg" class="" title="防火墙三区域">  <p>web端配置很简单看图配置就是了</p>]]></content>
    
    
    <categories>
      
      <category>eNSP网络搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>接入汇聚核心网络架构</title>
    <link href="/2024/09/01/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/09/01/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="接入汇聚核心架构网络"><a href="#接入汇聚核心架构网络" class="headerlink" title="接入汇聚核心架构网络"></a>接入汇聚核心架构网络</h1><h2 id="一、网络拓扑图"><a href="#一、网络拓扑图" class="headerlink" title="一、网络拓扑图"></a>一、网络拓扑图</h2><h3 id="1-1-静态路由内网互通"><a href="#1-1-静态路由内网互通" class="headerlink" title="1.1 静态路由内网互通"></a>1.1 静态路由内网互通</h3><img src="/2024/09/01/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84.jpg" class="" title="接入汇聚核心网络架构"><h3 id="1-2-NAT连接互联网"><a href="#1-2-NAT连接互联网" class="headerlink" title="1.2 NAT连接互联网"></a>1.2 NAT连接互联网</h3><img src="/2024/09/01/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/%E6%8E%A5%E5%85%A5%E6%B1%87%E8%81%9A%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1.jpg" class="" title="接入汇聚核心网络架构"><h2 id="二、接入层交换机配置"><a href="#二、接入层交换机配置" class="headerlink" title="二、接入层交换机配置"></a>二、接入层交换机配置</h2><h3 id="2-1-LSW1配置"><a href="#2-1-LSW1配置" class="headerlink" title="2.1 LSW1配置"></a>2.1 LSW1配置</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> JR-<span class="hljs-number">01</span><br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">10</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">20</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">3</span><br><span class="hljs-attribute">port</span> link-type trunk<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="2-2-LSW3配置"><a href="#2-2-LSW3配置" class="headerlink" title="2.2 LSW3配置"></a>2.2 LSW3配置</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> JR-<span class="hljs-number">02</span><br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">30</span> <span class="hljs-number">40</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">30</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">40</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">3</span><br><span class="hljs-attribute">port</span> link-type trunk<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">30</span> <span class="hljs-number">40</span><br></code></pre></td></tr></table></figure><h2 id="三、汇聚层交换机配置"><a href="#三、汇聚层交换机配置" class="headerlink" title="三、汇聚层交换机配置"></a>三、汇聚层交换机配置</h2><h3 id="3-1-LSW2配置"><a href="#3-1-LSW2配置" class="headerlink" title="3.1 LSW2配置"></a>3.1 LSW2配置</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> HJ-<span class="hljs-number">01</span><br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">10</span> <span class="hljs-number">20</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">10</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.10.1</span> <span class="hljs-number">255.255.255.0</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">20</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.20.1</span> <span class="hljs-number">255.255.255.0</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type trunk<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span><br><br><span class="hljs-attribute">q</span><br><span class="hljs-attribute">dhcp</span> en<br><br><span class="hljs-attribute">ip</span> pool for10<br><span class="hljs-attribute">network</span> <span class="hljs-number">192.168.10.0</span> mask <span class="hljs-number">255.255.255.0</span><br><span class="hljs-attribute">gateway</span>-list <span class="hljs-number">192.168.10.1</span><br><span class="hljs-attribute">dns</span>-list <span class="hljs-number">223.5.5.5</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">10</span><br><span class="hljs-attribute">dhcp</span> select global<br><br><span class="hljs-attribute">q</span><br><span class="hljs-attribute">ip</span> pool for20<br><span class="hljs-attribute">network</span> <span class="hljs-number">192.168.20.0</span> mask <span class="hljs-number">255.255.255.0</span><br><span class="hljs-attribute">gateway</span>-list <span class="hljs-number">192.168.20.1</span><br><span class="hljs-attribute">dns</span>-list <span class="hljs-number">223.5.5.5</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">20</span><br><span class="hljs-attribute">dhcp</span> se gl<br><br><span class="hljs-attribute">vlan</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">24</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.1.1.1</span> <span class="hljs-number">255.255.255.0</span><br><span class="hljs-comment">#将vlan 24 绑定接口 g0/0/2</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> vlan <span class="hljs-number">24</span><br><span class="hljs-comment">#dis ip int b</span><br><br><span class="hljs-comment">#配置静态路由</span><br><span class="hljs-comment">#dis ip routing-table 192.168.30.254</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.30.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.1.1.2</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.40.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.1.1.2</span><br><br><span class="hljs-comment">#缺省路由/默认路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">10.1.1.2</span> <br></code></pre></td></tr></table></figure><h3 id="3-2-LSW4配置"><a href="#3-2-LSW4配置" class="headerlink" title="3.2 LSW4配置"></a>3.2 LSW4配置</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> HJ-<span class="hljs-number">02</span><br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">30</span> <span class="hljs-number">40</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">30</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.30.1</span> <span class="hljs-number">255.255.255.0</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">40</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">192.168.40.1</span> <span class="hljs-number">255.255.255.0</span><br><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type trunk<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">30</span> <span class="hljs-number">40</span><br><br><span class="hljs-attribute">q</span><br><span class="hljs-attribute">dhcp</span> en<br><br><span class="hljs-comment">#dhcp简化配置，仅限华为部分产品</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">30</span><br><span class="hljs-attribute">dhcp</span> select interface<br><span class="hljs-attribute">dhcp</span> server dns-list <span class="hljs-number">223.5.5.5</span><br><br><span class="hljs-attribute">q</span><br><span class="hljs-comment">#dhcp简化配置，仅限华为部分产品</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">40</span><br><span class="hljs-attribute">dhcp</span> se int<br><span class="hljs-attribute">dhcp</span> server dns-list <span class="hljs-number">223.5.5.5</span><br><br><span class="hljs-attribute">vlan</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">24</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.2.1.1</span> <span class="hljs-number">255.255.255.0</span><br><span class="hljs-comment">#将vlan 24 绑定接口 g0/0/2</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> vlan <span class="hljs-number">24</span><br><span class="hljs-comment">#dis ip int b</span><br><br><span class="hljs-comment">#配置静态路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.10.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.2.1.2</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.20.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.2.1.2</span><br></code></pre></td></tr></table></figure><h2 id="四、核心层交换机配置"><a href="#四、核心层交换机配置" class="headerlink" title="四、核心层交换机配置"></a>四、核心层交换机配置</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> HX-<span class="hljs-number">1</span><br><span class="hljs-attribute">vlan</span> <span class="hljs-number">241</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">241</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.1.1.2</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">241</span><br><span class="hljs-comment">#ping 10.1.1.1</span><br><br><span class="hljs-attribute">vlan</span> <span class="hljs-number">242</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">242</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.2.1.2</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">2</span><br><span class="hljs-attribute">port</span> link-type access<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">242</span><br><span class="hljs-comment">#ping 10.2.1.1</span><br><br><span class="hljs-comment">#配置静态路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.30.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.2.1.1</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.40.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.2.1.1</span><br><span class="hljs-comment">#回程路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.10.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.1.1.1</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.20.0</span> <span class="hljs-number">255.255.255.0</span> <span class="hljs-number">10.1.1.1</span><br><br><span class="hljs-comment">#缺省路由/默认路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">10.3.1.2</span> <br><br><span class="hljs-comment">#接入互联网</span><br><span class="hljs-attribute">vlan</span> <span class="hljs-number">243</span><br><span class="hljs-attribute">int</span> vlan <span class="hljs-number">243</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.3.1.1</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">3</span><br><span class="hljs-attribute">port</span> link-type ac<br><span class="hljs-attribute">port</span> de vlan <span class="hljs-number">243</span><br></code></pre></td></tr></table></figure><h2 id="五、出口路由器NAT"><a href="#五、出口路由器NAT" class="headerlink" title="五、出口路由器NAT"></a>五、出口路由器NAT</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">10.3.1.2</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">64.1.1.1</span> <span class="hljs-number">24</span><br><br><span class="hljs-comment">#缺省路由/默认路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">0.0.0.0</span> <span class="hljs-number">64.1.1.2</span><br><span class="hljs-comment">#回程路由</span><br><span class="hljs-attribute">ip</span> route-static <span class="hljs-number">192.168.0.0</span> <span class="hljs-number">255.255.0.0</span> <span class="hljs-number">10.3.1.1</span><br><br><span class="hljs-comment">#利用acl规则进行NAT</span><br><span class="hljs-attribute">acl</span> <span class="hljs-number">2000</span><br><span class="hljs-attribute">rule</span> permit source <span class="hljs-number">192.168.0.0</span> <span class="hljs-number">0.0.255.255</span><br><span class="hljs-comment">#进入WAN口开启NAT</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br><span class="hljs-attribute">nat</span> outbound <span class="hljs-number">2000</span><br></code></pre></td></tr></table></figure><h2 id="六、互联网服务ISP"><a href="#六、互联网服务ISP" class="headerlink" title="六、互联网服务ISP"></a>六、互联网服务ISP</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sy</span><br><span class="hljs-attribute">sysname</span> ISP<br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">123.56.15.192</span> <span class="hljs-number">24</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">0</span><br><span class="hljs-attribute">ip</span> add <span class="hljs-number">64.1.1.2</span> <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><h2 id="七、ACL访问控制列表"><a href="#七、ACL访问控制列表" class="headerlink" title="七、ACL访问控制列表"></a>七、ACL访问控制列表</h2><p>在核心层LSW5上配置ACL</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#acl ? 查看acl命令帮助</span><br><span class="hljs-attribute">acl</span> <span class="hljs-number">3000</span><br><span class="hljs-comment">#允许10段访问30段</span><br><span class="hljs-attribute">rule</span> permit ip source <span class="hljs-number">192.168.10.0</span> <span class="hljs-number">0.0.0.255</span> destination <span class="hljs-number">192.168.30.0</span> <span class="hljs-number">0.0.0.255</span><br><span class="hljs-comment">#禁止20段访问30段</span><br><span class="hljs-attribute">rule</span> <span class="hljs-literal">deny</span> ip source <span class="hljs-number">192.168.20.0</span> <span class="hljs-number">0.0.0.255</span> destination <span class="hljs-number">192.168.30.0</span> <span class="hljs-number">0.0.0.255</span><br><span class="hljs-attribute">int</span> g0/<span class="hljs-number">0</span>/<span class="hljs-number">1</span><br><span class="hljs-comment">#启用acl 3000 规则的流量过滤，华为，H3C产品不写acl规则默认放行</span><br><span class="hljs-attribute">traffic</span>-filter inbound acl <span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>eNSP网络搭建</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维开发</title>
    <link href="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/"/>
    <url>/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><a href="#CICD_2">CI&#x2F;CD</a></li><li><ul><li><a href="#CI_5">持续集成（CI）</a></li><li><ul><li><a href="#_7">概念</a></li><li><a href="#_10">流程</a></li><li><a href="#_13">关键组件</a></li><li><a href="#_23">作用</a></li></ul></li><li><a href="#CD_33">持续交付（CD）</a></li><li><ul><li><a href="#_35">概念</a></li><li><a href="#_38">流程</a></li><li><a href="#_41">关键组件</a></li><li><a href="#_51">作用</a></li></ul></li></ul></li><li><a href="#GitHub_Action_58">GitHub Action</a></li><li><ul><li><a href="#_60">概念</a></li><li><a href="#_63">基本要点</a></li><li><ul><li><a href="#Workflows_65">工作流（Workflows）</a></li><li><a href="#Jobs_68">任务（Jobs）</a></li><li><a href="#Steps_71">步骤（Steps）</a></li></ul></li><li><a href="#_74">实践场景</a></li><li><ul><li><a href="#_76">需求</a></li><li><a href="#_79">步骤</a></li><li><ul><li><a href="#pull_request_81">创建pull_request工作流文件</a></li><li><a href="#PR_120">提交PR并观察</a></li><li><a href="#_125">创建用于部署的工作流文件</a></li><li><a href="#_202">部署文件</a></li><li><a href="#_226">提交到部署分支并观察</a></li></ul></li></ul></li><li><a href="#_239">其他概念介绍</a></li><li><ul><li><a href="#_241">概念功能</a></li><li><ul><li><a href="#Triggers_243">触发器（Triggers）</a></li><li><a href="#Environments_257">环境（Environments）</a></li><li><a href="#Matrix_Builds_267">矩阵构建（Matrix Builds）</a></li><li><a href="#Caching_275">缓存（Caching）</a></li><li><a href="#Custom_Actions_299">自定义操作（Custom Actions）</a></li><li><a href="#Deployment_302">部署（Deployment）</a></li><li><a href="#Secrets_305">Secrets</a></li></ul></li><li><a href="#_318">语法</a></li><li><ul><li><a href="#_320">工作流程文件结构</a></li><li><a href="#Steps_350">步骤（Steps）</a></li><li><a href="#Actions_363">操作（Actions）</a></li><li><a href="#Matrix_Builds_371">矩阵构建（Matrix Builds）</a></li><li><a href="#_379">环境变量</a></li><li><a href="#Conditions_391">条件（Conditions）</a></li><li><a href="#_400">超时和重试</a></li><li><a href="#Caching_410">缓存（Caching）</a></li></ul></li></ul></li></ul></li></ul><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><p>CI&#x2F;CD是<strong>持续集成（Continuous Integration）</strong>和<strong>持续交付（Continuous Delivery）</strong>的缩写，它旨在通过<strong>自动化</strong>的流程和工具，提高软件开发的效率、质量和交付速度。  </p><h3 id="持续集成（CI）"><a href="#持续集成（CI）" class="headerlink" title="持续集成（CI）"></a>持续集成（CI）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>持续集成是开发团队通过将代码的不同部分集成到共享存储库中，并频繁地进行构建和测试，以确保代码的一致性和稳定性。  </p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>在现在的开发模式中，一般的项目，协同开发是离不开的，这就涉及到多个开发人员编写处理自己负责的功能模块或者某些开发人员共同负责一个模块。于是，通过<strong>版本控制系统</strong>可以将各个开发人员的代码集成在该共享存储库里，在存储库里，每个开发人员根据需求的不同来创建对应的分支，在完成需求后，每个人都需要提交合并将开发分支代码集成在一起，这就需要解决代码冲突，并且如何除了code review之外如何确保这些更改对应用没有产生影响，一旦提交请求合并到主分支，<strong>自动化构建工具</strong>就会根据流程自动编译构建安装应用，并执行<strong>单元测试框架</strong>的自动化测试来校验提交的修改。  </p><h4 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h4><p>以下是一些用于构建有效CI流程的关键组件：</p><ol><li><strong>版本控制系统（Version Control System，VCS）</strong>：<ul><li>例如Git，用于跟踪代码变更，协作开发，并确保团队成员之间的代码同步。</li></ul></li><li><strong>自动化构建工具</strong>：<ul><li>如Jenkins、Travis CI、CircleCI等，用于在每次代码提交时自动触发构建过程。</li></ul></li><li><strong>单元测试框架</strong>：<ul><li>例如JUnit（Java）、pytest（Python），用于确保代码的基本功能在集成后仍然有效。</li></ul></li></ol><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>减少集成问题</strong>： 在传统的开发模式中，团队成员可能在各自的开发分支上独立工作，而在合并时可能会产生冲突和集成问题。CI通过持续集成代码，及时发现和解决这些问题，避免了集成地狱。</li><li><strong>提高代码质量</strong>： CI 强调自动化测试，包括单元测试、集成测试等。每次代码变更都会触发这些测试，确保新代码不会破坏现有功能，并减少引入 bug 的可能性。这有助于提高整体代码质量。</li><li><strong>快速反馈</strong>： CI 通过快速执行自动化构建和测试，提供了即时反馈。开发人员可以在提交代码后迅速得知其是否通过了构建和测试，帮助他们更快速地发现和修复问题。</li><li><strong>提高开发效率</strong>： 通过自动化构建、测试和部署，CI减少了手动操作的需求，提高了开发效率。开发人员可以专注于编写代码而不必花费过多时间在手动构建和测试上。</li><li><strong>自动化部署</strong>： 与持续交付（Continuous Delivery）和持续部署（Continuous Deployment）结合，CI 可以实现自动化部署。这意味着经过测试的代码变更可以自动部署到预定环境，实现快速且可靠的交付流程。</li><li><strong>团队协作</strong>： CI 鼓励团队成员频繁集成代码，确保大家的工作在一个共享的代码库中协同进行。这促进了团队之间的协作和沟通，减少了因代码集成问题而导致的沟通障碍。</li><li><strong>降低风险</strong>： 通过频繁集成和自动测试，CI 减少了发布到生产环境时出现问题的可能性。提前发现和解决问题有助于降低风险，确保稳定的软件交付。</li></ul><h3 id="持续交付（CD）"><a href="#持续交付（CD）" class="headerlink" title="持续交付（CD）"></a>持续交付（CD）</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>持续交付建立在持续集成的基础上，通过自动化的流程确保软件可以随时随地进行部署。  </p><h4 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h4><p>这时，持续交付后的代码已经在主分支上了，这处于某个版本的待发布的状态，随时可以将开发环境的功能部署到生产环境中（部署到生成环境前还需要在测试环境性能测试、回归测试、自动化测试、人工测试等），运行脚本<strong>构建打包应用</strong>，通过<strong>自动化部署工具</strong>部署到生产环境运行应用，<strong>监控</strong>生产环境指标，如出现问题和错误，可以触发手动或自动<strong>回滚</strong>，如系统正常，则定期回顾，收集反馈，优化，并<strong>持续改进</strong>。  </p><h4 id="关键组件-1"><a href="#关键组件-1" class="headerlink" title="关键组件"></a>关键组件</h4><p>以下是一些用于实现持续交付的关键组件：</p><ol><li><strong>自动化部署工具</strong>：<ul><li>例如Docker、Ansible、Kubernetes等，用于自动化地部署应用程序和其依赖。</li></ul></li><li><strong>环境配置管理</strong>：<ul><li>工具如Terraform，确保不同环境（开发、测试、生产）的一致性。</li></ul></li><li><strong>持续监控和反馈</strong>：<ul><li>使用工具如Prometheus、Grafana，确保在部署后能够监控应用程序的性能和稳定性。</li></ul></li></ol><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul><li><strong>快速交付</strong>： 持续交付强调频繁、快速地将新的代码变更交付到生产环境。这使得团队能够更加迅速地响应用户需求，推出新功能或修复 bug。</li><li><strong>稳定交付</strong>： 通过自动化测试、自动化部署和验证流程，持续交付确保每次交付都是经过充分验证的，降低了引入错误的风险，提高了软件的稳定性。</li><li><strong>降低发布成本</strong>： 持续交付通过自动化流程降低了发布的人工成本。这意味着开发团队不再需要手动执行繁琐的部署步骤，减少了错误的可能性，提高了整体效率。</li><li><strong>支持持续改进</strong>： 持续交付是一个循环过程，通过不断收集用户反馈、监控系统性能和流程改进，团队能够不断优化持续交付流程，提高整体效率和质量。</li></ul><h2 id="GitHub-Action"><a href="#GitHub-Action" class="headerlink" title="GitHub Action"></a>GitHub Action</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>采用CI&#x2F;CD可以通过自动化流程和工具自动帮你构建应用、测试应用、部署应用，将你的应用交给流程工具来管理，做到自动触发、验证、部署等功能，从而减省人工成本、提高交付速度，在敏捷开发、DevOps中扮演着重要的角色。<br>GitHub Action正是这样一个实现持续集成交付的自动化流程工具，是由GitHub提供的一个组件。你可以通过YAML文件的配置定义工作流程以构建执行CI&#x2F;CD流水线，并可以触发不同事件时（如代码提交push、Pull Request、schedule）自动执行这些工作流程。  </p><h3 id="基本要点"><a href="#基本要点" class="headerlink" title="基本要点"></a>基本要点</h3><h4 id="工作流（Workflows）"><a href="#工作流（Workflows）" class="headerlink" title="工作流（Workflows）"></a>工作流（Workflows）</h4><p>工作流是GitHub Actions执行任务的基本单位，你可以为Git上不同的事件（如push、pull、request等）定义不同的工作流，以响应操作代码的变更。  </p><h4 id="任务（Jobs）"><a href="#任务（Jobs）" class="headerlink" title="任务（Jobs）"></a>任务（Jobs）</h4><p>工作流程由一个或多个任务组成，每个任务运行在独立的虚拟环境中。任务可以是构建、测试、部署等操作。  </p><h4 id="步骤（Steps）"><a href="#步骤（Steps）" class="headerlink" title="步骤（Steps）"></a>步骤（Steps）</h4><p>任务由多个步骤组成，每个步骤执行一个操作。一个步骤可以是运行命令、使用某个预定义的操作，或者调用自定义脚本。  </p><h3 id="实践场景"><a href="#实践场景" class="headerlink" title="实践场景"></a>实践场景</h3><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>假如我们对项目中其中一个服务做了修改，添加了某些功能，完成任务后，我们在本地分支通过Git提交代码到Github项目仓库下的dev分支（这里直接本地提交到测试分支，省去测试环境测试的流程），并请求合并到master分支，这时，我们希望在合并之前先对该模块进行构建，运行测试来校验代码质量与验证代码是否出错，确保代码的基本功能在集成后仍然有效，测试通过后，提交到打包部署分支bdeploy来自动将模块打包成一个容器镜像推送到容器镜像仓库，并将docker-compose文件拷贝到远程生产服务器执行部署。  </p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><h5 id="创建pull-request工作流文件"><a href="#创建pull-request工作流文件" class="headerlink" title="创建pull_request工作流文件"></a>创建pull_request工作流文件</h5><p>在项目目录下创建.github&#x2F;workflows目录<br>添加compile.yml文件用于构建并测试项目：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">compile</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">paths:</span> <span class="hljs-comment">#当有 pull request，且文件路径包含 Java 文件或者当前的工作流配置文件时触发。</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;**.java&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">.github/workflows/compile.yml</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">compile:</span> <span class="hljs-comment">#任务名称</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">timeout-minutes:</span> <span class="hljs-number">30</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span> <span class="hljs-comment">#actions/checkout@v3 是 GitHub Actions 中一个常用的操作（Action），用于从存储库中检出代码。@v3 是指定该 Action 的版本号。在这里，v3 表示使用的是版本 3。</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Java</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-java@v3</span> <span class="hljs-comment">#actions/setup-java@v3 操作被用于设置 Java 运行环境</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">java-version:</span> <span class="hljs-string">&#x27;11&#x27;</span> <span class="hljs-comment"># 指定所需的 Java 版本</span><br>          <span class="hljs-attr">distribution:</span> <span class="hljs-string">&#x27;temurin&#x27;</span> <span class="hljs-comment">#&#x27;temurin&#x27; 表示使用 Temurin（先前称为 AdoptOpenJDK） 的发行版。Temurin 提供了免费的、社区驱动的 OpenJDK 发行版。</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">with</span> <span class="hljs-string">Maven</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">mvn</span> <span class="hljs-string">clean</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">JUnit</span> <span class="hljs-string">test</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">mvn</span> <span class="hljs-string">test</span><br><br></code></pre></td></tr></table></figure><p>上面工作流配置文件定义了在pull_request的时候会触发任务<br>定义了一个任务<code>compile</code>的四个步骤：</p><ul><li><code>Checkout code</code>：从存储库中检出代码</li><li><code>Set up Java</code>：设置Java运行环境</li><li><code>Build with Maven</code>：构建安装相关依赖</li><li><code>Run JUnit test</code>：执行单元测试</li></ul><h5 id="提交PR并观察"><a href="#提交PR并观察" class="headerlink" title="提交PR并观察"></a>提交PR并观察</h5><p>将当前分支的代码推送到远程github项目仓库的dev分支，并提PR请求合并到master分支。  </p><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/pr1.png" class="" title="运维开发"><p>提交PR后会自动触发执行工作流任务，查看详细：<br>依次执行了我们定义的任务，并且设置环境、执行构建和测试通过  </p><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/pr2.png" class="" title="运维开发"><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/pr3.png" class="" title="运维开发"><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/pr4.png" class="" title="运维开发"><p>之后可以选择合并此PR到master分支，将修改的代码合并到主分支准备部署。  </p><h5 id="创建用于部署的工作流文件"><a href="#创建用于部署的工作流文件" class="headerlink" title="创建用于部署的工作流文件"></a>创建用于部署的工作流文件</h5><p>代码合并到master分支后，在.github&#x2F;workflows目录目录下创建用于部署的工作流文件bdeploy.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">and</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">for</span> <span class="hljs-string">aliyun</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [<span class="hljs-string">bdeploy</span>]<br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">timeout-minutes:</span> <span class="hljs-number">30</span><br>    <span class="hljs-attr">strategy:</span> <span class="hljs-comment">#矩阵策略</span><br>      <span class="hljs-attr">matrix:</span><br>        <span class="hljs-attr">java:</span> [ <span class="hljs-string">&#x27;11&#x27;</span> ]<br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span> <span class="hljs-comment">#actions/checkout@v3 是 GitHub Actions 中一个常用的操作（Action），用于从存储库中检出代码。@v3 是指定该 Action 的版本号。在这里，v3 表示使用的是版本 3。</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Java</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-java@v3</span> <span class="hljs-comment">#actions/setup-java@v3 操作被用于设置 Java 运行环境</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">java-version:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">matrix.java</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-comment"># 指定所需的 Java 版本</span><br>          <span class="hljs-attr">distribution:</span> <span class="hljs-string">&#x27;temurin&#x27;</span> <span class="hljs-comment">#&#x27;temurin&#x27; 表示使用 Temurin（先前称为 AdoptOpenJDK） 的发行版。Temurin 提供了免费的、社区驱动的 OpenJDK 发行版。</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">base</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">mvn</span> <span class="hljs-string">clean</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">container</span> <span class="hljs-string">image</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">mvn</span> <span class="hljs-string">clean</span> <span class="hljs-string">package</span> <span class="hljs-string">-DskipTests</span> <span class="hljs-string">jib:build</span> <span class="hljs-comment"># -Pdocker</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">server</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          echo -e &quot;[demo] \n$&#123;&#123; secrets.SERVER_DEMO &#125;&#125; ansible_ssh_port=$&#123;&#123; secrets.PORT_DEMO &#125;&#125; ansible_ssh_user=$&#123;&#123; secrets.ACCOUNT_DEMO &#125;&#125; ansible_ssh_pass=&#x27;$&#123;&#123; secrets.PASSWORD_DEMO &#125;&#125;&#x27;&quot; &gt; ./hostfile</span><br><span class="hljs-string">          docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;touch /usr/local/demo/docker-compose-deploy.yml &amp;&amp; mv /usr/local/demo/docker-compose-deploy.yml /usr/local/demo/docker-compose-deploy.yml_bak&quot;</span><br><span class="hljs-string">          docker run -v $PWD/hostfile:/tmp/hostfile -v $PWD/deploy:/tmp/deploy -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m copy -a &quot;src=/tmp/deploy/prod/docker-compose-deploy.yml dest=/usr/local/demo/docker-compose-deploy.yml&quot;</span><br><span class="hljs-string">          docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker login --username=$&#123;&#123; secrets.ALINYUN_USERNAME &#125;&#125; --password=$&#123;&#123; secrets.ALINYUN_PASSWORD &#125;&#125; registry.cn-hangzhou.aliyuncs.com&quot;</span><br><span class="hljs-string">          docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker-compose -f /usr/local/demo/docker-compose-deploy.yml --compatibility up -d &quot;</span><br><span class="hljs-string">          docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker logout registry.cn-hangzhou.aliyuncs.com&quot;</span><br><span class="hljs-string">          rm -f hostfile</span><br></code></pre></td></tr></table></figure><p>上面工作流文件创建了一个名为Build and Deploy for aliyun的工作，定义了一个任务<code>build</code>的五个步骤：</p><ul><li><code>Checkout code</code>：从存储库中检出代码</li><li><code>Set up Java</code>：设置Java运行环境</li><li><code>Build base</code>：安装依赖构建项目</li><li><code>Build container image</code>：执行Google Jib的maven插件将当前项目打包并推送到远程容器镜像仓库。该插件的具体用法可参考我之前写的文章：</li></ul><p><a href="https://blog.csdn.net/weixin_44268936/article/details/133385011?spm=1001.2014.3001.5501">轻松构建Docker镜像：无需Docker引擎的Google Jib-CSDN博客</a></p><ul><li><code>Deploy server</code>：该部分实现了通过拷贝我们即定的docker-compose文件到远程服务器上，并在远程服务上拉取该项目的容器镜像，最后启动容器来实现部署。操作远程服务器的行为借助了<strong>自动化运维工具ansible</strong>。</li></ul><p>Ansible是一种自动化工具，基于Python开发，集合了众多运维工具（puppet、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。它是一个开源工具，使用简单，无需在被管理的主机上安装客户端，而且支持多云环境和多种操作系统。<br><a href="https://www.ansible.com/">Ansible is Simple IT Automation</a></p><p>我们来看下<code>Deploy server</code>做了什么</p><p><code>run: |</code><br>“| ”是 YAML 语法中的一个标记，表示执行一个多行字符串块，也称为“折叠块”（folded block）或“纵向线条”（vertical line），“ | ”后面的缩进代码块是一个 shell 命令的多行字符串。这样的写法允许你在一个步骤中执行多个命令，而不需要每个命令都单独使用一个步骤。</p><p><code>echo -e &quot;[demo] \n$&#123;&#123; secrets.SERVER_DEMO &#125;&#125; ansible_ssh_port=$&#123;&#123; secrets.PORT_DEMO &#125;&#125; ansible_ssh_user=$&#123;&#123; secrets.ACCOUNT_DEMO &#125;&#125; ansible_ssh_pass=&#39;$&#123;&#123; secrets.PASSWORD_DEMO &#125;&#125;&#39;&quot; &gt; ./hostfile</code><br>将要登陆的服务信息写入<code>hostfile</code>文件，<code>[ ]</code>里用于指定一个服务组别。<br>写入的格式为ansible可识别的主机清单文件格式，格式风格为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs auto">[web_servers]<br>ansible_host ansible_ssh_port=22 ansible_ssh_user=username ansible_ssh_pass=password<br></code></pre></td></tr></table></figure><p><code>$&#123;&#123; &#125;&#125;</code>为Github Actions的<code>secrets and variables</code>语法。<br>可以在项目的<code>Setting</code>的<code>secrets and variables</code>的<code>Actions</code>下来创建这些<code>Repository secrets</code>  </p><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/re1.png" class="" title="运维开发"><p><code>docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;touch /usr/local/demo/docker-compose-deploy.yml &amp;&amp; mv /usr/local/demo/docker-compose-deploy.yml /usr/local/demo/docker-compose-deploy.yml_bak&quot;</code><br>将本地主机的 hostfile 文件挂载到容器中的 &#x2F;tmp&#x2F;hostfile 目录，以提供 Ansible 主机清单。-i &#x2F;tmp&#x2F;hostfile 指定了 Ansible 主机清单文件的路径，demo 是指定的主机组。-m shell：使用 Ansible 的 shell 模块，该模块用于在目标主机上执行 shell 命令。-a “touch &#x2F;usr&#x2F;local&#x2F;demo&#x2F;docker-compose-deploy.yml &amp;&amp; mv &#x2F;usr&#x2F;local&#x2F;demo&#x2F;docker-compose-deploy.yml &#x2F;usr&#x2F;local&#x2F;demo&#x2F;docker-compose-deploy.yml_bak”：是 shell 模块的参数，其中包含要执行的 shell 命令，这创建了一个空的 docker-compose-deploy.yml 文件（如果不存在），将现有的 docker-compose-deploy.yml 部署文件备份。</p><p><code>docker run -v $PWD/hostfile:/tmp/hostfile -v $PWD/deploy:/tmp/deploy -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m copy -a &quot;src=/tmp/deploy/prod/docker-compose-deploy.yml dest=/usr/local/demo/docker-compose-deploy.yml&quot;</code><br>将本地主机的 hostfile 文件挂载到容器中的 &#x2F;tmp&#x2F;hostfile 目录，这是为了将本地主机上的 Ansible 主机清单文件提供给容器使用，并且将deploy目录下的文件挂载到容器中的 &#x2F;tmp&#x2F;deploy 目录，用于传递部署相关的文件。<br>-m copy 使用 Ansible 的 copy 模块，该模块用于复制文件。-a “src&#x3D;&#x2F;tmp&#x2F;deploy&#x2F;prod&#x2F;docker-compose-deploy.yml dest&#x3D;&#x2F;usr&#x2F;local&#x2F;demo&#x2F;docker-compose-deploy.yml” 是 copy 模块的参数，指定了源文件和目标文件的路径，这将刚刚挂载到ansible容器内的部署文件复制到远程主机的指定目录文件下，方便后续启动部署的项目容器。</p><p><code>docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker login --username=$&#123;&#123; secrets.ALINYUN_USERNAME &#125;&#125; --password=$&#123;&#123; secrets.ALINYUN_PASSWORD &#125;&#125; registry.cn-hangzhou.aliyuncs.com&quot;</code><br>在远程服务上执行docker login登录到阿里云的容器镜像仓库。</p><p><code>docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker-compose -f /usr/local/demo/docker-compose-deploy.yml --compatibility up -d &quot;</code><br>在远程服务器上执行docker-compose up来启动项目容器。</p><p><code>docker run -v $PWD/hostfile:/tmp/hostfile -e ANSIBLE_HOST_KEY_CHECKING=false --rm ghcr.io/yunhorn/ubuntu:ansible ansible -i /tmp/hostfile demo -m shell -a &quot;docker logout registry.cn-hangzhou.aliyuncs.com&quot;</code><br><code>rm -f hostfile</code><br>最后退出阿里云的容器镜像仓库并删除本地（Github项目上）hostfile文件。  </p><h5 id="部署文件"><a href="#部署文件" class="headerlink" title="部署文件"></a>部署文件</h5><p>编写用于部署我们提交的项目的docker-compose部署相关的文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><br><span class="hljs-attr">x-logging:</span><br>  <span class="hljs-string">&amp;default-logging</span><br>  <span class="hljs-attr">options:</span><br>    <span class="hljs-attr">mode:</span> <span class="hljs-string">non-blocking</span><br>    <span class="hljs-attr">max-buffer-size:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">tag:</span> <span class="hljs-string">&quot;demo.<span class="hljs-template-variable">&#123;&#123;.Name&#125;&#125;</span>&quot;</span>  <span class="hljs-comment">#配置容器的tag,以demo.为前缀,容器名称为后缀,docker-compose会给容器添加副本后缀</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">demo:</span><br>    <span class="hljs-attr">logging:</span> <span class="hljs-string">*default-logging</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">root</span> <span class="hljs-comment">#该服务内运行的进程将以root用户的身份启动</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-hangzhou.aliyuncs.com/minggo/demo:0.0.2-SNAPSHOT</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">8081</span><span class="hljs-string">:8081</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">server.port=8081</span><br></code></pre></td></tr></table></figure><h5 id="提交到部署分支并观察"><a href="#提交到部署分支并观察" class="headerlink" title="提交到部署分支并观察"></a>提交到部署分支并观察</h5><p>假设我们的部署分支是<code>bdeploy</code>，提交到该分支后会自动触发用于部署的工作流文件的任务。<br>在任务里会看到成功构建容器镜像并推送到阿里云容器镜像仓库：  </p><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/de1.png" class="" title="运维开发"> <p>成功拷贝我们的部署文件到远程服务，并且拉取我们刚刚推送的容器镜像，在服务器上创建了该容器，从而实现了项目的部署。  </p><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/de2.png" class="" title="运维开发"> <img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/de3.png" class="" title="运维开发"> <p>我们到服务器上查看</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker images<br></code></pre></td></tr></table></figure><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/do1.png" class="" title="运维开发"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker ps<br></code></pre></td></tr></table></figure><img src="/2024/08/03/%E8%BF%90%E7%BB%B4%E5%BC%80%E5%8F%91/do2.png" class="" title="运维开发"><p>以上就是一个基本的持续集成部署流程的示例，展示了如何使用 GitHub Actions 自动化构建、测试和部署一个 Java应用项目的过程。当然，GitHub Actions 的功能远不止这些，它提供了丰富的集成和自定义选项，满足各种复杂的自动化需求。  </p><h3 id="其他概念介绍"><a href="#其他概念介绍" class="headerlink" title="其他概念介绍"></a>其他概念介绍</h3><h4 id="概念功能"><a href="#概念功能" class="headerlink" title="概念功能"></a>概念功能</h4><h5 id="触发器（Triggers）"><a href="#触发器（Triggers）" class="headerlink" title="触发器（Triggers）"></a>触发器（Triggers）</h5><p>GitHub Actions 的工作流程可以通过多种触发器启动。除了常见的 on: push，还有 on: pull_request、on: schedule（定时触发）等。触发器的选择取决于你想要的 CI&#x2F;CD 触发条件。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br>  <span class="hljs-attr">schedule:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">cron:</span> <span class="hljs-string">&#x27;0 0 * * *&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="环境（Environments）"><a href="#环境（Environments）" class="headerlink" title="环境（Environments）"></a>环境（Environments）</h5><p>GitHub Actions 允许你为特定的任务或步骤定义环境。这可以是不同的操作系统（如 Windows、Linux、macOS），也可以是自定义的虚拟环境。这对于需要在不同环境中运行的项目非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">windows-latest</span><br></code></pre></td></tr></table></figure><h5 id="矩阵构建（Matrix-Builds）"><a href="#矩阵构建（Matrix-Builds）" class="headerlink" title="矩阵构建（Matrix Builds）"></a>矩阵构建（Matrix Builds）</h5><p>矩阵构建允许在不同参数下并行运行同一个工作流。这对于在多个版本、操作系统或配置下测试和构建应用程序非常有用，可以加速整个流程。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">strategy:</span><br>  <span class="hljs-attr">matrix:</span><br>    <span class="hljs-attr">node-version:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br></code></pre></td></tr></table></figure><h5 id="缓存（Caching）"><a href="#缓存（Caching）" class="headerlink" title="缓存（Caching）"></a>缓存（Caching）</h5><p>GitHub Actions 允许你缓存依赖项，以减少构建和测试的时间。通过缓存，你可以在不重复下载或构建相同依赖项的情况下提高工作流的效率。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span><br>        <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/*.lock&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          $&#123;&#123; runner.os &#125;&#125;-node-</span><br><span class="hljs-string"></span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">dependencies</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br></code></pre></td></tr></table></figure><h5 id="自定义操作（Custom-Actions）"><a href="#自定义操作（Custom-Actions）" class="headerlink" title="自定义操作（Custom Actions）"></a>自定义操作（Custom Actions）</h5><p>除了使用 GitHub Actions 提供的内置操作外，你还可以创建自己的自定义操作。这些操作可以在不同的工作流程中重复使用，使得你的配置更加模块化和可维护。  </p><h5 id="部署（Deployment）"><a href="#部署（Deployment）" class="headerlink" title="部署（Deployment）"></a>部署（Deployment）</h5><p>GitHub Actions 可以与部署目标（如服务器、云服务、容器等）集成，实现自动化部署。使用预定义的 deploy 操作或者自定义脚本，你可以将应用程序快速部署到目标环境。  </p><h5 id="Secrets"><a href="#Secrets" class="headerlink" title="Secrets"></a>Secrets</h5><p>Secrets 允许你安全地存储和使用敏感信息，如 API 密钥、访问令牌等。这些 Secrets 可以在工作流程中被引用，但不会被显示在日志中。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">deploy:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">production</span><br>      <span class="hljs-attr">uses:</span> <span class="hljs-string">my-custom-deployment-action</span><br>      <span class="hljs-attr">with:</span><br>        <span class="hljs-attr">api-key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DEPLOY_API_KEY</span> <span class="hljs-string">&#125;&#125;</span><br></code></pre></td></tr></table></figure><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><h5 id="工作流程文件结构"><a href="#工作流程文件结构" class="headerlink" title="工作流程文件结构"></a>工作流程文件结构</h5><p>一个 GitHub Actions 的工作流程文件通常包含以下几个部分：</p><ul><li><strong>name</strong>： 定义工作流程的名称。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">CI/CD</span> <span class="hljs-string">Workflow</span><br></code></pre></td></tr></table></figure><ul><li><strong>on</strong>： 定义触发工作流程的事件，如 push、pull_request 等。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br></code></pre></td></tr></table></figure><ul><li><strong>jobs</strong>： 定义工作流程中的任务，一个任务可以包含多个步骤。</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="步骤（Steps）-1"><a href="#步骤（Steps）-1" class="headerlink" title="步骤（Steps）"></a>步骤（Steps）</h5><p>步骤定义了工作流程中的具体操作。每个步骤都包含一个或多个命令，可以是运行脚本、使用预定义的操作或自定义的操作。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">code</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Set</span> <span class="hljs-string">up</span> <span class="hljs-string">Node.js</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;14&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="操作（Actions）"><a href="#操作（Actions）" class="headerlink" title="操作（Actions）"></a>操作（Actions）</h5><p>操作是可重用的、独立的任务单元。GitHub Actions 提供了一系列官方操作，也允许用户创建自定义的操作。操作可以通过 uses 字段引入。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">a</span> <span class="hljs-string">custom</span> <span class="hljs-string">action</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">./path/to/my-action</span><br></code></pre></td></tr></table></figure><h5 id="矩阵构建（Matrix-Builds）-1"><a href="#矩阵构建（Matrix-Builds）-1" class="headerlink" title="矩阵构建（Matrix Builds）"></a>矩阵构建（Matrix Builds）</h5><p>矩阵构建允许在不同参数下并行运行同一个工作流。这在同时测试多个版本或环境时非常有用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">strategy:</span><br>  <span class="hljs-attr">matrix:</span><br>    <span class="hljs-attr">node-version:</span> [<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">14</span>]<br></code></pre></td></tr></table></figure><h5 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h5><p>可以使用 env 字段定义环境变量，这些变量可以在工作流程的各个步骤中使用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">env:</span><br>  <span class="hljs-attr">MY_VARIABLE:</span> <span class="hljs-string">&#x27;some value&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Use</span> <span class="hljs-string">environment</span> <span class="hljs-string">variable</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">$MY_VARIABLE</span><br></code></pre></td></tr></table></figure><h5 id="条件（Conditions）"><a href="#条件（Conditions）" class="headerlink" title="条件（Conditions）"></a>条件（Conditions）</h5><p>可以使用 if 字段为步骤定义条件，根据条件来决定是否执行该步骤。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">only</span> <span class="hljs-string">on</span> <span class="hljs-string">main</span> <span class="hljs-string">branch</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Hello, World!&quot;</span><br>    <span class="hljs-attr">if:</span> <span class="hljs-string">github.ref</span> <span class="hljs-string">==</span> <span class="hljs-string">&#x27;refs/heads/main&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="超时和重试"><a href="#超时和重试" class="headerlink" title="超时和重试"></a>超时和重试</h5><p>使用 timeout-minutes 定义步骤的最大执行时间，使用 retry 定义步骤的最大重试次数。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">step</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;Hello, World!&quot;</span><br>    <span class="hljs-attr">timeout-minutes:</span> <span class="hljs-number">10</span><br>    <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h5 id="缓存（Caching）-1"><a href="#缓存（Caching）-1" class="headerlink" title="缓存（Caching）"></a>缓存（Caching）</h5><p>使用 actions&#x2F;cache 操作可以缓存依赖项，以减少构建和测试的时间。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">steps:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Cache</span> <span class="hljs-string">dependencies</span><br>    <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/cache@v2</span><br>    <span class="hljs-attr">with:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">~/.npm</span><br>      <span class="hljs-attr">key:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-$&#123;&#123;</span> <span class="hljs-string">hashFiles(&#x27;**/*.lock&#x27;)</span> <span class="hljs-string">&#125;&#125;</span><br>      <span class="hljs-attr">restore-keys:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">runner.os</span> <span class="hljs-string">&#125;&#125;-node-</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL手册</title>
    <link href="/2024/08/03/MySQL%E6%89%8B%E5%86%8C/"/>
    <url>/2024/08/03/MySQL%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文针对关系型数据库的一般语法。限于篇幅，本文侧重说明用法，不会展开讲解特性、原理。</p></blockquote><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="数据库术语"><a href="#数据库术语" class="headerlink" title="数据库术语"></a>数据库术语</h3><ul><li><code>数据库（database）</code> - 保存有组织的数据的容器（通常是一个文件或一组文件）。</li><li><code>数据表（table）</code> - 某种特定类型数据的结构化清单。</li><li><code>模式（schema）</code> - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。</li><li><code>列（column）</code> - 表中的一个字段。所有表都是由一个或多个列组成的。</li><li><code>行（row）</code> - 表中的一个记录。</li><li><code>主键（primary key）</code> - 一列（或一组列），其值能够唯一标识表中每一行。</li></ul><h3 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h3><blockquote><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL&#x2F;SQL、Transact-SQL 等。</p></blockquote><h4 id="SQL-语法结构"><a href="#SQL-语法结构" class="headerlink" title="SQL 语法结构"></a>SQL 语法结构</h4><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/15/16fa77ca4cc88a8a~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="sql-syntax"></p><p>SQL 语法结构包括：</p><ul><li><strong><code>子句</code></strong> - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。）</li><li><strong><code>表达式</code></strong> - 可以产生任何标量值，或由列和行的数据库表</li><li><strong><code>谓词</code></strong> - 给需要评估的 SQL 三值逻辑（3VL）（true&#x2F;false&#x2F;unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。</li><li><strong><code>查询</code></strong> - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。</li><li><strong><code>语句</code></strong> - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。</li></ul><h4 id="SQL-语法要点"><a href="#SQL-语法要点" class="headerlink" title="SQL 语法要点"></a>SQL 语法要点</h4><ul><li><strong>SQL 语句不区分大小写</strong>，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。</li></ul><p>例如：<code>SELECT</code> 与 <code>select</code> 、<code>Select</code> 是相同的。</p><ul><li><p><strong>多条 SQL 语句必须以分号（<code>;</code>）分隔</strong>。</p></li><li><p>处理 SQL 语句时，<strong>所有空格都被忽略</strong>。SQL 语句可以写成一行，也可以分写为多行。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 一行 SQL 语句</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span> <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><br><span class="hljs-comment">-- 多行 SQL 语句</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>SQL 支持三种注释</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">## 注释<span class="hljs-number">1</span><br><span class="hljs-comment">-- 注释2</span><br><span class="hljs-comment">/* 注释3 */</span><br></code></pre></td></tr></table></figure><h4 id="SQL-分类"><a href="#SQL-分类" class="headerlink" title="SQL 分类"></a>SQL 分类</h4><h4 id="数据定义语言（DDL）"><a href="#数据定义语言（DDL）" class="headerlink" title="数据定义语言（DDL）"></a>数据定义语言（DDL）</h4><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。</p><p>DDL 的主要功能是<strong>定义数据库对象</strong>。</p><p>DDL 的核心指令是 <code>CREATE</code>、<code>ALTER</code>、<code>DROP</code>。</p><h4 id="数据操纵语言（DML）"><a href="#数据操纵语言（DML）" class="headerlink" title="数据操纵语言（DML）"></a>数据操纵语言（DML）</h4><p>数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。</p><p>DML 的主要功能是 <strong>访问数据</strong>，因此其语法都是以<strong>读写数据库</strong>为主。</p><p>DML 的核心指令是 <code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>SELECT</code>。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。</p><h4 id="事务控制语言（TCL）"><a href="#事务控制语言（TCL）" class="headerlink" title="事务控制语言（TCL）"></a>事务控制语言（TCL）</h4><p>事务控制语言 (Transaction Control Language, TCL) 用于<strong>管理数据库中的事务</strong>。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。</p><p>TCL 的核心指令是 <code>COMMIT</code>、<code>ROLLBACK</code>。</p><h4 id="数据控制语言（DCL）"><a href="#数据控制语言（DCL）" class="headerlink" title="数据控制语言（DCL）"></a>数据控制语言（DCL）</h4><p>数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。</p><p>DCL 的核心指令是 <code>GRANT</code>、<code>REVOKE</code>。</p><p>DCL 以<strong>控制用户的访问权限</strong>为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：<code>CONNECT</code>、<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>EXECUTE</code>、<code>USAGE</code>、<code>REFERENCES</code>。</p><p>根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。</p><hr><p><em>（以下为 DML 语句用法）</em></p><h2 id="二、增删改查"><a href="#二、增删改查" class="headerlink" title="二、增删改查"></a>二、增删改查</h2><blockquote><p>增删改查，又称为 CRUD，数据库基本操作中的基本操作。</p></blockquote><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><blockquote><ul><li><code>INSERT INTO</code> 语句用于向表中插入新记录。</li></ul></blockquote><p><strong>插入完整的行</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username, password, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;admin&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">user</span>(username)<br><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> account;<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><blockquote><ul><li><code>UPDATE</code> 语句用于更新表中的记录。</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">SET</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span>, password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;robot&#x27;</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><blockquote><ul><li><code>DELETE</code> 语句用于删除表中的记录。</li><li><code>TRUNCATE TABLE</code> 可以清空表，也就是删除所有行。</li></ul></blockquote><p><strong>删除表中的指定数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;robot&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>清空表中的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><blockquote><ul><li><code>SELECT</code> 语句用于从数据库中查询数据。</li><li><code>DISTINCT</code> 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。</li><li><code>LIMIT</code> 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。<ul><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul></li></ul></blockquote><p><strong>查询单列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_name<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询多列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询所有列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">ELECT <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>查询不同的值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span><br>vend_id <span class="hljs-keyword">FROM</span> products;<br></code></pre></td></tr></table></figure><p><strong>限制查询结果</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 返回前 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">5</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>;<br><span class="hljs-comment">-- 返回第 3 ~ 5 行</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> mytable LIMIT <span class="hljs-number">2</span>, <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><h2 id="三、子查询"><a href="#三、子查询" class="headerlink" title="三、子查询"></a>三、子查询</h2><blockquote><p>子查询是嵌套在较大查询中的 SQL 查询。子查询也称为<strong>内部查询</strong>或<strong>内部选择</strong>，而包含子查询的语句也称为<strong>外部查询</strong>或<strong>外部选择</strong>。</p></blockquote><ul><li><p>子查询可以嵌套在 <code>SELECT</code>，<code>INSERT</code>，<code>UPDATE</code> 或 <code>DELETE</code> 语句内或另一个子查询中。</p></li><li><p>子查询通常会在另一个 <code>SELECT</code> 语句的 <code>WHERE</code> 子句中添加。</p></li><li><p>您可以使用比较运算符，如 <code>&gt;</code>，<code>&lt;</code>，或 <code>=</code>。比较运算符也可以是多行运算符，如 <code>IN</code>，<code>ANY</code> 或 <code>ALL</code>。</p></li><li><p>子查询必须被圆括号 <code>()</code> 括起来。</p></li><li><p>内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。执行过程可以参考下图：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/15/16fa77ca4da1bb77~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="sql-subqueries"></p></li></ul><p><strong>子查询的子查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, cust_contact<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> cust_id<br>                  <span class="hljs-keyword">FROM</span> orders<br>                  <span class="hljs-keyword">WHERE</span> order_num <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> order_num<br>                                      <span class="hljs-keyword">FROM</span> orderitems<br>                                      <span class="hljs-keyword">WHERE</span> prod_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;RGAN01&#x27;</span>));<br></code></pre></td></tr></table></figure><h3 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h3><ul><li><code>WHERE</code> 子句用于过滤记录，即缩小访问数据的范围。</li><li><code>WHERE</code> 后跟一个返回 <code>true</code> 或 <code>false</code> 的条件。</li><li><code>WHERE</code> 可以与 <code>SELECT</code>，<code>UPDATE</code> 和 <code>DELETE</code> 一起使用。</li><li>可以在 <code>WHERE</code> 子句中使用的操作符</li></ul><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>等于</td></tr><tr><td>&lt;&gt;</td><td>不等于。注释：在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;&#x3D;</td><td>大于等于</td></tr><tr><td>&lt;&#x3D;</td><td>小于等于</td></tr><tr><td>BETWEEN</td><td>在某个范围内</td></tr><tr><td>LIKE</td><td>搜索某种模式</td></tr><tr><td>IN</td><td>指定针对某个列的多个可能值</td></tr></tbody></table><p><strong><code>SELECT</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">WHERE</span> cust_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Kids Place&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong><code>UPDATE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> Customers<br><span class="hljs-keyword">SET</span> cust_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jack Jones&#x27;</span><br><span class="hljs-keyword">WHERE</span> cust_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Kids Place&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong><code>DELETE</code> 语句中的 <code>WHERE</code> 子句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">WHERE</span> cust_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Kids Place&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="IN-和-BETWEEN"><a href="#IN-和-BETWEEN" class="headerlink" title="IN 和 BETWEEN"></a>IN 和 BETWEEN</h3><ul><li><code>IN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是在指定的几个特定值中任选一个值。</li><li><code>BETWEEN</code> 操作符在 <code>WHERE</code> 子句中使用，作用是选取介于某个范围内的值。</li></ul><p><strong>IN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;DLL01&#x27;</span>, <span class="hljs-string">&#x27;BRS01&#x27;</span>);<br></code></pre></td></tr></table></figure><p><strong>BETWEEN 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="AND、OR、NOT"><a href="#AND、OR、NOT" class="headerlink" title="AND、OR、NOT"></a>AND、OR、NOT</h3><ul><li><code>AND</code>、<code>OR</code>、<code>NOT</code> 是用于对过滤条件的逻辑处理指令。</li><li><code>AND</code> 优先级高于 <code>OR</code>，为了明确处理顺序，可以使用 <code>()</code>。</li><li><code>AND</code> 操作符表示左右条件都要满足。</li><li><code>OR</code> 操作符表示左右条件满足任意一个即可。</li><li><code>NOT</code> 操作符用于否定一个条件。</li></ul><p><strong>AND 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;DLL01&#x27;</span> <span class="hljs-keyword">AND</span> prod_price <span class="hljs-operator">&lt;=</span> <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p><strong>OR 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;DLL01&#x27;</span> <span class="hljs-keyword">OR</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;BRS01&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>NOT 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">3</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><ul><li><code>LIKE</code> 操作符在 <code>WHERE</code> 子句中使用，作用是确定字符串是否匹配模式。</li><li>只有字段是文本值时才使用 <code>LIKE</code>。</li><li><code>LIKE</code> 支持两个通配符匹配选项：<code>%</code> 和 <code>_</code>。</li><li>不要滥用通配符，通配符位于开头处匹配会非常慢。</li><li><code>%</code> 表示任何字符出现任意次数。</li><li><code>_</code> 表示任何字符出现一次。</li></ul><p><strong>% 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%bean bag%&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>_ 示例</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> prod_id, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;__ inch teddy bear&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="四、连接和组合"><a href="#四、连接和组合" class="headerlink" title="四、连接和组合"></a>四、连接和组合</h2><h3 id="连接（JOIN）"><a href="#连接（JOIN）" class="headerlink" title="连接（JOIN）"></a>连接（JOIN）</h3><blockquote><ul><li>如果一个 <code>JOIN</code> 至少有一个公共字段并且它们之间存在关系，则该 <code>JOIN</code> 可以在两个或多个表上工作。</li><li>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</li><li><code>JOIN</code> 保持基表（结构和数据）不变。</li><li><code>JOIN</code> 有两种连接类型：内连接和外连接。</li><li>内连接又称等值连接，使用 INNER <code>JOIN</code> 关键字。在没有条件语句的情况下返回笛卡尔积。<ul><li>自连接可以看成内连接的一种，只是连接的表是自身而已。</li></ul></li><li>自然连接是把同名列通过 &#x3D; 测试连接起来的，同名列可以有多个。</li><li>内连接 vs 自然连接<ul><li>内连接提供连接的列，而自然连接自动连接所有同名列。</li></ul></li><li>外连接返回一个表中的所有行，并且仅返回来自次表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。<ul><li>左外连接就是保留左表没有关联的行。</li><li>右外连接就是保留右表没有关联的行。</li></ul></li><li>连接 vs 子查询<ul><li>连接可以替换子查询，并且比子查询的效率一般会更快。</li></ul></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/15/16fa77ca4ecc58cf~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp" alt="sql-join"></p></blockquote><h4 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> vend_name, prod_name, prod_price<br><span class="hljs-keyword">FROM</span> vendors <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> products<br><span class="hljs-keyword">ON</span> vendors.vend_id <span class="hljs-operator">=</span> products.vend_id;<br></code></pre></td></tr></table></figure><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> c1.cust_id, c1.cust_name, c1.cust_contact<br><span class="hljs-keyword">FROM</span> customers c1, customers c2<br><span class="hljs-keyword">WHERE</span> c1.cust_name <span class="hljs-operator">=</span> c2.cust_name<br><span class="hljs-keyword">AND</span> c2.cust_contact <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jim Jones&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="自然连接（NATURAL-JOIN）"><a href="#自然连接（NATURAL-JOIN）" class="headerlink" title="自然连接（NATURAL JOIN）"></a>自然连接（NATURAL JOIN）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> Products<br><span class="hljs-keyword">NATURAL</span> <span class="hljs-keyword">JOIN</span> Customers;<br></code></pre></td></tr></table></figure><h4 id="左连接（LEFT-JOIN）"><a href="#左连接（LEFT-JOIN）" class="headerlink" title="左连接（LEFT JOIN）"></a>左连接（LEFT JOIN）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customers.cust_id, orders.order_num<br><span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> orders<br><span class="hljs-keyword">ON</span> customers.cust_id <span class="hljs-operator">=</span> orders.cust_id;<br></code></pre></td></tr></table></figure><h4 id="右连接（RIGHT-JOIN）"><a href="#右连接（RIGHT-JOIN）" class="headerlink" title="右连接（RIGHT JOIN）"></a>右连接（RIGHT JOIN）</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> customers.cust_id, orders.order_num<br><span class="hljs-keyword">FROM</span> customers <span class="hljs-keyword">RIGHT</span> <span class="hljs-keyword">JOIN</span> orders<br><span class="hljs-keyword">ON</span> customers.cust_id <span class="hljs-operator">=</span> orders.cust_id;<br></code></pre></td></tr></table></figure><h3 id="组合（UNION）"><a href="#组合（UNION）" class="headerlink" title="组合（UNION）"></a>组合（UNION）</h3><ul><li><code>UNION</code> 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 <code>UNION</code> 中参与查询的提取行。</li><li><code>UNION</code> 基本规则<ul><li>所有查询的列数和列顺序必须相同。</li><li>每个查询中涉及表的列的数据类型必须相同或兼容。</li><li>通常返回的列名取自第一个查询。</li></ul></li><li>默认会去除相同行，如果需要保留相同行，使用 <code>UNION ALL</code>。</li><li>只能包含一个 <code>ORDER BY</code> 子句，并且必须位于语句的最后。</li><li>应用场景<ul><li>在一个查询中从不同的表返回结构数据。</li><li>对一个表执行多个查询，按一个查询返回数据。</li></ul></li></ul><p><strong>组合查询</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, cust_contact, cust_email<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_state <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;IL&#x27;</span>, <span class="hljs-string">&#x27;IN&#x27;</span>, <span class="hljs-string">&#x27;MI&#x27;</span>)<br><span class="hljs-keyword">UNION</span><br><span class="hljs-keyword">SELECT</span> cust_name, cust_contact, cust_email<br><span class="hljs-keyword">FROM</span> customers<br><span class="hljs-keyword">WHERE</span> cust_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Fun4All&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="JOIN-vs-UNION"><a href="#JOIN-vs-UNION" class="headerlink" title="JOIN vs UNION"></a>JOIN vs UNION</h3><ul><li>JOIN vs UNION<ul><li><code>JOIN</code> 中连接表的列可能不同，但在 <code>UNION</code> 中，所有查询的列数和列顺序必须相同。</li><li><code>UNION</code> 将查询之后的行放在一起（垂直放置），但 <code>JOIN</code> 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。</li></ul></li></ul><h2 id="五、函数"><a href="#五、函数" class="headerlink" title="五、函数"></a>五、函数</h2><blockquote><p>🔔 注意：不同数据库的函数往往各不相同，因此不可移植。本节主要以 Mysql 的函数为例。</p></blockquote><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td><code>LEFT()</code>、<code>RIGHT()</code></td><td>左边或者右边的字符</td></tr><tr><td><code>LOWER()</code>、<code>UPPER()</code></td><td>转换为小写或者大写</td></tr><tr><td><code>LTRIM()</code>、<code>RTIM()</code></td><td>去除左边或者右边的空格</td></tr><tr><td><code>LENGTH()</code></td><td>长度</td></tr><tr><td><code>SOUNDEX()</code></td><td>转换为语音值</td></tr></tbody></table><p>其中， <strong>SOUNDEX()</strong> 可以将一个字符串转换为描述其语音表示的字母数字模式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> mytable<br><span class="hljs-keyword">WHERE</span> SOUNDEX(col1) <span class="hljs-operator">=</span> SOUNDEX(<span class="hljs-string">&#x27;apple&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="日期和时间处理"><a href="#日期和时间处理" class="headerlink" title="日期和时间处理"></a>日期和时间处理</h3><ul><li>日期格式：<code>YYYY-MM-DD</code></li><li>时间格式：<code>HH:MM:SS</code></li></ul><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AddDate()</code></td><td>增加一个日期（天、周等）</td></tr><tr><td><code>AddTime()</code></td><td>增加一个时间（时、分等）</td></tr><tr><td><code>CurDate()</code></td><td>返回当前日期</td></tr><tr><td><code>CurTime()</code></td><td>返回当前时间</td></tr><tr><td><code>Date()</code></td><td>返回日期时间的日期部分</td></tr><tr><td><code>DateDiff()</code></td><td>计算两个日期之差</td></tr><tr><td><code>Date_Add()</code></td><td>高度灵活的日期运算函数</td></tr><tr><td><code>Date_Format()</code></td><td>返回一个格式化的日期或时间串</td></tr><tr><td><code>Day()</code></td><td>返回一个日期的天数部分</td></tr><tr><td><code>DayOfWeek()</code></td><td>对于一个日期，返回对应的星期几</td></tr><tr><td><code>Hour()</code></td><td>返回一个时间的小时部分</td></tr><tr><td><code>Minute()</code></td><td>返回一个时间的分钟部分</td></tr><tr><td><code>Month()</code></td><td>返回一个日期的月份部分</td></tr><tr><td><code>Now()</code></td><td>返回当前日期和时间</td></tr><tr><td><code>Second()</code></td><td>返回一个时间的秒部分</td></tr><tr><td><code>Time()</code></td><td>返回一个日期时间的时间部分</td></tr><tr><td><code>Year()</code></td><td>返回一个日期的年份部分</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">mysql<span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SELECT</span> NOW();<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs auto">2018-4-14 20:25:11<br></code></pre></td></tr></table></figure><h3 id="数值处理"><a href="#数值处理" class="headerlink" title="数值处理"></a>数值处理</h3><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>SIN()</td><td>正弦</td></tr><tr><td>COS()</td><td>余弦</td></tr><tr><td>TAN()</td><td>正切</td></tr><tr><td>ABS()</td><td>绝对值</td></tr><tr><td>SQRT()</td><td>平方根</td></tr><tr><td>MOD()</td><td>余数</td></tr><tr><td>EXP()</td><td>指数</td></tr><tr><td>PI()</td><td>圆周率</td></tr><tr><td>RAND()</td><td>随机数</td></tr></tbody></table><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><table><thead><tr><th>函 数</th><th>说 明</th></tr></thead><tbody><tr><td><code>AVG()</code></td><td>返回某列的平均值</td></tr><tr><td><code>COUNT()</code></td><td>返回某列的行数</td></tr><tr><td><code>MAX()</code></td><td>返回某列的最大值</td></tr><tr><td><code>MIN()</code></td><td>返回某列的最小值</td></tr><tr><td><code>SUM()</code></td><td>返回某列值之和</td></tr></tbody></table><p><code>AVG()</code> 会忽略 NULL 行。</p><p>使用 DISTINCT 可以让汇总函数值汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(<span class="hljs-keyword">DISTINCT</span> col1) <span class="hljs-keyword">AS</span> avg_col<br><span class="hljs-keyword">FROM</span> mytable<br></code></pre></td></tr></table></figure><h2 id="六、排序和分组"><a href="#六、排序和分组" class="headerlink" title="六、排序和分组"></a>六、排序和分组</h2><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><ul><li><code>ORDER BY</code> 用于对结果集进行排序。<ul><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul></li><li>可以按多个列进行排序，并且为每个列指定不同的排序方式</li></ul><p><strong>指定多个列的排序方向</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> products<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_price <span class="hljs-keyword">DESC</span>, prod_name <span class="hljs-keyword">ASC</span>;<br></code></pre></td></tr></table></figure><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><ul><li><code>GROUP BY</code> 子句将记录分组到汇总行中。</li><li><code>GROUP BY</code> 为每个组返回一个记录。</li><li><code>GROUP BY</code> 通常还涉及聚合：COUNT，MAX，SUM，AVG 等。</li><li><code>GROUP BY</code> 可以按一列或多列进行分组。</li><li><code>GROUP BY</code> 按分组字段进行排序后，<code>ORDER BY</code> 可以以汇总字段来进行排序。</li></ul><p><strong>分组</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name;<br></code></pre></td></tr></table></figure><p><strong>分组后排序</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(cust_address) <span class="hljs-keyword">AS</span> addr_num<br><span class="hljs-keyword">FROM</span> Customers <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cust_name <span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><h3 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h3><ul><li><code>HAVING</code> 用于对汇总的 <code>GROUP BY</code> 结果进行过滤。</li><li><code>HAVING</code> 要求存在一个 <code>GROUP BY</code> 子句。</li><li><code>WHERE</code> 和 <code>HAVING</code> 可以在相同的查询中。</li><li><code>HAVING</code> vs <code>WHERE</code><ul><li><code>WHERE</code> 和 <code>HAVING</code> 都是用于过滤。</li><li><code>HAVING</code> 适用于汇总的组记录；而 WHERE 适用于单个记录。</li></ul></li></ul><p><strong>使用 WHERE 和 HAVING 过滤数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cust_name, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">AS</span> num<br><span class="hljs-keyword">FROM</span> Customers<br><span class="hljs-keyword">WHERE</span> cust_email <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> cust_name<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><hr><p><em>（以下为 DDL 语句用法）</em></p><h2 id="七、数据定义"><a href="#七、数据定义" class="headerlink" title="七、数据定义"></a>七、数据定义</h2><blockquote><p>DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）。</p></blockquote><h3 id="数据库（DATABASE）"><a href="#数据库（DATABASE）" class="headerlink" title="数据库（DATABASE）"></a>数据库（DATABASE）</h3><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE test;<br></code></pre></td></tr></table></figure><h4 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE test;<br></code></pre></td></tr></table></figure><h3 id="数据表（TABLE）"><a href="#数据表（TABLE）" class="headerlink" title="数据表（TABLE）"></a>数据表（TABLE）</h3><h4 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h4><p><strong>普通创建</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span> (<br>  id <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) unsigned <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;Id&#x27;</span>,<br>  username <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  password <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  email <span class="hljs-type">varchar</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱&#x27;</span><br>) COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>根据已有的表创建新表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> vip_user <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="删除数据表"><a href="#删除数据表" class="headerlink" title="删除数据表"></a>删除数据表</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><h4 id="修改数据表"><a href="#修改数据表" class="headerlink" title="修改数据表"></a>修改数据表</h4><p><strong>添加列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> age <span class="hljs-type">int</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><strong>删除列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> age;<br></code></pre></td></tr></table></figure><p><strong>修改列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `<span class="hljs-keyword">user</span>`<br>MODIFY <span class="hljs-keyword">COLUMN</span> age tinyint;<br></code></pre></td></tr></table></figure><p><strong>添加主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (id);<br></code></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure><h3 id="视图（VIEW）"><a href="#视图（VIEW）" class="headerlink" title="视图（VIEW）"></a>视图（VIEW）</h3><blockquote><ul><li>定义<ul><li>视图是基于 SQL 语句的结果集的可视化的表。</li><li>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。</li></ul></li><li>作用<ul><li>简化复杂的 SQL 操作，比如复杂的联结；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul></li></ul></blockquote><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> top_10_user_view <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> id, username<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> top_10_user_view;<br></code></pre></td></tr></table></figure><h3 id="索引（INDEX）"><a href="#索引（INDEX）" class="headerlink" title="索引（INDEX）"></a>索引（INDEX）</h3><blockquote><ul><li>作用<ul><li>通过索引可以更加快速高效地查询数据。</li><li>用户无法看到索引，它们只能被用来加速查询。</li></ul></li><li>注意<ul><li>更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。</li></ul></li><li>唯一索引<ul><li>唯一索引表明此索引的每一个索引值只对应唯一的数据记录。</li></ul></li></ul></blockquote><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="创建唯一索引"><a href="#创建唯一索引" class="headerlink" title="创建唯一索引"></a>创建唯一索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">UNIQUE</span> INDEX user_index<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span> (id);<br></code></pre></td></tr></table></figure><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">DROP</span> INDEX user_index;<br></code></pre></td></tr></table></figure><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><blockquote><p>SQL 约束用于规定表中的数据规则。</p></blockquote><ul><li>如果存在违反约束的数据行为，行为会被约束终止。</li><li>约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。</li><li>约束类型<ul><li><code>NOT NULL</code> - 指示某列不能存储 NULL 值。</li><li><code>UNIQUE</code> - 保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。</li><li><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个���中的值的参照完整性。</li><li><code>CHECK</code> - 保证列中的值符合指定的条件。</li><li><code>DEFAULT</code> - 规定没有给列赋值时的默认值。</li></ul></li></ul><p>创建表时使用约束条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Users (<br>  Id <span class="hljs-type">INT</span>(<span class="hljs-number">10</span>) UNSIGNED <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;自增Id&#x27;</span>,<br>  Username <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  Password <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  Email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default&#x27;</span> COMMENT <span class="hljs-string">&#x27;邮箱地址&#x27;</span>,<br>  Enabled TINYINT(<span class="hljs-number">4</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;是否有效&#x27;</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (Id)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8mb4 COMMENT<span class="hljs-operator">=</span><span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><hr><p><em>（以下为 TCL 语句用法）</em></p><h2 id="八、事务处理"><a href="#八、事务处理" class="headerlink" title="八、事务处理"></a>八、事务处理</h2><blockquote><ul><li>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</li><li><strong>MySQL 默认是隐式提交</strong>，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>START TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交。</li><li>通过 <code>set autocommit=0</code> 可以取消自动提交，直到 <code>set autocommit=1</code> 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。</li><li>指令<ul><li><code>START TRANSACTION</code> - 指令用于标记事务的起始点。</li><li><code>SAVEPOINT</code> - 指令用于创建保留点。</li><li><code>ROLLBACK TO</code> - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 <code>START TRANSACTION</code> 语句处。</li><li><code>COMMIT</code> - 提交事务。</li></ul></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开始事务</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 插入操作 A</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;root1&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 创建保留点 updateA</span><br><span class="hljs-keyword">SAVEPOINT</span> updateA;<br><br><span class="hljs-comment">-- 插入操作 B</span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;root2&#x27;</span>, <span class="hljs-string">&#x27;xxxx@163.com&#x27;</span>);<br><br><span class="hljs-comment">-- 回滚到保留点 updateA</span><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> updateA;<br><br><span class="hljs-comment">-- 提交事务，只有操作 A 生效</span><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><hr><p><em>（以下为 DCL 语句用法）</em></p><h2 id="九、权限控制"><a href="#九、权限控制" class="headerlink" title="九、权限控制"></a>九、权限控制</h2><blockquote><ul><li><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul></li><li><p>新创建的账户没有任何权限。</p></li><li><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p></li><li><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure></li></ul></blockquote><h3 id="创建账户"><a href="#创建账户" class="headerlink" title="创建账户"></a>创建账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> myuser IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;mypassword&#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="修改账户名"><a href="#修改账户名" class="headerlink" title="修改账户名"></a>修改账户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;newuser&#x27;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;myuser&#x27;</span>;<br>FLUSH PRIVILEGES;<br></code></pre></td></tr></table></figure><h3 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="查看权限"><a href="#查看权限" class="headerlink" title="查看权限"></a>查看权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="授予权限"><a href="#授予权限" class="headerlink" title="授予权限"></a>授予权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="删除权限"><a href="#删除权限" class="headerlink" title="删除权限"></a>删除权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> <span class="hljs-keyword">SELECT</span>, <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> myuser;<br></code></pre></td></tr></table></figure><h3 id="更改密码"><a href="#更改密码" class="headerlink" title="更改密码"></a>更改密码</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> PASSWORD <span class="hljs-keyword">FOR</span> myuser <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;mypass&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="十、存储过程"><a href="#十、存储过程" class="headerlink" title="十、存储过程"></a>十、存储过程</h2><blockquote><ul><li>存储过程可以看成是对一系列 SQL 操作的批处理；</li><li>使用存储过程的好处<ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul></li><li>创建存储过程<ul><li>命令行中创建存储过程需要自定义分隔符，因为命令行是以 <code>;</code> 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</li><li>包含 in、out 和 inout 三种参数。</li><li>给变量赋值都需要用 select into 语句。</li><li>每次只能给一个变量赋值，不支持集合的操作。</li></ul></li></ul></blockquote><h3 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> `proc_adder`;<br>DELIMITER ;;<br><span class="hljs-keyword">CREATE</span> DEFINER<span class="hljs-operator">=</span>`root`@`localhost` <span class="hljs-keyword">PROCEDURE</span> `proc_adder`(<span class="hljs-keyword">IN</span> a <span class="hljs-type">int</span>, <span class="hljs-keyword">IN</span> b <span class="hljs-type">int</span>, <span class="hljs-keyword">OUT</span> sum <span class="hljs-type">int</span>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> c <span class="hljs-type">int</span>;<br>    if a <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> a <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    if b <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">set</span> b <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">end</span> if;<br><br>    <span class="hljs-keyword">set</span> sum  <span class="hljs-operator">=</span> a <span class="hljs-operator">+</span> b;<br><span class="hljs-keyword">END</span><br>;;<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="使用存储过程"><a href="#使用存储过程" class="headerlink" title="使用存储过程"></a>使用存储过程</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> <span class="hljs-variable">@b</span><span class="hljs-operator">=</span><span class="hljs-number">5</span>;<br><span class="hljs-keyword">call</span> proc_adder(<span class="hljs-number">2</span>,<span class="hljs-variable">@b</span>,<span class="hljs-variable">@s</span>);<br><span class="hljs-keyword">select</span> <span class="hljs-variable">@s</span> <span class="hljs-keyword">as</span> sum;<br></code></pre></td></tr></table></figure><h2 id="十一、游标"><a href="#十一、游标" class="headerlink" title="十一、游标"></a>十一、游标</h2><blockquote><ul><li>游标（cursor）是一个存储在 DBMS 服务器上的数据库查询，它不是一条 SELECT 语句，而是被该语句检索出来的结果集。</li><li>在存储过程中使用游标可以对一个结果集进行移动遍历。</li><li>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</li><li>使用游标的四个步骤：<ul><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ul></li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span>  <span class="hljs-keyword">PROCEDURE</span> getTotal()<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> total <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建接收游标数据的变量</span><br>    <span class="hljs-keyword">DECLARE</span> sid <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">DECLARE</span> sname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">-- 创建总数变量</span><br>    <span class="hljs-keyword">DECLARE</span> sage <span class="hljs-type">INT</span>;<br>    <span class="hljs-comment">-- 创建结束标志变量</span><br>    <span class="hljs-keyword">DECLARE</span> done <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">-- 创建游标</span><br>    <span class="hljs-keyword">DECLARE</span> cur <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> id,name,age <span class="hljs-keyword">from</span> cursor_table <span class="hljs-keyword">where</span> age<span class="hljs-operator">&gt;</span><span class="hljs-number">30</span>;<br>    <span class="hljs-comment">-- 指定游标循环结束时的返回值</span><br>    <span class="hljs-keyword">DECLARE</span> CONTINUE HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">SET</span> done <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">OPEN</span> cur;<br>    <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    WHILE(<span class="hljs-keyword">NOT</span> done)<br>    DO<br>        <span class="hljs-keyword">SET</span> total <span class="hljs-operator">=</span> total <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">FETCH</span> cur <span class="hljs-keyword">INTO</span> sid, sname, sage;<br>    <span class="hljs-keyword">END</span> WHILE;<br><br>    <span class="hljs-keyword">CLOSE</span> cur;<br>    <span class="hljs-keyword">SELECT</span> total;<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br><br><span class="hljs-comment">-- 调用存储过程</span><br><span class="hljs-keyword">call</span> getTotal();<br></code></pre></td></tr></table></figure><h2 id="十二、触发器"><a href="#十二、触发器" class="headerlink" title="十二、触发器"></a>十二、触发器</h2><blockquote><p>触发器是一种与表操作有关的数据库对象，当触发器所在表上出现指定事件时，将调用该对象，即表的操作事件触发表上的触发器的执行。</p></blockquote><p>可以使用触发器来进行审计跟踪，把修改记录到另外一张表中。</p><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程。</p><p><strong><code>BEGIN</code> 和 <code>END</code></strong></p><p>当触发器的触发条件满足时，将会执行 <code>BEGIN</code> 和 <code>END</code> 之间的触发器执行动作。</p><blockquote><p>🔔 注意：在 MySQL 中，分号 <code>;</code> 是语句结束的标识符，遇到分号表示该段语句已经结束，MySQL 可以开始执行了。因此，解释器遇到触发器执行动作中的分号后就开始执行，然后会报错，因为没有找到和 BEGIN 匹配的 END。</p><p>这时就会用到 <code>DELIMITER</code> 命令（DELIMITER 是定界符，分隔符的意思）。它是一条命令，不需要语句结束标识，语法为：<code>DELIMITER new_delemiter</code>。<code>new_delemiter</code> 可以设为 1 个或多个长度的符号，默认的是分号 <code>;</code>，我们可以把它修改为其他符号，如 <code>$</code> - <code>DELIMITER $</code> 。在这之后的语句，以分号结束，解释器不会有什么反应，只有遇到了 <code>$</code>，才认为是语句结束。注意，使用完之后，我们还应该记得把它给修改回来。</p></blockquote><p><strong><code>NEW</code> 和 <code>OLD</code></strong></p><ul><li>MySQL 中定义了 <code>NEW</code> 和 <code>OLD</code> 关键字，用来表示触发器的所在表中，触发了触发器的那一行数据。</li><li>在 <code>INSERT</code> 型触发器中，<code>NEW</code> 用来表示将要（<code>BEFORE</code>）或已经（<code>AFTER</code>）插入的新数据；</li><li>在 <code>UPDATE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被修改的原数据，<code>NEW</code> 用来表示将要或已经修改为的新数据；</li><li>在 <code>DELETE</code> 型触发器中，<code>OLD</code> 用来表示将要或已经被删除的原数据；</li><li>使用方法： <code>NEW.columnName</code> （columnName 为相应数据表某一列名）</li></ul><h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><blockquote><p>提示：为了理解触发器的要点，有必要先了解一下创建触发器的指令。</p></blockquote><p><code>CREATE TRIGGER</code> 指令用于创建触发器。</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> trigger_name<br>trigger_time<br>trigger_event<br><span class="hljs-keyword">ON</span> table_name<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>  trigger_statements<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>trigger_name：触发器名</li><li>trigger_time: 触发器的触发时机。取值为 <code>BEFORE</code> 或 <code>AFTER</code>。</li><li>trigger_event: 触发器的监听事件。取值为 <code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>。</li><li>table_name: 触发器的监听目标。指定在哪张表上建立触发器。</li><li>FOR EACH ROW: 行级监视，Mysql 固定写法，其他 DBMS 不同。</li><li>trigger_statements: 触发器执行动作。是一条或多条 SQL 语句的列表，列表内的每条语句都必须用分号 <code>;</code> 来结尾。</li></ul><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql">DELIMITER $<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> `trigger_insert_user`<br>AFTER <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> `<span class="hljs-keyword">user</span>`<br><span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span><br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `user_history`(user_id, operate_type, operate_time)<br>    <span class="hljs-keyword">VALUES</span> (NEW.id, <span class="hljs-string">&#x27;add a user&#x27;</span>,  now());<br><span class="hljs-keyword">END</span> $<br>DELIMITER ;<br></code></pre></td></tr></table></figure><h3 id="查看触发器"><a href="#查看触发器" class="headerlink" title="查看触发器"></a>查看触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TRIGGERS;<br></code></pre></td></tr></table></figure><h3 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> IF <span class="hljs-keyword">EXISTS</span> trigger_insert_user;<br></code></pre></td></tr></table></figure><p>（完）</p><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li><li><a href="https://draveness.me/mysql-transaction" title="https://draveness.me/mysql-transaction">『浅入深出』MySQL 中事务的实现</a></li><li><a href="https://www.cnblogs.com/CraryPrimitiveMan/p/4206942.html" title="https://www.cnblogs.com/CraryPrimitiveMan/p/4206942.html">MySQL 的学习–触发器</a></li><li><a href="https://zh.wikipedia.org/wiki/SQL" title="https://zh.wikipedia.org/wiki/SQL">维基百科词条 - SQL</a></li><li><a href="https://www.sitesbay.com/sql/index" title="https://www.sitesbay.com/sql/index">www.sitesbay.com/sql/index</a></li><li><a href="https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php" title="https://www.w3resource.com/sql/subqueries/understanding-sql-subqueries.php">SQL Subqueries</a></li><li><a href="https://stackoverflow.com/questions/6294778/mysql-quick-breakdown-of-the-types-of-joins" title="https://stackoverflow.com/questions/6294778/mysql-quick-breakdown-of-the-types-of-joins">Quick breakdown of the types of joins</a></li><li><a href="https://www.w3resource.com/sql/sql-union.php" title="https://www.w3resource.com/sql/sql-union.php">SQL UNION</a></li><li><a href="https://www.w3resource.com/sql/database-security/create-users.php" title="https://www.w3resource.com/sql/database-security/create-users.php">SQL database security</a></li><li><a href="https://www.cnblogs.com/chenpi/p/5136483.html" title="https://www.cnblogs.com/chenpi/p/5136483.html">Mysql 中的存储过程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
