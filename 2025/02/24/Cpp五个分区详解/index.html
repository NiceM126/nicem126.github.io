

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid-nierdemon.png">
  <link rel="icon" href="/img/fluid-nierdemon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Nier Demon">
  <meta name="keywords" content="">
  
    <meta name="description" content="在C++中，程序的内存管理被分为几个区域，这些区域每个都有其特定的用途。下面是五个分区的详细描述： 1. 栈区（Stack） 用途：用于存储局部变量和函数调用时的上下文（如返回地址与参数等）。  特点：  采用先进后出（LIFO）原则进行管理。  内存由编译器自动分配和释放，程序员无法手动干预。  栈区的内存分配和释放速度非常快。  栈的大小通常是有限的，较大的局部变量或深度递归可能导致栈溢出（S">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp五个分区详解">
<meta property="og:url" content="https://nicem126.github.io/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Nier Demon">
<meta property="og:description" content="在C++中，程序的内存管理被分为几个区域，这些区域每个都有其特定的用途。下面是五个分区的详细描述： 1. 栈区（Stack） 用途：用于存储局部变量和函数调用时的上下文（如返回地址与参数等）。  特点：  采用先进后出（LIFO）原则进行管理。  内存由编译器自动分配和释放，程序员无法手动干预。  栈区的内存分配和释放速度非常快。  栈的大小通常是有限的，较大的局部变量或深度递归可能导致栈溢出（S">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://nicem126.github.io/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/FQ.jpg">
<meta property="article:published_time" content="2025-02-24T14:28:21.000Z">
<meta property="article:modified_time" content="2025-04-18T09:44:07.355Z">
<meta property="article:author" content="Nier Demon">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://nicem126.github.io/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/FQ.jpg">
  
  
  
  <title>Cpp五个分区详解 - Nier Demon</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"nicem126.github.io","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"VRmfzrVi10XWibnlJUpR9xa8-gzGzoHsz","app_key":"nwtrisoMYMghSxqd9uNxcmu1","server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Nier Demon</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://img.niestar.tech/pics/test.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Cpp五个分区详解"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-02-24 22:28" pubdate>
          2025年2月24日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          82 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Cpp五个分区详解</h1>
            
            
              <div class="markdown-body">
                
                <p><strong>在C++中，程序的内存管理被分为几个区域，这些区域每个都有其特定的用途。下面是五个分区的详细描述：</strong></p>
<h3 id="1-栈区（Stack）"><a href="#1-栈区（Stack）" class="headerlink" title="1. 栈区（Stack）"></a>1. 栈区（Stack）</h3><ul>
<li><p>用途：用于存储局部变量和函数调用时的上下文（如返回地址与参数等）。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>采用先进后出（LIFO）原则进行管理。</p>
</li>
<li><p>内存由编译器自动分配和释放，程序员无法手动干预。</p>
</li>
<li><p>栈区的内存分配和释放速度非常快。</p>
</li>
<li><p>栈的大小通常是有限的，较大的局部变量或深度递归可能导致栈溢出（Stack Overflow）。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;    <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 存储在栈区&#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-堆区（Heap）"><a href="#2-堆区（Heap）" class="headerlink" title="2. 堆区（Heap）"></a>2. 堆区（Heap）</h3><ul>
<li><p>用途：用于动态分配内存（例如使用<code>new</code>或<code>malloc</code>时）。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>由程序员手动管理内存分配和释放（使用<code>delete</code>或<code>free</code>）。</p>
</li>
<li><p>内存大小通常只有在系统可用内存的限制下。</p>
</li>
<li><p>相较于栈区，堆区的分配和释放较慢，且容易出现内存泄漏等问题。</p>
</li>
<li><p>适合存储生命周期不明确的对象。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>; <span class="hljs-comment">// ptr 存储在堆区</span><br>    *ptr = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放堆区内存</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-静态区（Static-Data-Segment）"><a href="#3-静态区（Static-Data-Segment）" class="headerlink" title="3. 静态区（Static Data Segment）"></a>3. 静态区（Static Data Segment）</h3><ul>
<li><p>用途：用于全局变量、静态变量和常量的存储。这部分内存的生命周期从程序开始直到程序结束。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>静态变量在程序的整个运行过程中保持其值。</p>
</li>
<li><p>静态区的大小在编译时决定，且并不随函数调用而改变。</p>
</li>
<li><p>存储在静态区的变量以其初始值进行初始化。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">int</span> globalVar; <span class="hljs-comment">// 存储在静态区</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> staticVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// staticVar 存储在静态区</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-常量区（Constant-Area）"><a href="#4-常量区（Constant-Area）" class="headerlink" title="4. 常量区（Constant Area）"></a>4. 常量区（Constant Area）</h3><ul>
<li><p>用途：用于存储常量（如字符串字面量和使用<code>const</code>修饰的变量）。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>常量区中的数据是不可修改的，尝试修改将导致未定义行为。</p>
</li>
<li><p>该区通常有助于提高程序的安全性和稳定性。</p>
</li>
<li><p>具体实现和存储方式可能依赖于编译器和平台。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> constValue = <span class="hljs-number">100</span>; <span class="hljs-comment">// 存储在常量区</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">char</span>* <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// 字符串常量存储在常量区</span><br></code></pre></td></tr></table></figure>

<h3 id="5-代码区（Code-Segment）"><a href="#5-代码区（Code-Segment）" class="headerlink" title="5. 代码区（Code Segment）"></a>5. 代码区（Code Segment）</h3><ul>
<li><p>用途：存储编译生成的机器代码（即程序指令）。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>该区域通常是只读的，防止程序在运行时意外地修改代码。</p>
</li>
<li><p>包含了所有函数的实现。</p>
</li>
<li><p>使用静态分配，不占用运行时内存的动态分配。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 代码存储在代码区</span><br>    std::<span class="hljs-variable constant_">cout</span> &lt;&lt; <span class="hljs-string">&quot;This is a function.&quot;</span> &lt;&lt; std::<span class="hljs-variable constant_">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<img src="/2025/02/24/Cpp%E4%BA%94%E4%B8%AA%E5%88%86%E5%8C%BA%E8%AF%A6%E8%A7%A3/FQ.jpg" srcset="/img/loading.gif" lazyload class="" title="Cpp五个分区详解">


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在C++程序的运行过程中，不同的内存区域有各自的用途和特点：</p>
<ul>
<li><p>栈区：用于局部变量，访问速度快，自动管理。</p>
</li>
<li><p>堆区：用于动态分配内存，程序员管理。</p>
</li>
<li><p>静态区：用于全局和静态变量，生命周期与程序相同。</p>
</li>
<li><p>常量区：用于常量，防止数据修改。</p>
</li>
<li><p>代码区：存储程序的执行指令。</p>
</li>
</ul>
<p>理解这些内存区域对有效管理内存、避免内存泄漏及错误是非常重要的。</p>
<h3 id="虚函数的存储区域"><a href="#虚函数的存储区域" class="headerlink" title="虚函数的存储区域"></a>虚函数的存储区域</h3><ol>
<li>代码区（Code Segment）</li>
</ol>
<ul>
<li>虚函数的实现（代码）存储在代码区。这是程序编译后生成的机器码包含函数体的地方，所有的函数（包括虚函数）的代码都在这一区域。</li>
</ul>
<ol start="3">
<li>虚函数表（Vtable）</li>
</ol>
<ul>
<li><p>使用虚函数的类会生成一个虚函数表（Vtable），这个表通常被存储在静态区。Vtable是一个指针数组，每个类的每个虚函数都有一个对应的表项，指向类的虚函数实现。</p>
</li>
<li><p>在实例化一个对象时，对象内部会有一个指向Vtable的指针（通常称为虚指针，Vptr），这个指针存储在对象的实例内存中，位于堆或栈内存中，具体取决于对象是如何创建的。</p>
</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>虚函数的代码存储在代码区。</p>
</li>
<li><p>虚函数表（Vtable）通常存储在静态区。</p>
</li>
<li><p>对象内的虚指针（Vptr）则存储在堆区或栈区，具体取决于对象的创建方式。</p>
</li>
</ul>
<h4 id="例子说明"><a href="#例子说明" class="headerlink" title="例子说明"></a>例子说明</h4><p>下面是一个简单的示例，展示如何用虚函数实现多态：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; <span class="hljs-comment">// 这段代码在代码区</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">// 这段代码在代码区</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    Base* b;              <span class="hljs-comment">// b 变量在栈中</span><br>    Derived d;           <span class="hljs-comment">// d 对象在栈中</span><br>    b = &amp;d;              <span class="hljs-comment">// b 指向 d 的地址</span><br>    b-&gt;show();           <span class="hljs-comment">// 调用 Derived::show，通过虚指针（vptr）访问 Vtable</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中：</p>
<ul>
<li><p><code>Base</code> 和 <code>Derived</code> 的 <code>show()</code> 函数实现存储在代码区。</p>
</li>
<li><p><code>b</code> 是一个指向 <code>Base</code> 类型的指针（存储在栈区），但它指向了 <code>Derived</code> 对象。</p>
</li>
<li><p>当调用 <code>b-&gt;show()</code> 时，程序使用 <code>b</code> 的虚指针来查找 <code>Derived</code> 类的 <code>show()</code> 实现（再次通过虚函数表）。</p>
</li>
</ul>
<p><strong>在C++中，重载、重写和隐藏的概念与其他面向对象编程语言（如Java）既有相似之处，也有一些特有的实现方式。下面是对这三个概念在C++中的详细解释和示例。</strong></p>
<h3 id="1-重载（Overloading）"><a href="#1-重载（Overloading）" class="headerlink" title="1. 重载（Overloading）"></a>1. 重载（Overloading）</h3><p>定义：重载是在同一个作用域中定义多个同名的函数，但这些函数的参数列表必须不同（可以是参数类型不同、参数个数不同，或参数顺序不同）。重载是在编译时决定的。</p>
<p>特点：</p>
<ul>
<li><p>方法名相同，但参数不同（无论是类型还是数量）。</p>
</li>
<li><p>可以在同一类中或在同一作用域内进行重载。</p>
</li>
<li><p>仅通过参数类型和数量来区分，返回类型不影响重载。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">int</span> a) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display integer: &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">double</span> b) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display double: &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-keyword">display</span>(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">double</span> b) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Display int and double: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-built_in">int</span> main() &#123;<br>    Example e;<br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5</span>);        <span class="hljs-comment">// 调用第一个方法</span><br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5.0</span>);      <span class="hljs-comment">// 调用第二个方法</span><br>    e.<span class="hljs-keyword">display</span>(<span class="hljs-number">5</span>, <span class="hljs-number">2.5</span>);   <span class="hljs-comment">// 调用第三个方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-重写（Overriding）"><a href="#2-重写（Overriding）" class="headerlink" title="2. 重写（Overriding）"></a>2. 重写（Overriding）</h3><p>定义：重写是指在子类中重新定义父类的虚函数，子类中的函数必须与父类的虚函数具有相同的名称、参数列表和返回类型。重写是在运行时决定的。</p>
<p>特点：</p>
<ul>
<li><p>只有当父类的方法被声明为<code>virtual</code>时，才能在子类中重写。</p>
</li>
<li><p>允许多态性，通过父类指针或引用可以调用子类的重写方法。</p>
</li>
<li><p>使用<code>override</code>关键字能够提高代码的可读性(VS2010及以后版本)。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 声明为虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">// 重写父类方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();<br>    p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 输出: Child show</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-隐藏（Hiding）"><a href="#3-隐藏（Hiding）" class="headerlink" title="3. 隐藏（Hiding）"></a>3. 隐藏（Hiding）</h3><p>定义：在C++中，隐藏是指子类中定义了与父类同名的静态方法或非虚函数。隐藏只适用于静态方法或非虚方法，子类的方法会“隐藏”父类的同名方法。</p>
<p>特点：</p>
<ul>
<li><p>只适用于静态成员和非虚函数，虚函数不会被隐藏。</p>
</li>
<li><p>子类中的同名静态成员或函数不会覆盖父类的版本，而是隐藏了它们。</p>
</li>
<li><p>访问时推荐使用类名方式来明确调用哪个类中的成员。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parent</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent display&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 非静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Child</span> : <span class="hljs-keyword">public</span> Parent &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 隐藏父类的静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child display&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 重写父类的非静态方法</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Child show&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent::<span class="hljs-built_in">display</span>(); <span class="hljs-comment">// 输出: Parent display</span><br>    Child::<span class="hljs-built_in">display</span>();  <span class="hljs-comment">// 输出: Child display</span><br><br>    Parent* p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Child</span>();<br>    p-&gt;<span class="hljs-built_in">show</span>(); <span class="hljs-comment">// 输出: Child show</span><br>    <span class="hljs-keyword">delete</span> p;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>重载：同一作用域中同名函数，参数不同，编译时绑定。</p>
</li>
<li><p>重写：子类实现父类的虚函数，同名同签名，运行时绑定。</p>
</li>
<li><p>隐藏：子类定义与父类同名的静态方法或非虚函数，仅造成隐藏，而非重写。</p>
</li>
</ul>
<h3 id="什么是虚函数？"><a href="#什么是虚函数？" class="headerlink" title="什么是虚函数？"></a>什么是虚函数？</h3><p><strong>虚函数是C++中一种用于实现多态性的成员函数。虚函数是在基类中声明为<code>virtual</code>的函数，可以被派生类重写（覆盖）。虚函数允许通过基类的指针或引用来调用派生类的实现。虚函数的使用能够灵活地管理对象的行为，特别是在使用多态时。</strong></p>
<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><ol>
<li><p>动态多态性：虚函数支持运行时多态性。通过基类指针或引用调用虚函数时，实际调用的函数是派生类中重写的函数，而不是基类中的函数。</p>
</li>
<li><p>虚函数表（Vtable）：每一个包含虚函数的类都会有一个虚函数表，它是一个指针数组，里面存储着类中虚函数的地址。每个对象在创建时，会有一个指向虚函数表的指针（通常称为<code>vptr</code>）。</p>
</li>
<li><p>可以被重写：派生类可以重写基类的虚函数，以实现特定的行为。</p>
</li>
</ol>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta">#include </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-title">std</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span>()</span> &#123; <span class="hljs-comment">// 声明为虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Base class showing&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> : <span class="hljs-title">public</span> <span class="hljs-title">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span>() <span class="hljs-keyword">override</span></span> &#123; <span class="hljs-comment">// 重写基类的虚函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Derived class showing&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span> &#123;<br>    Base* b;          <span class="hljs-comment">// 基类指针</span><br>    Derived d;       <span class="hljs-comment">// 创建派生类对象</span><br>    b = &amp;d;          <span class="hljs-comment">// 基类指针指向派生类对象</span><br><br>    b-&gt;show();       <span class="hljs-comment">// 动态绑定，调用派生类的 show()</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">Derived <span class="hljs-keyword">class</span> <span class="hljs-symbol">showing</span><br></code></pre></td></tr></table></figure>

<h4 id="为什么在基类中使用虚函数"><a href="#为什么在基类中使用虚函数" class="headerlink" title="为什么在基类中使用虚函数?"></a>为什么在基类中使用虚函数?</h4><ol>
<li>实现多态性：</li>
</ol>
<ul>
<li>虚函数允许通过基类指针或引用调用派生类的方法，这就实现了所谓的<em>动态多态性</em>，使得可以在运行时决定调用哪个方法。这样，可以在不需要关心对象具体类型的情况下处理不同类型的对象。</li>
</ul>
<ol start="3">
<li>增强代码的灵活性与可扩展性：</li>
</ol>
<ul>
<li>使用虚函数可以使代码更灵活，允许通过继承来扩展现有类的功能，而不需要更改原有代码。这使得程序可以更容易的适应变化。</li>
</ul>
<ol start="5">
<li>统一接口：</li>
</ol>
<ul>
<li>通过在基类中声明虚函数，确保所有派生类都实现相同的方法，提供了一种统一的接口。这种接口规范使得代码更易于理解和使用。</li>
</ul>
<ol start="7">
<li>通过抽象类引入接口：</li>
</ol>
<ul>
<li>创建一个只有虚函数（即没有实现的函数）的基类，可以强制派生类实现这些函数。这种方式允许将基类定义为抽象类，提供了强制实现的能力。</li>
</ul>
<ol start="9">
<li>遵循开闭原则：</li>
</ol>
<ul>
<li>在设计中，基础类只需定义接口，而不需要知道所依赖的具体实现，符合面向对象设计的开闭原则（对扩展开放，对修改关闭）。</li>
</ul>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>虚函数在C++中是重要的面向对象编程特性之一，使得程序能够实现动态多态性。它不仅提高了代码的灵活性与可扩展性，还允许通过定义统一的接口来管理和使用不同类型的对象。</p>
<h3 id="什么是析构函数？"><a href="#什么是析构函数？" class="headerlink" title="什么是析构函数？"></a>什么是析构函数？</h3><p>析构函数（Destructor）是C++中一个特殊的成员函数，用于在对象生命周期结束时释放资源和清理工作。它的名称与类名相同，但前面加上波浪号（<code>~</code>），且不接受参数也不返回值。</p>
<h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ol>
<li><p>自动调用：当一个对象的生命周期结束时（例如超出作用域、动态分配的对象被删除），析构函数自动被调用。</p>
</li>
<li><p>只能有一个：每个类只能有一个析构函数，无法被重载。</p>
</li>
<li><p>不可继承：析构函数在派生类中不能被继承，但是可以被重写。</p>
</li>
<li><p>逆序调用：对于局部对象，当控制离开其作用域时，其析构函数按照逆序调用，即先调用最新创建的对象的析构函数。</p>
</li>
</ol>
<h4 id="析构函数的作用"><a href="#析构函数的作用" class="headerlink" title="析构函数的作用"></a>析构函数的作用</h4><ol>
<li>释放动态分配的内存：</li>
</ol>
<ul>
<li>当对象使用 <code>new</code> 操作符动态分配内存时，在析构函数中对应地使用 <code>delete</code> 释放这部分内存，防止内存泄漏。</li>
</ul>
<ol start="3">
<li>清理资源：</li>
</ol>
<ul>
<li>除了内存，析构函数还可以释放其他资源，如文件句柄、网络连接、数据库连接等。</li>
</ul>
<ol start="5">
<li>执行必要的清理工作：</li>
</ol>
<ul>
<li>可以在对象销毁前执行清理操作，确保那些需要在对象结束其生命周期前处理的操作能被执行。</li>
</ul>
<ol start="7">
<li>用于维护静态或全局资源：</li>
</ol>
<ul>
<li>当程序结束时，可以利用析构函数中装配的清理代码来确保静态对象或全局对象得到妥善处理。</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个简单的示例，展示了析构函数的用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;  <span class="hljs-comment">// 构造函数</span><br>        <span class="hljs-comment">// 分配资源</span><br>        data = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);<br>        cout &lt;&lt; <span class="hljs-string">&quot;Constructor: Resource allocated, value: &quot;</span> &lt;&lt; *data &lt;&lt; endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">MyClass</span>() &#123; <span class="hljs-comment">// 析构函数</span><br>        <span class="hljs-comment">// 释放资源</span><br>        <span class="hljs-keyword">delete</span> data;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Destructor: Resource released&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data; <span class="hljs-comment">// 指向动态分配的整数</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    &#123;<br>        MyClass obj; <span class="hljs-comment">// 创建对象，调用构造函数</span><br>    &#125; <span class="hljs-comment">// obj 超出范围，调用析构函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>:</span> Resource allocated, value: <span class="hljs-number">42</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span>:</span> Resource released<br></code></pre></td></tr></table></figure>

<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>析构函数在C++中是一个关键机制，帮助开发者管理动态资源。在设计类时，特别是涉及到动态内存分配、文件操作及其他资源管理时，必须谨慎地实现析构函数，以确保资源得到正确和及时的释放，防止内存泄漏或资源浪费。</p>
<p><strong>C++标准模板库（STL）提供了一些非常实用和强大的容器，能有效支持各种数据结构的实现和操作。以下是STL库中一些常用容器的介绍，包括<code>vector</code>、<code>list</code>、<code>deque</code>、<code>set</code>、<code>map</code>、<code>unordered_map</code>和<code>array</code>。</strong></p>
<h4 id="1-vector"><a href="#1-vector" class="headerlink" title="1. vector"></a>1. <code>vector</code></h4><ul>
<li><p>定义：<code>std::vector</code>是一个动态数组，可以根据需要调整大小。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>允许随机访问元素，可以通过索引访问。</p>
</li>
<li><p>支持在末尾插入和删除元素，时间复杂度为O(1)，但在中间位置插入和删除的时间复杂度为O(n)。</p>
</li>
<li><p>需要时，可自动扩展其容量，以容纳更多元素。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector v = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    v.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 在末尾添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : v) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-list"><a href="#2-list" class="headerlink" title="2. list"></a>2. <code>list</code></h4><ul>
<li><p>定义：<code>std::list</code>是一个双向链表，支持在任意位置高效插入和删除元素。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>不支持随机访问，必须通过迭代器顺序访问元素。</p>
</li>
<li><p>插入和删除操作的时间复杂度为O(1)（在已知的位置进行操作）。</p>
</li>
<li><p>适合频繁插入和删除的场景。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    list lst = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    lst.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 在末尾添加元素</span><br>    lst.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在头部添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : lst) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 0 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-deque"><a href="#3-deque" class="headerlink" title="3. deque"></a>3. <code>deque</code></h4><ul>
<li><p>定义：<code>std::deque</code>（双端队列）是一种支持在两端进行高效插入和删除的序列容器。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>允许在两端（前端和后端）高效地添加和删除元素，时间复杂度为O(1)。</p>
</li>
<li><p>支持随机访问，时间复杂度为O(1)。</p>
</li>
<li><p>在某些情况下，比<code>vector</code>更适合于频繁的前端插入。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    deque dq = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    dq.<span class="hljs-built_in">push_front</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 在前端添加元素</span><br>    dq.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 在后端添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : dq) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 0 1 2 3 4</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-set"><a href="#4-set" class="headerlink" title="4. set"></a>4. <code>set</code></h4><ul>
<li><p>定义：<code>std::set</code>是一个存储唯一元素的集合，底层通常使用红黑树实现。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>自动排序，且每个元素都是唯一的，不可重复。</p>
</li>
<li><p>支持高效的查找、插入和删除，时间复杂度为O(log n)。</p>
</li>
<li><p>不能通过索引访问元素，但支持迭代器。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    set s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 添加元素</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : s) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3 4 （自动排序）</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5-map"><a href="#5-map" class="headerlink" title="5. map"></a>5. <code>map</code></h4><ul>
<li><p>定义：<code>std::map</code>是一种以键值对形式存储数据的容器，底层使用红黑树。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>自动排序，键是唯一的，且不允许重复。</p>
</li>
<li><p>可以通过键高效查找、插入和删除，时间复杂度为O(log n)。</p>
</li>
<li><p>支持使用迭代器访问元素。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    map m;<br>    m[<span class="hljs-string">&quot;a&quot;</span>] = <span class="hljs-number">1</span>;<br>    m[<span class="hljs-string">&quot;b&quot;</span>] = <span class="hljs-number">2</span>;<br>    m[<span class="hljs-string">&quot;c&quot;</span>] = <span class="hljs-number">3</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : m) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: a: 1 b: 2 c: 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="6-unordered-map"><a href="#6-unordered-map" class="headerlink" title="6. unordered_map"></a>6. <code>unordered_map</code></h4><ul>
<li><p>定义：<code>std::unordered_map</code>是基于哈希表实现的关联容器，不会对元素进行排序。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>允许快速查找、插入和删除，平均时间复杂度为O(1)。</p>
</li>
<li><p>键必须是唯一的，且不能重复，插入的顺序没有保证。</p>
</li>
<li><p>适合于需要快速查找的场景。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    unordered_map um;<br>    um[<span class="hljs-string">&quot;apple&quot;</span>] = <span class="hljs-number">1</span>;<br>    um[<span class="hljs-string">&quot;banana&quot;</span>] = <span class="hljs-number">2</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pair : um) &#123;<br>        cout &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; pair.second &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: apple: 1 banana: 2 （顺序不固定）</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="7-array"><a href="#7-array" class="headerlink" title="7. array"></a>7. <code>array</code></h4><ul>
<li><p>定义：<code>std::array</code>是一个固定大小的数组容器，提供了数组的许多优点。</p>
</li>
<li><p>特点：</p>
</li>
<li><p>尺寸在编译时确定，不支持动态大小调整。</p>
</li>
<li><p>支持随机访问，和内置数组一样高效。均为常数时间复杂度 O(1)。</p>
</li>
<li><p>具有较好的类型安全性，能够使用STL算法。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    array arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr) &#123;<br>        cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 输出: 1 2 3</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>STL中的各种容器提供了丰富的数据结构支持，使得C++能够高效地处理各种数据存储和访问需求。根据不同的应用场景和需求，可以选择合适的容器来优化性能和资源使用。了解这些容器的特性和用法是使用C++进行高效编程的重要基础。</p>
<p><strong>在C++中，静态成员变量和静态成员函数是类中的特殊成员，它们有一些独特的属性和行为。下面将详细解释这两个概念，讨论它们属于哪个内存分区，并提供代码示例。</strong></p>
<h4 id="静态成员变量（Static-Member-Variables）"><a href="#静态成员变量（Static-Member-Variables）" class="headerlink" title="静态成员变量（Static Member Variables）"></a>静态成员变量（Static Member Variables）</h4><p>定义：</p>
<ul>
<li><p>静态成员变量是属于类本身而不是某个具体对象的变量。所有的对象共享同一个静态成员变量。</p>
</li>
<li><p>静态成员变量使用<code>static</code>关键字声明，且只能在类内部定义，但必须在类外部初始化。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>所有的对象共享同一个静态成员变量。</p>
</li>
<li><p>可以直接通过类名访问（不需要创建对象）。</p>
</li>
<li><p>生命周期与程序相同，在程序运行期间存在。</p>
</li>
<li><p>在类的所有对象创建之前分配内存，并在程序结束时释放。</p>
</li>
</ul>
<p>属于哪个分区：</p>
<ul>
<li>静态成员变量存储在静态区中。</li>
</ul>
<p>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 声明静态成员变量</span><br><br>    <span class="hljs-built_in">Example</span>() &#123;<br>        count++; <span class="hljs-comment">// 每创建一个对象，count加1</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Current count: &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 定义并初始化静态成员变量</span><br><span class="hljs-type">int</span> Example::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Example obj1;<br>    Example obj2;<br>    Example obj3;<br><br>    Example::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出: Current count: 3</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="静态成员函数（Static-Member-Functions）"><a href="#静态成员函数（Static-Member-Functions）" class="headerlink" title="静态成员函数（Static Member Functions）"></a>静态成员函数（Static Member Functions）</h4><p>定义：</p>
<ul>
<li><p>静态成员函数是属于类本身而不是某个具体对象的函数。静态成员函数也使用<code>static</code>关键字声明。</p>
</li>
<li><p>静态成员函数只能访问静态成员变量或其他静态成员函数，不能访问非静态成员变量和非静态成员函数。</p>
</li>
</ul>
<p>特点：</p>
<ul>
<li><p>静态成员函数可以在没有创建类的对象的情况下被调用。</p>
</li>
<li><p>不能访问类中的非静态成员（没有<code>this</code>指针）。</p>
</li>
<li><p>可以通过类名直接调用。</p>
</li>
</ul>
<p>属于哪个分区：</p>
<ul>
<li>静态成员函数的代码存储在代码区中。</li>
</ul>
<p>示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// 静态成员变量</span><br><br>    <span class="hljs-built_in">Example</span>() &#123;<br>        count++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">displayCount</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 静态成员函数</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;Current count: &quot;</span> &lt;&lt; count &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> Example::count = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Example obj1;<br>    Example obj2;<br><br>    Example::<span class="hljs-built_in">displayCount</span>(); <span class="hljs-comment">// 输出: Current count: 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>静态成员变量是类中的变量，只有一份，所有实例共享，声明时需要在类定义中及类外部定义。</p>
</li>
<li><p>静态成员函数是类中的方法，无法访问非静态的成员，但可以访问静态成员，没有 <code>this</code> 指针，通常通过类名调用。</p>
</li>
<li><p>静态成员变量：</p>
</li>
<li><p>存储在静态区。</p>
</li>
<li><p>所有对象共享。</p>
</li>
<li><p>生命周期与程序相同。</p>
</li>
<li><p>静态成员函数：</p>
</li>
<li><p>存放在代码区。</p>
</li>
<li><p>不能访问非静态成员。</p>
</li>
<li><p>可以通过类名直接调用。</p>
</li>
</ul>
<p>这两个特性在设计类时非常有用，可以用于实现类级别的数据和行为。</p>
<h3 id="const和-static-的作用及其作用域的区别。"><a href="#const和-static-的作用及其作用域的区别。" class="headerlink" title="const和 static 的作用及其作用域的区别。"></a>const和 static 的作用及其作用域的区别。</h3><p><strong>在 C++ 中，<code>const</code> 和 <code>static</code> 是两个常用的修饰符，它们可以结合使用来定义某些特定特性。下面将详细解释 <code>const</code> 和 <code>static</code> 的作用及其作用域的区别。</strong></p>
<h4 id="1-const-关键字"><a href="#1-const-关键字" class="headerlink" title="1. const 关键字"></a>1. <code>const</code> 关键字</h4><ul>
<li><p>作用：用于声明常量，即该变量在初始化后不能被修改。</p>
</li>
<li><p>作用域：<code>const</code> 变量的作用域和类型（如局部、全局或成员）有关。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">// a 是一个全局常量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">function</span>()</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>; <span class="hljs-comment">// b 是一个局部常量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在此示例中，<code>a</code> 是一个全局常量，<code>b</code> 是一个局部常量，它们的值在定义后不能被修改。<code>const</code> 的作用域取决于它所在的上下文。</p>
<p><strong>在类中的 <code>const</code>：</strong></p>
<p>在类中声明的 <code>const</code> 成员变量，意味着这个变量在对象的生命周期内无法被修改。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;<br>public:<br>    const <span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">x</span> 是一个常量成员变量<br>    MyClass(<span class="hljs-keyword">int</span> val) : <span class="hljs-keyword">x</span>(val) &#123;&#125; // 在构造函数中初始化<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-static-关键字"><a href="#2-static-关键字" class="headerlink" title="2. static 关键字"></a>2. <code>static</code> 关键字</h4><ul>
<li><p>作用：用于声明静态变量或函数，意味着该变量或函数的生命周期在整个程序运行期间持续存在。对于类中的静态成员，其值在所有对象之间共享。</p>
</li>
<li><p>作用域：</p>
</li>
<li><p>全局作用域：<code>static</code> 修饰的全局变量或函数只能在定义它们的文件内访问，具有内部链接。</p>
</li>
<li><p>类作用域：<code>static</code> 成员属于类本身，而不是类的实例，所有对象共享静态成员。</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">count</span>; <span class="hljs-comment">// 声明静态成员变量</span><br>&#125;;<br><br><span class="hljs-comment">// 静态成员需在类外初始化</span><br><span class="hljs-built_in">int</span> MyClass::<span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>count</code> 是 <code>MyClass</code> 的静态成员变量，在所有 <code>MyClass</code> 的实例中共享。</p>
<h4 id="3-const-static-的组合"><a href="#3-const-static-的组合" class="headerlink" title="3. const static 的组合"></a>3. <code>const static</code> 的组合</h4><p>当 <code>const</code> 和 <code>static</code> 组合使用时，表示该变量是类级别的常量，所有实例共享同一份常量，且其值在对象的生命周期内不可改变。</p>
<p>示例：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-type">double</span> <span class="hljs-literal">PI</span>; <span class="hljs-comment">// 声明静态常量</span><br>&#125;;<br><br><span class="hljs-comment">// 在类外初始化</span><br><span class="hljs-keyword">const</span> <span class="hljs-type">double</span> Circle::<span class="hljs-literal">PI</span> = <span class="hljs-number">3.14159</span>;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>Circle::PI</code> 是静态常量，所有 <code>Circle</code> 的实例共享 <code>PI</code> 的值。因为它是 <code>const</code> 的，这个值不能被修改。</p>
<h4 id="作用域区别总结"><a href="#作用域区别总结" class="headerlink" title="作用域区别总结"></a>作用域区别总结</h4><ul>
<li><p><code>const</code>：</p>
</li>
<li><p>局部或全局作用域，根据声明位置决定。</p>
</li>
<li><p>只能在声明它的作用域中访问（例如，局部常量只能在函数内部访问）。</p>
</li>
<li><p><code>static</code>：</p>
</li>
<li><p>全局作用域的 static 变量或函数只能在定义它的源文件中访问。</p>
</li>
<li><p>类中声明的 static 成员变量在类的所有实例之间共享，可以通过类名直接访问。</p>
</li>
<li><p><code>const static</code>：</p>
</li>
<li><p>在类中声明的 <code>const static</code> 成员变量属于类，所有实例共享并且不可改变。</p>
</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><p>使用 <code>const</code> 来定义常量值，确保它们不可被修改。</p>
</li>
<li><p>使用 <code>static</code> 来管理类中的共享状态或限制变量的作用域到声明它的文件。</p>
</li>
<li><p>使用 <code>const static</code> 来定义类级别的常量，增强代码的可读性和维护性。</p>
</li>
</ul>
<p><strong>运算符重载（Operator Overloading）是C++的一项重要特性，允许程序员为自定义类型（类）定义或重新定义运算符的行为。通过运算符重载，可以使对象看起来像内置类型一样使用，从而提高代码的可读性和可维护性。</strong></p>
<h3 id="运算符重载的基本概念"><a href="#运算符重载的基本概念" class="headerlink" title="运算符重载的基本概念"></a>运算符重载的基本概念</h3><p>在C++中，许多内置数据类型（如整型、浮点型、字符型等）支持多种运算符（如<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>[]</code>, <code>()</code>, 等）。运算符重载通过提供特定的函数定义，使得这些运算符能够作用于用户自定义类型。运算符的重载并不是创建新的运算符，而是改变其在特定上下文中的行为。</p>
<h4 id="运算符重载的基本语法"><a href="#运算符重载的基本语法" class="headerlink" title="运算符重载的基本语法"></a>运算符重载的基本语法</h4><p>运算符重载通常通过成员函数或非成员函数来实现。例如，假设我们有一个简单的 <code>Complex</code> 类来表示复数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Complex</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">double</span> <span class="hljs-keyword">real</span>;<br>    <span class="hljs-keyword">double</span> imag;<br><br>    <span class="hljs-title function_ invoke__">Complex</span>(<span class="hljs-keyword">double</span> r, <span class="hljs-keyword">double</span> i) : <span class="hljs-keyword">real</span>(r), <span class="hljs-title function_ invoke__">imag</span>(i) &#123;&#125;<br><br>    <span class="hljs-comment">// 成员函数重载 `+` 运算符</span><br>    Complex operator+(<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Complex</span>&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">Complex</span>(<span class="hljs-keyword">real</span> + other.<span class="hljs-keyword">real</span>, imag + other.imag);<br>    &#125;<br><br>    <span class="hljs-comment">// 成员函数重载 `&lt;&lt;` 运算符，以便于输出</span><br>    friend std::<span class="hljs-variable constant_">ostream</span>&amp; operator&lt;&lt;(std::<span class="hljs-variable constant_">ostream</span>&amp; os, <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">Complex</span>&amp; c) &#123;<br>        os &lt;&lt; c.<span class="hljs-keyword">real</span> &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.imag &lt;&lt; <span class="hljs-string">&quot;i&quot;</span>;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<span class="hljs-keyword">int</span> <span class="hljs-title function_ invoke__">main</span>() &#123;    <span class="hljs-comment">// 创建两个 Complex 对象    Complex c1(1.0, 2.0);    Complex c2(3.0, 4.0);    // 使用重载的 + 运算符    Complex c3 = c1 + c2; // 会调用 c1.operator+(c2)</span><br>    <span class="hljs-comment">// 使用重载的 &lt;&lt; 运算符输出结果    std::cout &lt;&lt; &quot;c1 + c2 = &quot; &lt;&lt; c3 &lt;&lt; std::endl; // 输出: c1 + c2 = 4.0 + 6.0i</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="运算符重载的注意事项"><a href="#运算符重载的注意事项" class="headerlink" title="运算符重载的注意事项"></a>运算符重载的注意事项</h4><ol>
<li><p>不能改变运算符的优先级：运算符重载并不能改变运算符的优先级或结合性，它们仍然遵循C++的默认规则。</p>
</li>
<li><p>所有现有运算符不能重载：某些运算符（如<code>::</code>, <code>.</code>, <code>.*</code>, <code>? :</code>）在C++中无法被重载。</p>
</li>
<li><p>至少一个操作数必须是用户定义的类型：运算符必须至少有一个操作数是自定义类型，才能重载该运算符。</p>
</li>
<li><p>重载函数返回类型：运算符重载函数通常返回相应类型的对象（如 <code>Complex</code> 类型的对象），以支持链式调用。</p>
</li>
</ol>
<h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>运算符重载的常见使用场景包括但不限于：</p>
<ol>
<li><p>数学类：如复数（<code>Complex</code>），矩阵（<code>Matrix</code>），向量（<code>Vector</code>），使用运算符重载可以让这些类的对象直接参与数值运算，使代码更自然易读。</p>
</li>
<li><p>容器类：如链表、栈、队列等数据结构类，重载运算符如<code>[]</code>可以方便地实现对元素的访问。</p>
</li>
<li><p>字符串类：自定义字符串类的运算符重载可以支持字符串拼接、比较等操作。</p>
</li>
<li><p>比较逻辑：重载比较运算符（如<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）可以方便地使用这些类对象进行排序和查找操作。</p>
</li>
</ol>
<h4 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h4><p>例如，我们可以创建一个表示二维点的类，并重载一些运算符以便使用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> x, y;<br><br>    <span class="hljs-built_in">Point</span>(<span class="hljs-type">int</span> xCoord, <span class="hljs-type">int</span> yCoord) : <span class="hljs-built_in">x</span>(xCoord), <span class="hljs-built_in">y</span>(yCoord) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 `+` 运算符</span><br>    Point <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x + other.x, y + other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载 `-` 运算符</span><br>    Point <span class="hljs-keyword">operator</span>-(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Point</span>(x - other.x, y - other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 重载 `==` 运算符</span><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Point&amp; other) &#123;<br>        <span class="hljs-built_in">return</span> (x == other.x) &amp;&amp; (y == other.y);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出重载</span><br>    <span class="hljs-keyword">friend</span> std::ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="hljs-type">const</span> Point&amp; p) &#123;<br>        os &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; p.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>        <span class="hljs-keyword">return</span> os;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Point <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-function">Point <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br>    Point p3 = p1 + p2; <span class="hljs-comment">// 使用重载的 +</span><br>    Point p4 = p2 - p1; <span class="hljs-comment">// 使用重载的 -</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p3: &quot;</span> &lt;&lt; p3 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出 (4, 6)</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;p4: &quot;</span> &lt;&lt; p4 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>; <span class="hljs-comment">// 输出 (2, 2)</span><br><br>    <span class="hljs-keyword">if</span> (p1 == p4) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 and p4 are equal.\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;p1 and p4 are not equal.\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个<code>Point</code>类，重载了加法（<code>+</code>）、减法（<code>-</code>）和比较（<code>==</code>）运算符，使得我们可以像使用内置类型一样使用这些对象。这样不仅增加了代码的可读性，也让用户自定义对象的使用变得更简单和自然。</p>
<h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p>运算符重载在C++中是一种强大且灵活的特性，能够使用户定义类型的行为更符合直觉，提升代码的可读性与可维护性。合理使用运算符重载可以让复杂的操作变得简单明了，但也需要注意过度重载可能导致代码的理解和维护变得困难。</p>
<h3 id="模板类和模板函数"><a href="#模板类和模板函数" class="headerlink" title="模板类和模板函数"></a>模板类和模板函数</h3><p>C++ 的模板是强大的工具，它允许开发者编写与类型无关的代码。这主要有两种形式：模板类（Class Template）和模板函数（Function Template）。</p>
<h4 id="1-模板类（Class-Template）"><a href="#1-模板类（Class-Template）" class="headerlink" title="1. 模板类（Class Template）"></a>1. 模板类（Class Template）</h4><p>模板类是一种用于创建泛型类的机制。借助模板类，可以根据不同的数据类型生成多个类，而不需要为每种数据类型重写相似的代码。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T data;<br>    <span class="hljs-built_in">MyClass</span>(T value) : <span class="hljs-built_in">data</span>(value) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; data &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2-模板函数（Function-Template）"><a href="#2-模板函数（Function-Template）" class="headerlink" title="2. 模板函数（Function Template）"></a>2. 模板函数（Function Template）</h4><p>模板函数是一种创建泛型函数的机制。使用模板函数，可以将相同的函数逻辑应用于不同的数据类型。</p>
<h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span> </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">(T arg)</span> </span>&#123;<br>    std::cout &lt;&lt; arg &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面的示例展示了如何定义一个模板类和一个模板函数，并且在 <code>main</code> 函数中使用它们。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-comment">// 模板类：Stack</span><br><span class="hljs-keyword">template</span> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    T* arr;       <span class="hljs-comment">// 动态数组</span><br>    <span class="hljs-type">int</span> top;      <span class="hljs-comment">// 栈顶索引</span><br>    <span class="hljs-type">int</span> capacity; <span class="hljs-comment">// 栈的容量</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">Stack</span>(<span class="hljs-type">int</span> size) &#123;<br>        arr = <span class="hljs-keyword">new</span> T[size]; <span class="hljs-comment">// 分配动态内存</span><br>        capacity = size;<br>        top = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 初始化栈顶为 -1（为空）</span><br>    &#125;<br><br>    <span class="hljs-comment">// 压栈</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T item)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == capacity - <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;栈已满，无法压入 &quot;</span> &lt;&lt; item &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        arr[++top] = item; <span class="hljs-comment">// 将数据放到栈顶，并增加栈顶索引</span><br>    &#125;<br><br>    <span class="hljs-comment">// 弹栈</span><br>    <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;栈为空，无法弹出元素&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 返回默认构造的 T 类型对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[top--]; <span class="hljs-comment">// 返回栈顶元素并减少栈顶索引</span><br>    &#125;<br><br>    <span class="hljs-comment">// 返回栈顶元素</span><br>    <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (top == <span class="hljs-number">-1</span>) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;栈为空，无法查看元素&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">T</span>(); <span class="hljs-comment">// 返回默认构造的 T 类型对象</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> arr[top];<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">Stack</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 释放动态内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 模板函数：打印数组元素</span><br><span class="hljs-function"><span class="hljs-keyword">template</span> </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用模板类</span><br>    <span class="hljs-function">Stack <span class="hljs-title">intStack</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个可以存储 5 个整数的栈</span><br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    intStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">peek</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 输出栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出的元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 弹出栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;弹出的元素: &quot;</span> &lt;&lt; intStack.<span class="hljs-built_in">pop</span>() &lt;&lt; std::endl; <span class="hljs-function">Container <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;    c<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 输出：Data: 5 MyClass  c2(&quot;Hello&quot;);    c2.print(); // 输出：Data: Hello// 使用模板函数    double arr[] = &#123;1.1, 2.2, 3.3, 4.4, 5.5&#125;;</span><br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br>    <span class="hljs-built_in">printArray</span>(arr, size); <span class="hljs-comment">// 打印数组元素</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="解释示例代码"><a href="#解释示例代码" class="headerlink" title="解释示例代码"></a>解释示例代码</h4><ul>
<li><p>模板类：在示例中，我们定义了一个 <code>Stack</code> 模板类，可以存储任何类型的数据。该类实现了基本的栈操作，包括压栈、弹栈和查看栈顶元素。</p>
</li>
<li><p>模板函数：自定义了一个 <code>printArray</code> 模板函数，用于打印数组中的元素。同样，它可以处理任何数据类型。</p>
</li>
<li><p>主函数：在 <code>main</code> 函数中，我们创建了一个 <code>Stack&lt;int&gt;</code> 的实例，并使用它进行栈操作。此外，我们还使用 <code>printArray</code> 函数打印一个 <code>double</code> 类型的数组。</p>
</li>
</ul>
<p>这样，模板的使用使得代码变得灵活且重用性高，开发者可以针对不同的类型创建相同的逻辑。</p>
<h3 id="解释引用（Reference）与指针（Pointer）之间的区别"><a href="#解释引用（Reference）与指针（Pointer）之间的区别" class="headerlink" title="解释引用（Reference）与指针（Pointer）之间的区别"></a>解释引用（Reference）与指针（Pointer）之间的区别</h3><p><strong>引用（Reference）和指针（Pointer）都是C++中用于间接访问变量的机制，但是它们有不同的定义、语法和特性。下面将详细解释引用和指针之间的主要区别。</strong></p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h4><ul>
<li><p>指针（Pointer）：</p>
</li>
<li><p>指针是一个变量，用于存储另一个变量的内存地址。它可以指向任何数据类型，使用时需要解引用（dereference）以访问指向的值。</p>
</li>
<li><p>指针可以修改其指向的对象，可以在任何时刻改变指向的地址。</p>
</li>
<li><p>引用（Reference）：</p>
</li>
<li><p>引用是一个变量的别名，为一个已有的变量起一个新的名字。引用在创建时必须初始化，并在创建后不可以改变指向的对象。</p>
</li>
<li><p>引用的使用方式与普通变量相同，可以直接使用而无需解引用。</p>
</li>
</ul>
<h4 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h4><ul>
<li><p>指针的声明和使用：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> x = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">int</span>* p = &amp;x; <span class="hljs-comment">// 声明一个指针，指向x的地址</span><br>*p = <span class="hljs-number">20</span>; <span class="hljs-comment">// 解引用指针p，修改x的值为20Copy</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>引用的声明和使用：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> <span class="hljs-keyword">x</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span>&amp; <span class="hljs-keyword">ref</span> = <span class="hljs-keyword">x</span>; <span class="hljs-regexp">//</span> <span class="hljs-keyword">ref</span>是<span class="hljs-keyword">x</span>的引用<br><span class="hljs-keyword">ref</span> = <span class="hljs-number">20</span>; <span class="hljs-regexp">//</span> 修改<span class="hljs-keyword">x</span>的值为20Copy<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3. 初始化"></a>3. 初始化</h4><ul>
<li><p>指针：</p>
</li>
<li><p>指针可以在任意时刻被初始化和重新赋值，可以为<code>nullptr</code>，也可以指向不同的变量。</p>
</li>
<li><p>例如：</p>
<figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-type">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span>* <span class="hljs-keyword">ptr</span> = &amp;a; // <span class="hljs-keyword">ptr</span>指向a<br><span class="hljs-keyword">ptr</span> = &amp;b; // 现在<span class="hljs-keyword">ptr</span>指向b<br></code></pre></td></tr></table></figure>
</li>
<li><p>引用：</p>
</li>
<li><p>引用必须在定义时进行初始化，并且初始化后就不能改变所引用的变量。</p>
</li>
<li><p>例如：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span>&amp; <span class="hljs-keyword">ref</span> = a; <span class="hljs-regexp">//</span> <span class="hljs-keyword">ref</span>引用a<br>// <span class="hljs-keyword">int</span>&amp; ref2; <span class="hljs-regexp">//</span> 错误：必须在声明时初始化<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="4-空值"><a href="#4-空值" class="headerlink" title="4. 空值"></a>4. 空值</h4><ul>
<li><p>指针：</p>
</li>
<li><p>指针可以指向<code>nullptr</code>，表示指向无效地址。</p>
</li>
<li><p>例如：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>* ptr = <span class="hljs-literal">null</span>ptr; <span class="hljs-comment">// 指针初始化为null，表示不指向任何变量</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>引用：</p>
</li>
<li><p>引用不能为<code>nullptr</code>，在定义时必须绑定到一个有效对象。</p>
</li>
</ul>
<h4 id="5-大小"><a href="#5-大小" class="headerlink" title="5. 大小"></a>5. 大小</h4><ul>
<li><p>指针的大小通常为4字节（在32位系统中）或8字节（在64位系统中），用于存储地址。</p>
</li>
<li><p>引用的大小通常与其所引用的对象相同，实际上引用会在编译时转换为相应的指针，因此它的大小与指针相同。</p>
</li>
</ul>
<h4 id="6-作用域"><a href="#6-作用域" class="headerlink" title="6. 作用域"></a>6. 作用域</h4><ul>
<li><p>指针可以在不同的作用域中声明和使用，可以改变其作用域。</p>
</li>
<li><p>引用的生命周期通常与其所引用的对象一致，一旦对象超出范围，引用变量也将不可用。</p>
</li>
</ul>
<h4 id="7-用途"><a href="#7-用途" class="headerlink" title="7. 用途"></a>7. 用途</h4><ul>
<li><p>指针：</p>
</li>
<li><p>常用于动态内存分配（例如通过<code>new</code>和<code>delete</code>）。</p>
</li>
<li><p>可以表示数组（指针可以和数组名互换使用）。</p>
</li>
<li><p>优于引用的场景如需要可选参数（可以传null）。</p>
</li>
<li><p>引用：</p>
</li>
<li><p>常用于函数参数传递（可以避免复制大对象的开销）。</p>
</li>
<li><p>适合表示对象的别名，使得语法更简洁。</p>
</li>
<li><p>适合用作返回值（返回大对象的引用而不是值）。</p>
</li>
</ul>
<h4 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个示例，展示了指针和引用的不同使用场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyWithPointer</span><span class="hljs-params">(<span class="hljs-type">int</span>* p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p) &#123; <span class="hljs-comment">// 检查指针是否为空</span><br>        *p = <span class="hljs-number">100</span>; <span class="hljs-comment">// 修改指针指向的值</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modifyWithReference</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; r)</span> </span>&#123;<br>    r = <span class="hljs-number">200</span>; <span class="hljs-comment">// 直接修改引用的值</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br>    <span class="hljs-comment">// 使用指针</span><br>    <span class="hljs-type">int</span>* ptr = &amp;a;<br>    <span class="hljs-built_in">modifyWithPointer</span>(ptr); <span class="hljs-comment">// 通过指针修改a</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;a after pointer modification: &quot;</span> &lt;&lt; a &lt;&lt; std::endl; <span class="hljs-comment">// 输出 100</span><br><br>    <span class="hljs-comment">// 使用引用</span><br>    <span class="hljs-built_in">modifyWithReference</span>(b); <span class="hljs-comment">// 通过引用修改b</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;b after reference modification: &quot;</span> &lt;&lt; b &lt;&lt; std::endl; <span class="hljs-comment">// 输出 200</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="输出-1"><a href="#输出-1" class="headerlink" title="输出"></a>输出</h4><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">a <span class="hljs-keyword">after</span> pointer modification: <span class="hljs-number">100</span><br>b <span class="hljs-keyword">after</span> <span class="hljs-keyword">reference</span> modification: <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure>

<h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>引用（Reference） 是对已有变量的别名，在使用时更为简洁、清晰，并且在生命周期上与所引用的对象一致。</p>
</li>
<li><p>指针（Pointer） 是一个可以指向不同对象及不同内存地址的变量，灵活性更强，但使用时相对复杂，需要处理指针的有效性。</p>
</li>
<li><p>在选择时，可以根据需要的灵活性和易用性来决定使用引用还是指针。</p>
</li>
</ul>
<h3 id="解释浅拷贝和深拷贝"><a href="#解释浅拷贝和深拷贝" class="headerlink" title="解释浅拷贝和深拷贝"></a>解释浅拷贝和深拷贝</h3><p><strong>在C++中，浅拷贝（Shallow Copy）和深拷贝（Deep Copy）是指在复制对象时如何处理成员变量，尤其是指针和动态分配的内存。</strong></p>
<h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><p>定义：浅拷贝会复制对象的所有成员，包括指针的值（地址），使得源对象和目标对象都指向相同的内存位置。这意味着如果一个对象释放了这段内存，另一个对象将变为悬空指针，导致未定义行为。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ShallowCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(value) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 默认深拷贝构造函数（浅拷贝）</span><br>    <span class="hljs-built_in">ShallowCopy</span>(<span class="hljs-type">const</span> ShallowCopy&amp; other) &#123;<br>        data = other.data;  <span class="hljs-comment">// 共享内存</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">ShallowCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;  <span class="hljs-comment">// 释放内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">ShallowCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    ShallowCopy obj2 = obj1; <span class="hljs-comment">// 浅拷贝</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 释放 obj1 的数据</span><br>    <span class="hljs-keyword">delete</span>[] obj<span class="hljs-number">1.</span>data;<br><br>    <span class="hljs-comment">// 此时 obj2.data 成为悬空指针，访问会导致未定义行为</span><br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;obj2 data: &quot; &lt;&lt; obj2.data &lt;&lt; std::endl; // 不安全的访问！</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，当执行 <code>delete[] obj1.data;</code> 时，<code>obj2.data</code> 也会变成一个悬空指针，造成未定义行为。</p>
<h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><p>定义：深拷贝会创建一个新对象，并为其每一个动态分配的成员（包括指针指向的内容）分配新的内存。这样，源对象与目标对象之间没有共享内存的指针。</p>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DeepCopy</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">char</span>* data;<br><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(value) + <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">strcpy</span>(data, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 自定义拷贝构造函数实现深拷贝</span><br>    <span class="hljs-built_in">DeepCopy</span>(<span class="hljs-type">const</span> DeepCopy&amp; other) &#123;<br>        data = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(other.data) + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 分配新内存</span><br>        <span class="hljs-built_in">strcpy</span>(data, other.data);  <span class="hljs-comment">// 复制内容</span><br>    &#125;<br><br>    ~<span class="hljs-built_in">DeepCopy</span>() &#123;<br>        <span class="hljs-keyword">delete</span>[] data;  <span class="hljs-comment">// 释放内存</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">DeepCopy <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello&quot;</span>)</span></span>;<br>    DeepCopy obj2 = obj1; <span class="hljs-comment">// 深拷贝</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 修改 obj1 的数据，不会影响 obj2</span><br>    obj<span class="hljs-number">1.</span>data[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;h&#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;After modification...&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj1 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">1.</span>data &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;obj2 data: &quot;</span> &lt;&lt; obj<span class="hljs-number">2.</span>data &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，每当 <code>DeepCopy</code> 对象被创建时，都会分配自己的内存，并且每个对象都是独立的。对 <code>obj1</code> 的任何修改都不会影响 <code>obj2</code>，因为它们各自拥有自己的 <code>data</code> 副本。</p>
<h4 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>浅拷贝：拷贝的是指针，多个对象会指向同一个内存区域，释放其中一个的内存会导致其他对象变成悬空指针。</p>
</li>
<li><p>深拷贝：拷贝的是实际的数据，确保每个对象都拥有独立的内存副本，修改一个对象不会影响另一个对象。</p>
</li>
</ul>
<p>在实际开发中，了解何时使用浅拷贝，何时使用深拷贝非常重要，尤其涉及到动态内存管理时。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/C-%E5%9F%BA%E7%A1%80/" class="category-chain-item">C++基础</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Cpp五个分区详解</div>
      <div>https://nicem126.github.io/2025/02/24/Cpp五个分区详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Nier Demon</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年2月24日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/15/%E9%93%B6%E6%B2%B3%E9%BA%92%E9%BA%9F%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E5%AE%9A/" title="银河麒麟账户被锁定">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">银河麒麟账户被锁定</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/24/Linux%E7%B3%BB%E7%BB%9Froot%E8%B4%A6%E6%88%B7%E8%A2%AB%E9%94%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/" title="Linux系统root账户被锁解决方法">
                        <span class="hidden-mobile">Linux系统root账户被锁解决方法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"VRmfzrVi10XWibnlJUpR9xa8-gzGzoHsz","appKey":"nwtrisoMYMghSxqd9uNxcmu1","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
